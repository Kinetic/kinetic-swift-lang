// Generated by the protocol buffer compiler.  DO NOT EDIT!
// Source file kinetic.proto

import Foundation
import ProtocolBuffers


internal struct Com { internal struct Seagate { internal struct Kinetic { internal struct Proto { }}}}

internal func == (lhs: Com.Seagate.Kinetic.Proto.Local, rhs: Com.Seagate.Kinetic.Proto.Local) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasProtocolVersion == rhs.hasProtocolVersion) && (!lhs.hasProtocolVersion || lhs.protocolVersion == rhs.protocolVersion)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

internal func == (lhs: Com.Seagate.Kinetic.Proto.Message_, rhs: Com.Seagate.Kinetic.Proto.Message_) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasAuthType == rhs.hasAuthType) && (!lhs.hasAuthType || lhs.authType == rhs.authType)
  fieldCheck = fieldCheck && (lhs.hasHmacAuth == rhs.hasHmacAuth) && (!lhs.hasHmacAuth || lhs.hmacAuth == rhs.hmacAuth)
  fieldCheck = fieldCheck && (lhs.hasPinAuth == rhs.hasPinAuth) && (!lhs.hasPinAuth || lhs.pinAuth == rhs.pinAuth)
  fieldCheck = fieldCheck && (lhs.hasCommandBytes == rhs.hasCommandBytes) && (!lhs.hasCommandBytes || lhs.commandBytes == rhs.commandBytes)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

internal func == (lhs: Com.Seagate.Kinetic.Proto.Message_.Hmacauth, rhs: Com.Seagate.Kinetic.Proto.Message_.Hmacauth) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasIdentity == rhs.hasIdentity) && (!lhs.hasIdentity || lhs.identity == rhs.identity)
  fieldCheck = fieldCheck && (lhs.hasHmac == rhs.hasHmac) && (!lhs.hasHmac || lhs.hmac == rhs.hmac)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

internal func == (lhs: Com.Seagate.Kinetic.Proto.Message_.Pinauth, rhs: Com.Seagate.Kinetic.Proto.Message_.Pinauth) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasPin == rhs.hasPin) && (!lhs.hasPin || lhs.pin == rhs.pin)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

internal func == (lhs: Com.Seagate.Kinetic.Proto.Command, rhs: Com.Seagate.Kinetic.Proto.Command) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasHeader == rhs.hasHeader) && (!lhs.hasHeader || lhs.header == rhs.header)
  fieldCheck = fieldCheck && (lhs.hasBody == rhs.hasBody) && (!lhs.hasBody || lhs.body == rhs.body)
  fieldCheck = fieldCheck && (lhs.hasStatus == rhs.hasStatus) && (!lhs.hasStatus || lhs.status == rhs.status)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

internal func == (lhs: Com.Seagate.Kinetic.Proto.Command.Header, rhs: Com.Seagate.Kinetic.Proto.Command.Header) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasClusterVersion == rhs.hasClusterVersion) && (!lhs.hasClusterVersion || lhs.clusterVersion == rhs.clusterVersion)
  fieldCheck = fieldCheck && (lhs.hasConnectionId == rhs.hasConnectionId) && (!lhs.hasConnectionId || lhs.connectionId == rhs.connectionId)
  fieldCheck = fieldCheck && (lhs.hasSequence == rhs.hasSequence) && (!lhs.hasSequence || lhs.sequence == rhs.sequence)
  fieldCheck = fieldCheck && (lhs.hasAckSequence == rhs.hasAckSequence) && (!lhs.hasAckSequence || lhs.ackSequence == rhs.ackSequence)
  fieldCheck = fieldCheck && (lhs.hasMessageType == rhs.hasMessageType) && (!lhs.hasMessageType || lhs.messageType == rhs.messageType)
  fieldCheck = fieldCheck && (lhs.hasTimeout == rhs.hasTimeout) && (!lhs.hasTimeout || lhs.timeout == rhs.timeout)
  fieldCheck = fieldCheck && (lhs.hasEarlyExit == rhs.hasEarlyExit) && (!lhs.hasEarlyExit || lhs.earlyExit == rhs.earlyExit)
  fieldCheck = fieldCheck && (lhs.hasPriority == rhs.hasPriority) && (!lhs.hasPriority || lhs.priority == rhs.priority)
  fieldCheck = fieldCheck && (lhs.hasTimeQuanta == rhs.hasTimeQuanta) && (!lhs.hasTimeQuanta || lhs.timeQuanta == rhs.timeQuanta)
  fieldCheck = fieldCheck && (lhs.hasBatchId == rhs.hasBatchId) && (!lhs.hasBatchId || lhs.batchId == rhs.batchId)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

internal func == (lhs: Com.Seagate.Kinetic.Proto.Command.Body, rhs: Com.Seagate.Kinetic.Proto.Command.Body) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasKeyValue == rhs.hasKeyValue) && (!lhs.hasKeyValue || lhs.keyValue == rhs.keyValue)
  fieldCheck = fieldCheck && (lhs.hasRange == rhs.hasRange) && (!lhs.hasRange || lhs.range == rhs.range)
  fieldCheck = fieldCheck && (lhs.hasSetup == rhs.hasSetup) && (!lhs.hasSetup || lhs.setup == rhs.setup)
  fieldCheck = fieldCheck && (lhs.hasP2POperation == rhs.hasP2POperation) && (!lhs.hasP2POperation || lhs.p2POperation == rhs.p2POperation)
  fieldCheck = fieldCheck && (lhs.hasGetLog == rhs.hasGetLog) && (!lhs.hasGetLog || lhs.getLog == rhs.getLog)
  fieldCheck = fieldCheck && (lhs.hasSecurity == rhs.hasSecurity) && (!lhs.hasSecurity || lhs.security == rhs.security)
  fieldCheck = fieldCheck && (lhs.hasPinOp == rhs.hasPinOp) && (!lhs.hasPinOp || lhs.pinOp == rhs.pinOp)
  fieldCheck = fieldCheck && (lhs.hasBatch == rhs.hasBatch) && (!lhs.hasBatch || lhs.batch == rhs.batch)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

internal func == (lhs: Com.Seagate.Kinetic.Proto.Command.Batch, rhs: Com.Seagate.Kinetic.Proto.Command.Batch) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasCount == rhs.hasCount) && (!lhs.hasCount || lhs.count == rhs.count)
  fieldCheck = fieldCheck && (lhs.sequence == rhs.sequence)
  fieldCheck = fieldCheck && (lhs.hasFailedSequence == rhs.hasFailedSequence) && (!lhs.hasFailedSequence || lhs.failedSequence == rhs.failedSequence)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

internal func == (lhs: Com.Seagate.Kinetic.Proto.Command.Status, rhs: Com.Seagate.Kinetic.Proto.Command.Status) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasCode == rhs.hasCode) && (!lhs.hasCode || lhs.code == rhs.code)
  fieldCheck = fieldCheck && (lhs.hasStatusMessage == rhs.hasStatusMessage) && (!lhs.hasStatusMessage || lhs.statusMessage == rhs.statusMessage)
  fieldCheck = fieldCheck && (lhs.hasDetailedMessage == rhs.hasDetailedMessage) && (!lhs.hasDetailedMessage || lhs.detailedMessage == rhs.detailedMessage)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

internal func == (lhs: Com.Seagate.Kinetic.Proto.Command.KeyValue, rhs: Com.Seagate.Kinetic.Proto.Command.KeyValue) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasNewVersion == rhs.hasNewVersion) && (!lhs.hasNewVersion || lhs.newVersion == rhs.newVersion)
  fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
  fieldCheck = fieldCheck && (lhs.hasDbVersion == rhs.hasDbVersion) && (!lhs.hasDbVersion || lhs.dbVersion == rhs.dbVersion)
  fieldCheck = fieldCheck && (lhs.hasTag == rhs.hasTag) && (!lhs.hasTag || lhs.tag == rhs.tag)
  fieldCheck = fieldCheck && (lhs.hasAlgorithm == rhs.hasAlgorithm) && (!lhs.hasAlgorithm || lhs.algorithm == rhs.algorithm)
  fieldCheck = fieldCheck && (lhs.hasMetadataOnly == rhs.hasMetadataOnly) && (!lhs.hasMetadataOnly || lhs.metadataOnly == rhs.metadataOnly)
  fieldCheck = fieldCheck && (lhs.hasForce == rhs.hasForce) && (!lhs.hasForce || lhs.force == rhs.force)
  fieldCheck = fieldCheck && (lhs.hasSynchronization == rhs.hasSynchronization) && (!lhs.hasSynchronization || lhs.synchronization == rhs.synchronization)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

internal func == (lhs: Com.Seagate.Kinetic.Proto.Command.Range, rhs: Com.Seagate.Kinetic.Proto.Command.Range) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasStartKey == rhs.hasStartKey) && (!lhs.hasStartKey || lhs.startKey == rhs.startKey)
  fieldCheck = fieldCheck && (lhs.hasEndKey == rhs.hasEndKey) && (!lhs.hasEndKey || lhs.endKey == rhs.endKey)
  fieldCheck = fieldCheck && (lhs.hasStartKeyInclusive == rhs.hasStartKeyInclusive) && (!lhs.hasStartKeyInclusive || lhs.startKeyInclusive == rhs.startKeyInclusive)
  fieldCheck = fieldCheck && (lhs.hasEndKeyInclusive == rhs.hasEndKeyInclusive) && (!lhs.hasEndKeyInclusive || lhs.endKeyInclusive == rhs.endKeyInclusive)
  fieldCheck = fieldCheck && (lhs.hasMaxReturned == rhs.hasMaxReturned) && (!lhs.hasMaxReturned || lhs.maxReturned == rhs.maxReturned)
  fieldCheck = fieldCheck && (lhs.hasReverse == rhs.hasReverse) && (!lhs.hasReverse || lhs.reverse == rhs.reverse)
  fieldCheck = fieldCheck && (lhs.keys == rhs.keys)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

internal func == (lhs: Com.Seagate.Kinetic.Proto.Command.Setup, rhs: Com.Seagate.Kinetic.Proto.Command.Setup) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasNewClusterVersion == rhs.hasNewClusterVersion) && (!lhs.hasNewClusterVersion || lhs.newClusterVersion == rhs.newClusterVersion)
  fieldCheck = fieldCheck && (lhs.hasFirmwareDownload == rhs.hasFirmwareDownload) && (!lhs.hasFirmwareDownload || lhs.firmwareDownload == rhs.firmwareDownload)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

internal func == (lhs: Com.Seagate.Kinetic.Proto.Command.P2Poperation, rhs: Com.Seagate.Kinetic.Proto.Command.P2Poperation) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasPeer == rhs.hasPeer) && (!lhs.hasPeer || lhs.peer == rhs.peer)
  fieldCheck = fieldCheck && (lhs.operation == rhs.operation)
  fieldCheck = fieldCheck && (lhs.hasAllChildOperationsSucceeded == rhs.hasAllChildOperationsSucceeded) && (!lhs.hasAllChildOperationsSucceeded || lhs.allChildOperationsSucceeded == rhs.allChildOperationsSucceeded)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

internal func == (lhs: Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation, rhs: Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
  fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
  fieldCheck = fieldCheck && (lhs.hasNewKey == rhs.hasNewKey) && (!lhs.hasNewKey || lhs.newKey == rhs.newKey)
  fieldCheck = fieldCheck && (lhs.hasForce == rhs.hasForce) && (!lhs.hasForce || lhs.force == rhs.force)
  fieldCheck = fieldCheck && (lhs.hasStatus == rhs.hasStatus) && (!lhs.hasStatus || lhs.status == rhs.status)
  fieldCheck = fieldCheck && (lhs.hasP2Pop == rhs.hasP2Pop) && (!lhs.hasP2Pop || lhs.p2Pop == rhs.p2Pop)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

internal func == (lhs: Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer, rhs: Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasHostname == rhs.hasHostname) && (!lhs.hasHostname || lhs.hostname == rhs.hostname)
  fieldCheck = fieldCheck && (lhs.hasPort == rhs.hasPort) && (!lhs.hasPort || lhs.port == rhs.port)
  fieldCheck = fieldCheck && (lhs.hasTls == rhs.hasTls) && (!lhs.hasTls || lhs.tls == rhs.tls)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

internal func == (lhs: Com.Seagate.Kinetic.Proto.Command.GetLog, rhs: Com.Seagate.Kinetic.Proto.Command.GetLog) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.types == rhs.types)
  fieldCheck = fieldCheck && (lhs.utilizations == rhs.utilizations)
  fieldCheck = fieldCheck && (lhs.temperatures == rhs.temperatures)
  fieldCheck = fieldCheck && (lhs.hasCapacity == rhs.hasCapacity) && (!lhs.hasCapacity || lhs.capacity == rhs.capacity)
  fieldCheck = fieldCheck && (lhs.hasConfiguration == rhs.hasConfiguration) && (!lhs.hasConfiguration || lhs.configuration == rhs.configuration)
  fieldCheck = fieldCheck && (lhs.statistics == rhs.statistics)
  fieldCheck = fieldCheck && (lhs.hasMessages == rhs.hasMessages) && (!lhs.hasMessages || lhs.messages == rhs.messages)
  fieldCheck = fieldCheck && (lhs.hasLimits == rhs.hasLimits) && (!lhs.hasLimits || lhs.limits == rhs.limits)
  fieldCheck = fieldCheck && (lhs.hasDevice == rhs.hasDevice) && (!lhs.hasDevice || lhs.device == rhs.device)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

internal func == (lhs: Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization, rhs: Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

internal func == (lhs: Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature, rhs: Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.hasCurrent == rhs.hasCurrent) && (!lhs.hasCurrent || lhs.current == rhs.current)
  fieldCheck = fieldCheck && (lhs.hasMinimum == rhs.hasMinimum) && (!lhs.hasMinimum || lhs.minimum == rhs.minimum)
  fieldCheck = fieldCheck && (lhs.hasMaximum == rhs.hasMaximum) && (!lhs.hasMaximum || lhs.maximum == rhs.maximum)
  fieldCheck = fieldCheck && (lhs.hasTarget == rhs.hasTarget) && (!lhs.hasTarget || lhs.target == rhs.target)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

internal func == (lhs: Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity, rhs: Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasNominalCapacityInBytes == rhs.hasNominalCapacityInBytes) && (!lhs.hasNominalCapacityInBytes || lhs.nominalCapacityInBytes == rhs.nominalCapacityInBytes)
  fieldCheck = fieldCheck && (lhs.hasPortionFull == rhs.hasPortionFull) && (!lhs.hasPortionFull || lhs.portionFull == rhs.portionFull)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

internal func == (lhs: Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration, rhs: Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasVendor == rhs.hasVendor) && (!lhs.hasVendor || lhs.vendor == rhs.vendor)
  fieldCheck = fieldCheck && (lhs.hasModel == rhs.hasModel) && (!lhs.hasModel || lhs.model == rhs.model)
  fieldCheck = fieldCheck && (lhs.hasSerialNumber == rhs.hasSerialNumber) && (!lhs.hasSerialNumber || lhs.serialNumber == rhs.serialNumber)
  fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
  fieldCheck = fieldCheck && (lhs.interface == rhs.interface)
  fieldCheck = fieldCheck && (lhs.hasPort == rhs.hasPort) && (!lhs.hasPort || lhs.port == rhs.port)
  fieldCheck = fieldCheck && (lhs.hasTlsPort == rhs.hasTlsPort) && (!lhs.hasTlsPort || lhs.tlsPort == rhs.tlsPort)
  fieldCheck = fieldCheck && (lhs.hasCompilationDate == rhs.hasCompilationDate) && (!lhs.hasCompilationDate || lhs.compilationDate == rhs.compilationDate)
  fieldCheck = fieldCheck && (lhs.hasSourceHash == rhs.hasSourceHash) && (!lhs.hasSourceHash || lhs.sourceHash == rhs.sourceHash)
  fieldCheck = fieldCheck && (lhs.hasWorldWideName == rhs.hasWorldWideName) && (!lhs.hasWorldWideName || lhs.worldWideName == rhs.worldWideName)
  fieldCheck = fieldCheck && (lhs.hasProtocolVersion == rhs.hasProtocolVersion) && (!lhs.hasProtocolVersion || lhs.protocolVersion == rhs.protocolVersion)
  fieldCheck = fieldCheck && (lhs.hasProtocolCompilationDate == rhs.hasProtocolCompilationDate) && (!lhs.hasProtocolCompilationDate || lhs.protocolCompilationDate == rhs.protocolCompilationDate)
  fieldCheck = fieldCheck && (lhs.hasProtocolSourceHash == rhs.hasProtocolSourceHash) && (!lhs.hasProtocolSourceHash || lhs.protocolSourceHash == rhs.protocolSourceHash)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

internal func == (lhs: Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface, rhs: Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.hasMac == rhs.hasMac) && (!lhs.hasMac || lhs.mac == rhs.mac)
  fieldCheck = fieldCheck && (lhs.hasIpv4Address == rhs.hasIpv4Address) && (!lhs.hasIpv4Address || lhs.ipv4Address == rhs.ipv4Address)
  fieldCheck = fieldCheck && (lhs.hasIpv6Address == rhs.hasIpv6Address) && (!lhs.hasIpv6Address || lhs.ipv6Address == rhs.ipv6Address)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

internal func == (lhs: Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics, rhs: Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasMessageType == rhs.hasMessageType) && (!lhs.hasMessageType || lhs.messageType == rhs.messageType)
  fieldCheck = fieldCheck && (lhs.hasCount == rhs.hasCount) && (!lhs.hasCount || lhs.count == rhs.count)
  fieldCheck = fieldCheck && (lhs.hasBytes == rhs.hasBytes) && (!lhs.hasBytes || lhs.bytes == rhs.bytes)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

internal func == (lhs: Com.Seagate.Kinetic.Proto.Command.GetLog.Limits, rhs: Com.Seagate.Kinetic.Proto.Command.GetLog.Limits) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasMaxKeySize == rhs.hasMaxKeySize) && (!lhs.hasMaxKeySize || lhs.maxKeySize == rhs.maxKeySize)
  fieldCheck = fieldCheck && (lhs.hasMaxValueSize == rhs.hasMaxValueSize) && (!lhs.hasMaxValueSize || lhs.maxValueSize == rhs.maxValueSize)
  fieldCheck = fieldCheck && (lhs.hasMaxVersionSize == rhs.hasMaxVersionSize) && (!lhs.hasMaxVersionSize || lhs.maxVersionSize == rhs.maxVersionSize)
  fieldCheck = fieldCheck && (lhs.hasMaxTagSize == rhs.hasMaxTagSize) && (!lhs.hasMaxTagSize || lhs.maxTagSize == rhs.maxTagSize)
  fieldCheck = fieldCheck && (lhs.hasMaxConnections == rhs.hasMaxConnections) && (!lhs.hasMaxConnections || lhs.maxConnections == rhs.maxConnections)
  fieldCheck = fieldCheck && (lhs.hasMaxOutstandingReadRequests == rhs.hasMaxOutstandingReadRequests) && (!lhs.hasMaxOutstandingReadRequests || lhs.maxOutstandingReadRequests == rhs.maxOutstandingReadRequests)
  fieldCheck = fieldCheck && (lhs.hasMaxOutstandingWriteRequests == rhs.hasMaxOutstandingWriteRequests) && (!lhs.hasMaxOutstandingWriteRequests || lhs.maxOutstandingWriteRequests == rhs.maxOutstandingWriteRequests)
  fieldCheck = fieldCheck && (lhs.hasMaxMessageSize == rhs.hasMaxMessageSize) && (!lhs.hasMaxMessageSize || lhs.maxMessageSize == rhs.maxMessageSize)
  fieldCheck = fieldCheck && (lhs.hasMaxKeyRangeCount == rhs.hasMaxKeyRangeCount) && (!lhs.hasMaxKeyRangeCount || lhs.maxKeyRangeCount == rhs.maxKeyRangeCount)
  fieldCheck = fieldCheck && (lhs.hasMaxIdentityCount == rhs.hasMaxIdentityCount) && (!lhs.hasMaxIdentityCount || lhs.maxIdentityCount == rhs.maxIdentityCount)
  fieldCheck = fieldCheck && (lhs.hasMaxPinSize == rhs.hasMaxPinSize) && (!lhs.hasMaxPinSize || lhs.maxPinSize == rhs.maxPinSize)
  fieldCheck = fieldCheck && (lhs.hasMaxOperationCountPerBatch == rhs.hasMaxOperationCountPerBatch) && (!lhs.hasMaxOperationCountPerBatch || lhs.maxOperationCountPerBatch == rhs.maxOperationCountPerBatch)
  fieldCheck = fieldCheck && (lhs.hasMaxBatchCountPerDevice == rhs.hasMaxBatchCountPerDevice) && (!lhs.hasMaxBatchCountPerDevice || lhs.maxBatchCountPerDevice == rhs.maxBatchCountPerDevice)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

internal func == (lhs: Com.Seagate.Kinetic.Proto.Command.GetLog.Device, rhs: Com.Seagate.Kinetic.Proto.Command.GetLog.Device) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

internal func == (lhs: Com.Seagate.Kinetic.Proto.Command.Security, rhs: Com.Seagate.Kinetic.Proto.Command.Security) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.acl == rhs.acl)
  fieldCheck = fieldCheck && (lhs.hasOldLockPin == rhs.hasOldLockPin) && (!lhs.hasOldLockPin || lhs.oldLockPin == rhs.oldLockPin)
  fieldCheck = fieldCheck && (lhs.hasNewLockPin == rhs.hasNewLockPin) && (!lhs.hasNewLockPin || lhs.newLockPin == rhs.newLockPin)
  fieldCheck = fieldCheck && (lhs.hasOldErasePin == rhs.hasOldErasePin) && (!lhs.hasOldErasePin || lhs.oldErasePin == rhs.oldErasePin)
  fieldCheck = fieldCheck && (lhs.hasNewErasePin == rhs.hasNewErasePin) && (!lhs.hasNewErasePin || lhs.newErasePin == rhs.newErasePin)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

internal func == (lhs: Com.Seagate.Kinetic.Proto.Command.Security.Acl, rhs: Com.Seagate.Kinetic.Proto.Command.Security.Acl) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasIdentity == rhs.hasIdentity) && (!lhs.hasIdentity || lhs.identity == rhs.identity)
  fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
  fieldCheck = fieldCheck && (lhs.hasHmacAlgorithm == rhs.hasHmacAlgorithm) && (!lhs.hasHmacAlgorithm || lhs.hmacAlgorithm == rhs.hmacAlgorithm)
  fieldCheck = fieldCheck && (lhs.scope == rhs.scope)
  fieldCheck = fieldCheck && (lhs.hasMaxPriority == rhs.hasMaxPriority) && (!lhs.hasMaxPriority || lhs.maxPriority == rhs.maxPriority)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

internal func == (lhs: Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope, rhs: Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasOffset == rhs.hasOffset) && (!lhs.hasOffset || lhs.offset == rhs.offset)
  fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
  fieldCheck = fieldCheck && (lhs.permission == rhs.permission)
  fieldCheck = fieldCheck && (lhs.hasTlsRequired == rhs.hasTlsRequired) && (!lhs.hasTlsRequired || lhs.tlsRequired == rhs.tlsRequired)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

internal func == (lhs: Com.Seagate.Kinetic.Proto.Command.PinOperation, rhs: Com.Seagate.Kinetic.Proto.Command.PinOperation) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasPinOpType == rhs.hasPinOpType) && (!lhs.hasPinOpType || lhs.pinOpType == rhs.pinOpType)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

internal extension Com.Seagate.Kinetic.Proto {
  internal struct KineticRoot {
    internal static var sharedInstance : KineticRoot {
     struct Static {
         static let instance : KineticRoot = KineticRoot()
     }
     return Static.instance
    }
    internal var extensionRegistry:ExtensionRegistry

    init() {
      extensionRegistry = ExtensionRegistry()
      registerAllExtensions(extensionRegistry)
    }
    internal func registerAllExtensions(registry:ExtensionRegistry) {
    }
  }

  final internal class Local : GeneratedMessage, GeneratedMessageProtocol {
    private(set) var hasProtocolVersion:Bool = false
    private(set) var protocolVersion:String = "3.0.6"

    required internal init() {
         super.init()
    }
    override internal func isInitialized() -> Bool {
     return true
    }
    override internal func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasProtocolVersion {
        try output.writeString(1, value:protocolVersion)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override internal func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasProtocolVersion {
        serialize_size += protocolVersion.computeStringSize(1)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    internal class func parseFromData(data:NSData) throws -> Com.Seagate.Kinetic.Proto.Local {
      return try Com.Seagate.Kinetic.Proto.Local.Builder().mergeFromData(data, extensionRegistry:Com.Seagate.Kinetic.Proto.KineticRoot.sharedInstance.extensionRegistry).build()
    }
    internal class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Local {
      return try Com.Seagate.Kinetic.Proto.Local.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    internal class func parseFromInputStream(input:NSInputStream) throws -> Com.Seagate.Kinetic.Proto.Local {
      return try Com.Seagate.Kinetic.Proto.Local.Builder().mergeFromInputStream(input).build()
    }
    internal class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Local {
      return try Com.Seagate.Kinetic.Proto.Local.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    internal class func parseFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Local {
      return try Com.Seagate.Kinetic.Proto.Local.Builder().mergeFromCodedInputStream(input).build()
    }
    internal class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Local {
      return try Com.Seagate.Kinetic.Proto.Local.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    internal class func getBuilder() -> Com.Seagate.Kinetic.Proto.Local.Builder {
      return Com.Seagate.Kinetic.Proto.Local.classBuilder() as! Com.Seagate.Kinetic.Proto.Local.Builder
    }
    internal func getBuilder() -> Com.Seagate.Kinetic.Proto.Local.Builder {
      return classBuilder() as! Com.Seagate.Kinetic.Proto.Local.Builder
    }
    internal override class func classBuilder() -> MessageBuilder {
      return Com.Seagate.Kinetic.Proto.Local.Builder()
    }
    internal override func classBuilder() -> MessageBuilder {
      return Com.Seagate.Kinetic.Proto.Local.Builder()
    }
    internal func toBuilder() throws -> Com.Seagate.Kinetic.Proto.Local.Builder {
      return try Com.Seagate.Kinetic.Proto.Local.builderWithPrototype(self)
    }
    internal class func builderWithPrototype(prototype:Com.Seagate.Kinetic.Proto.Local) throws -> Com.Seagate.Kinetic.Proto.Local.Builder {
      return try Com.Seagate.Kinetic.Proto.Local.Builder().mergeFrom(prototype)
    }
    override internal func writeDescriptionTo(inout output:String, indent:String) throws {
      if hasProtocolVersion {
        output += "\(indent) protocolVersion: \(protocolVersion) \n"
      }
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override internal var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasProtocolVersion {
               hashCode = (hashCode &* 31) &+ protocolVersion.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override internal class func className() -> String {
        return "Com.Seagate.Kinetic.Proto.Local"
    }
    override internal func className() -> String {
        return "Com.Seagate.Kinetic.Proto.Local"
    }
    override internal func classMetaType() -> GeneratedMessage.Type {
        return Com.Seagate.Kinetic.Proto.Local.self
    }
    //Meta information declaration end

    final internal class Builder : GeneratedMessageBuilder {
      private var builderResult:Com.Seagate.Kinetic.Proto.Local = Com.Seagate.Kinetic.Proto.Local()
      internal func getMessage() -> Com.Seagate.Kinetic.Proto.Local {
          return builderResult
      }

      required override internal init () {
         super.init()
      }
      var hasProtocolVersion:Bool {
           get {
                return builderResult.hasProtocolVersion
           }
      }
      var protocolVersion:String {
           get {
                return builderResult.protocolVersion
           }
           set (value) {
               builderResult.hasProtocolVersion = true
               builderResult.protocolVersion = value
           }
      }
      func setProtocolVersion(value:String) -> Com.Seagate.Kinetic.Proto.Local.Builder {
        self.protocolVersion = value
        return self
      }
      internal func clearProtocolVersion() -> Com.Seagate.Kinetic.Proto.Local.Builder{
           builderResult.hasProtocolVersion = false
           builderResult.protocolVersion = "3.0.6"
           return self
      }
      override internal var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      internal override func clear() -> Com.Seagate.Kinetic.Proto.Local.Builder {
        builderResult = Com.Seagate.Kinetic.Proto.Local()
        return self
      }
      internal override func clone() throws -> Com.Seagate.Kinetic.Proto.Local.Builder {
        return try Com.Seagate.Kinetic.Proto.Local.builderWithPrototype(builderResult)
      }
      internal override func build() throws -> Com.Seagate.Kinetic.Proto.Local {
           try checkInitialized()
           return buildPartial()
      }
      internal func buildPartial() -> Com.Seagate.Kinetic.Proto.Local {
        let returnMe:Com.Seagate.Kinetic.Proto.Local = builderResult
        return returnMe
      }
      internal func mergeFrom(other:Com.Seagate.Kinetic.Proto.Local) throws -> Com.Seagate.Kinetic.Proto.Local.Builder {
        if other == Com.Seagate.Kinetic.Proto.Local() {
         return self
        }
        if other.hasProtocolVersion {
             protocolVersion = other.protocolVersion
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      internal override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Local.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      internal override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Local.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let tag = try input.readTag()
          switch tag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10 :
            protocolVersion = try input.readString()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }

  }

  final internal class Message_ : GeneratedMessage, GeneratedMessageProtocol {


    //Nested type declaration start

      final internal class Hmacauth : GeneratedMessage, GeneratedMessageProtocol {
        private(set) var hasIdentity:Bool = false
        private(set) var identity:Int64 = Int64(0)

        private(set) var hasHmac:Bool = false
        private(set) var hmac:NSData = NSData()

        required internal init() {
             super.init()
        }
        override internal func isInitialized() -> Bool {
         return true
        }
        override internal func writeToCodedOutputStream(output:CodedOutputStream) throws {
          if hasIdentity {
            try output.writeInt64(1, value:identity)
          }
          if hasHmac {
            try output.writeData(2, value:hmac)
          }
          try unknownFields.writeToCodedOutputStream(output)
        }
        override internal func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          if hasIdentity {
            serialize_size += identity.computeInt64Size(1)
          }
          if hasHmac {
            serialize_size += hmac.computeDataSize(2)
          }
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        internal class func parseFromData(data:NSData) throws -> Com.Seagate.Kinetic.Proto.Message_.Hmacauth {
          return try Com.Seagate.Kinetic.Proto.Message_.Hmacauth.Builder().mergeFromData(data, extensionRegistry:Com.Seagate.Kinetic.Proto.KineticRoot.sharedInstance.extensionRegistry).build()
        }
        internal class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Message_.Hmacauth {
          return try Com.Seagate.Kinetic.Proto.Message_.Hmacauth.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
        }
        internal class func parseFromInputStream(input:NSInputStream) throws -> Com.Seagate.Kinetic.Proto.Message_.Hmacauth {
          return try Com.Seagate.Kinetic.Proto.Message_.Hmacauth.Builder().mergeFromInputStream(input).build()
        }
        internal class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Message_.Hmacauth {
          return try Com.Seagate.Kinetic.Proto.Message_.Hmacauth.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        internal class func parseFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Message_.Hmacauth {
          return try Com.Seagate.Kinetic.Proto.Message_.Hmacauth.Builder().mergeFromCodedInputStream(input).build()
        }
        internal class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Message_.Hmacauth {
          return try Com.Seagate.Kinetic.Proto.Message_.Hmacauth.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        internal class func getBuilder() -> Com.Seagate.Kinetic.Proto.Message_.Hmacauth.Builder {
          return Com.Seagate.Kinetic.Proto.Message_.Hmacauth.classBuilder() as! Com.Seagate.Kinetic.Proto.Message_.Hmacauth.Builder
        }
        internal func getBuilder() -> Com.Seagate.Kinetic.Proto.Message_.Hmacauth.Builder {
          return classBuilder() as! Com.Seagate.Kinetic.Proto.Message_.Hmacauth.Builder
        }
        internal override class func classBuilder() -> MessageBuilder {
          return Com.Seagate.Kinetic.Proto.Message_.Hmacauth.Builder()
        }
        internal override func classBuilder() -> MessageBuilder {
          return Com.Seagate.Kinetic.Proto.Message_.Hmacauth.Builder()
        }
        internal func toBuilder() throws -> Com.Seagate.Kinetic.Proto.Message_.Hmacauth.Builder {
          return try Com.Seagate.Kinetic.Proto.Message_.Hmacauth.builderWithPrototype(self)
        }
        internal class func builderWithPrototype(prototype:Com.Seagate.Kinetic.Proto.Message_.Hmacauth) throws -> Com.Seagate.Kinetic.Proto.Message_.Hmacauth.Builder {
          return try Com.Seagate.Kinetic.Proto.Message_.Hmacauth.Builder().mergeFrom(prototype)
        }
        override internal func writeDescriptionTo(inout output:String, indent:String) throws {
          if hasIdentity {
            output += "\(indent) identity: \(identity) \n"
          }
          if hasHmac {
            output += "\(indent) hmac: \(hmac) \n"
          }
          unknownFields.writeDescriptionTo(&output, indent:indent)
        }
        override internal var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasIdentity {
                   hashCode = (hashCode &* 31) &+ identity.hashValue
                }
                if hasHmac {
                   hashCode = (hashCode &* 31) &+ hmac.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override internal class func className() -> String {
            return "Com.Seagate.Kinetic.Proto.Message_.Hmacauth"
        }
        override internal func className() -> String {
            return "Com.Seagate.Kinetic.Proto.Message_.Hmacauth"
        }
        override internal func classMetaType() -> GeneratedMessage.Type {
            return Com.Seagate.Kinetic.Proto.Message_.Hmacauth.self
        }
        //Meta information declaration end

        final internal class Builder : GeneratedMessageBuilder {
          private var builderResult:Com.Seagate.Kinetic.Proto.Message_.Hmacauth = Com.Seagate.Kinetic.Proto.Message_.Hmacauth()
          internal func getMessage() -> Com.Seagate.Kinetic.Proto.Message_.Hmacauth {
              return builderResult
          }

          required override internal init () {
             super.init()
          }
          var hasIdentity:Bool {
               get {
                    return builderResult.hasIdentity
               }
          }
          var identity:Int64 {
               get {
                    return builderResult.identity
               }
               set (value) {
                   builderResult.hasIdentity = true
                   builderResult.identity = value
               }
          }
          func setIdentity(value:Int64) -> Com.Seagate.Kinetic.Proto.Message_.Hmacauth.Builder {
            self.identity = value
            return self
          }
          internal func clearIdentity() -> Com.Seagate.Kinetic.Proto.Message_.Hmacauth.Builder{
               builderResult.hasIdentity = false
               builderResult.identity = Int64(0)
               return self
          }
          var hasHmac:Bool {
               get {
                    return builderResult.hasHmac
               }
          }
          var hmac:NSData {
               get {
                    return builderResult.hmac
               }
               set (value) {
                   builderResult.hasHmac = true
                   builderResult.hmac = value
               }
          }
          func setHmac(value:NSData) -> Com.Seagate.Kinetic.Proto.Message_.Hmacauth.Builder {
            self.hmac = value
            return self
          }
          internal func clearHmac() -> Com.Seagate.Kinetic.Proto.Message_.Hmacauth.Builder{
               builderResult.hasHmac = false
               builderResult.hmac = NSData()
               return self
          }
          override internal var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          internal override func clear() -> Com.Seagate.Kinetic.Proto.Message_.Hmacauth.Builder {
            builderResult = Com.Seagate.Kinetic.Proto.Message_.Hmacauth()
            return self
          }
          internal override func clone() throws -> Com.Seagate.Kinetic.Proto.Message_.Hmacauth.Builder {
            return try Com.Seagate.Kinetic.Proto.Message_.Hmacauth.builderWithPrototype(builderResult)
          }
          internal override func build() throws -> Com.Seagate.Kinetic.Proto.Message_.Hmacauth {
               try checkInitialized()
               return buildPartial()
          }
          internal func buildPartial() -> Com.Seagate.Kinetic.Proto.Message_.Hmacauth {
            let returnMe:Com.Seagate.Kinetic.Proto.Message_.Hmacauth = builderResult
            return returnMe
          }
          internal func mergeFrom(other:Com.Seagate.Kinetic.Proto.Message_.Hmacauth) throws -> Com.Seagate.Kinetic.Proto.Message_.Hmacauth.Builder {
            if other == Com.Seagate.Kinetic.Proto.Message_.Hmacauth() {
             return self
            }
            if other.hasIdentity {
                 identity = other.identity
            }
            if other.hasHmac {
                 hmac = other.hmac
            }
            try mergeUnknownFields(other.unknownFields)
            return self
          }
          internal override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Message_.Hmacauth.Builder {
               return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
          }
          internal override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Message_.Hmacauth.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
            while (true) {
              let tag = try input.readTag()
              switch tag {
              case 0: 
                self.unknownFields = try unknownFieldsBuilder.build()
                return self

              case 8 :
                identity = try input.readInt64()

              case 18 :
                hmac = try input.readData()

              default:
                if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag))) {
                   unknownFields = try unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
        }

      }

    //Nested type declaration end



    //Nested type declaration start

      final internal class Pinauth : GeneratedMessage, GeneratedMessageProtocol {
        private(set) var hasPin:Bool = false
        private(set) var pin:NSData = NSData()

        required internal init() {
             super.init()
        }
        override internal func isInitialized() -> Bool {
         return true
        }
        override internal func writeToCodedOutputStream(output:CodedOutputStream) throws {
          if hasPin {
            try output.writeData(1, value:pin)
          }
          try unknownFields.writeToCodedOutputStream(output)
        }
        override internal func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          if hasPin {
            serialize_size += pin.computeDataSize(1)
          }
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        internal class func parseFromData(data:NSData) throws -> Com.Seagate.Kinetic.Proto.Message_.Pinauth {
          return try Com.Seagate.Kinetic.Proto.Message_.Pinauth.Builder().mergeFromData(data, extensionRegistry:Com.Seagate.Kinetic.Proto.KineticRoot.sharedInstance.extensionRegistry).build()
        }
        internal class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Message_.Pinauth {
          return try Com.Seagate.Kinetic.Proto.Message_.Pinauth.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
        }
        internal class func parseFromInputStream(input:NSInputStream) throws -> Com.Seagate.Kinetic.Proto.Message_.Pinauth {
          return try Com.Seagate.Kinetic.Proto.Message_.Pinauth.Builder().mergeFromInputStream(input).build()
        }
        internal class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Message_.Pinauth {
          return try Com.Seagate.Kinetic.Proto.Message_.Pinauth.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        internal class func parseFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Message_.Pinauth {
          return try Com.Seagate.Kinetic.Proto.Message_.Pinauth.Builder().mergeFromCodedInputStream(input).build()
        }
        internal class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Message_.Pinauth {
          return try Com.Seagate.Kinetic.Proto.Message_.Pinauth.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        internal class func getBuilder() -> Com.Seagate.Kinetic.Proto.Message_.Pinauth.Builder {
          return Com.Seagate.Kinetic.Proto.Message_.Pinauth.classBuilder() as! Com.Seagate.Kinetic.Proto.Message_.Pinauth.Builder
        }
        internal func getBuilder() -> Com.Seagate.Kinetic.Proto.Message_.Pinauth.Builder {
          return classBuilder() as! Com.Seagate.Kinetic.Proto.Message_.Pinauth.Builder
        }
        internal override class func classBuilder() -> MessageBuilder {
          return Com.Seagate.Kinetic.Proto.Message_.Pinauth.Builder()
        }
        internal override func classBuilder() -> MessageBuilder {
          return Com.Seagate.Kinetic.Proto.Message_.Pinauth.Builder()
        }
        internal func toBuilder() throws -> Com.Seagate.Kinetic.Proto.Message_.Pinauth.Builder {
          return try Com.Seagate.Kinetic.Proto.Message_.Pinauth.builderWithPrototype(self)
        }
        internal class func builderWithPrototype(prototype:Com.Seagate.Kinetic.Proto.Message_.Pinauth) throws -> Com.Seagate.Kinetic.Proto.Message_.Pinauth.Builder {
          return try Com.Seagate.Kinetic.Proto.Message_.Pinauth.Builder().mergeFrom(prototype)
        }
        override internal func writeDescriptionTo(inout output:String, indent:String) throws {
          if hasPin {
            output += "\(indent) pin: \(pin) \n"
          }
          unknownFields.writeDescriptionTo(&output, indent:indent)
        }
        override internal var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasPin {
                   hashCode = (hashCode &* 31) &+ pin.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override internal class func className() -> String {
            return "Com.Seagate.Kinetic.Proto.Message_.Pinauth"
        }
        override internal func className() -> String {
            return "Com.Seagate.Kinetic.Proto.Message_.Pinauth"
        }
        override internal func classMetaType() -> GeneratedMessage.Type {
            return Com.Seagate.Kinetic.Proto.Message_.Pinauth.self
        }
        //Meta information declaration end

        final internal class Builder : GeneratedMessageBuilder {
          private var builderResult:Com.Seagate.Kinetic.Proto.Message_.Pinauth = Com.Seagate.Kinetic.Proto.Message_.Pinauth()
          internal func getMessage() -> Com.Seagate.Kinetic.Proto.Message_.Pinauth {
              return builderResult
          }

          required override internal init () {
             super.init()
          }
          var hasPin:Bool {
               get {
                    return builderResult.hasPin
               }
          }
          var pin:NSData {
               get {
                    return builderResult.pin
               }
               set (value) {
                   builderResult.hasPin = true
                   builderResult.pin = value
               }
          }
          func setPin(value:NSData) -> Com.Seagate.Kinetic.Proto.Message_.Pinauth.Builder {
            self.pin = value
            return self
          }
          internal func clearPin() -> Com.Seagate.Kinetic.Proto.Message_.Pinauth.Builder{
               builderResult.hasPin = false
               builderResult.pin = NSData()
               return self
          }
          override internal var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          internal override func clear() -> Com.Seagate.Kinetic.Proto.Message_.Pinauth.Builder {
            builderResult = Com.Seagate.Kinetic.Proto.Message_.Pinauth()
            return self
          }
          internal override func clone() throws -> Com.Seagate.Kinetic.Proto.Message_.Pinauth.Builder {
            return try Com.Seagate.Kinetic.Proto.Message_.Pinauth.builderWithPrototype(builderResult)
          }
          internal override func build() throws -> Com.Seagate.Kinetic.Proto.Message_.Pinauth {
               try checkInitialized()
               return buildPartial()
          }
          internal func buildPartial() -> Com.Seagate.Kinetic.Proto.Message_.Pinauth {
            let returnMe:Com.Seagate.Kinetic.Proto.Message_.Pinauth = builderResult
            return returnMe
          }
          internal func mergeFrom(other:Com.Seagate.Kinetic.Proto.Message_.Pinauth) throws -> Com.Seagate.Kinetic.Proto.Message_.Pinauth.Builder {
            if other == Com.Seagate.Kinetic.Proto.Message_.Pinauth() {
             return self
            }
            if other.hasPin {
                 pin = other.pin
            }
            try mergeUnknownFields(other.unknownFields)
            return self
          }
          internal override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Message_.Pinauth.Builder {
               return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
          }
          internal override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Message_.Pinauth.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
            while (true) {
              let tag = try input.readTag()
              switch tag {
              case 0: 
                self.unknownFields = try unknownFieldsBuilder.build()
                return self

              case 10 :
                pin = try input.readData()

              default:
                if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag))) {
                   unknownFields = try unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
        }

      }

    //Nested type declaration end



      //Enum type declaration start 

      internal enum AuthType:Int32 {
        case InvalidAuthType = -1
        case Hmacauth = 1
        case Pinauth = 2
        case Unsolicitedstatus = 3

      }

      //Enum type declaration end 

    private(set) var authType:Message_.AuthType = Message_.AuthType.InvalidAuthType
    private(set) var hasAuthType:Bool = false
    private(set) var hasHmacAuth:Bool = false
    private(set) var hmacAuth:Com.Seagate.Kinetic.Proto.Message_.Hmacauth!
    private(set) var hasPinAuth:Bool = false
    private(set) var pinAuth:Com.Seagate.Kinetic.Proto.Message_.Pinauth!
    private(set) var hasCommandBytes:Bool = false
    private(set) var commandBytes:NSData = NSData()

    required internal init() {
         super.init()
    }
    override internal func isInitialized() -> Bool {
     return true
    }
    override internal func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasAuthType {
        try output.writeEnum(4, value:authType.rawValue)
      }
      if hasHmacAuth {
        try output.writeMessage(5, value:hmacAuth)
      }
      if hasPinAuth {
        try output.writeMessage(6, value:pinAuth)
      }
      if hasCommandBytes {
        try output.writeData(7, value:commandBytes)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override internal func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasAuthType) {
        serialize_size += authType.rawValue.computeEnumSize(4)
      }
      if hasHmacAuth {
          if let varSizehmacAuth = hmacAuth?.computeMessageSize(5) {
              serialize_size += varSizehmacAuth
          }
      }
      if hasPinAuth {
          if let varSizepinAuth = pinAuth?.computeMessageSize(6) {
              serialize_size += varSizepinAuth
          }
      }
      if hasCommandBytes {
        serialize_size += commandBytes.computeDataSize(7)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    internal class func parseFromData(data:NSData) throws -> Com.Seagate.Kinetic.Proto.Message_ {
      return try Com.Seagate.Kinetic.Proto.Message_.Builder().mergeFromData(data, extensionRegistry:Com.Seagate.Kinetic.Proto.KineticRoot.sharedInstance.extensionRegistry).build()
    }
    internal class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Message_ {
      return try Com.Seagate.Kinetic.Proto.Message_.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    internal class func parseFromInputStream(input:NSInputStream) throws -> Com.Seagate.Kinetic.Proto.Message_ {
      return try Com.Seagate.Kinetic.Proto.Message_.Builder().mergeFromInputStream(input).build()
    }
    internal class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Message_ {
      return try Com.Seagate.Kinetic.Proto.Message_.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    internal class func parseFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Message_ {
      return try Com.Seagate.Kinetic.Proto.Message_.Builder().mergeFromCodedInputStream(input).build()
    }
    internal class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Message_ {
      return try Com.Seagate.Kinetic.Proto.Message_.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    internal class func getBuilder() -> Com.Seagate.Kinetic.Proto.Message_.Builder {
      return Com.Seagate.Kinetic.Proto.Message_.classBuilder() as! Com.Seagate.Kinetic.Proto.Message_.Builder
    }
    internal func getBuilder() -> Com.Seagate.Kinetic.Proto.Message_.Builder {
      return classBuilder() as! Com.Seagate.Kinetic.Proto.Message_.Builder
    }
    internal override class func classBuilder() -> MessageBuilder {
      return Com.Seagate.Kinetic.Proto.Message_.Builder()
    }
    internal override func classBuilder() -> MessageBuilder {
      return Com.Seagate.Kinetic.Proto.Message_.Builder()
    }
    internal func toBuilder() throws -> Com.Seagate.Kinetic.Proto.Message_.Builder {
      return try Com.Seagate.Kinetic.Proto.Message_.builderWithPrototype(self)
    }
    internal class func builderWithPrototype(prototype:Com.Seagate.Kinetic.Proto.Message_) throws -> Com.Seagate.Kinetic.Proto.Message_.Builder {
      return try Com.Seagate.Kinetic.Proto.Message_.Builder().mergeFrom(prototype)
    }
    override internal func writeDescriptionTo(inout output:String, indent:String) throws {
      if (hasAuthType) {
        output += "\(indent) authType: \(authType.rawValue)\n"
      }
      if hasHmacAuth {
        output += "\(indent) hmacAuth {\n"
        try hmacAuth?.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent) }\n"
      }
      if hasPinAuth {
        output += "\(indent) pinAuth {\n"
        try pinAuth?.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent) }\n"
      }
      if hasCommandBytes {
        output += "\(indent) commandBytes: \(commandBytes) \n"
      }
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override internal var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasAuthType {
               hashCode = (hashCode &* 31) &+ Int(authType.rawValue)
            }
            if hasHmacAuth {
                if let hashValuehmacAuth = hmacAuth?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuehmacAuth
                }
            }
            if hasPinAuth {
                if let hashValuepinAuth = pinAuth?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuepinAuth
                }
            }
            if hasCommandBytes {
               hashCode = (hashCode &* 31) &+ commandBytes.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override internal class func className() -> String {
        return "Com.Seagate.Kinetic.Proto.Message_"
    }
    override internal func className() -> String {
        return "Com.Seagate.Kinetic.Proto.Message_"
    }
    override internal func classMetaType() -> GeneratedMessage.Type {
        return Com.Seagate.Kinetic.Proto.Message_.self
    }
    //Meta information declaration end

    final internal class Builder : GeneratedMessageBuilder {
      private var builderResult:Com.Seagate.Kinetic.Proto.Message_ = Com.Seagate.Kinetic.Proto.Message_()
      internal func getMessage() -> Com.Seagate.Kinetic.Proto.Message_ {
          return builderResult
      }

      required override internal init () {
         super.init()
      }
        var hasAuthType:Bool{
            get {
                return builderResult.hasAuthType
            }
        }
        var authType:Message_.AuthType {
            get {
                return builderResult.authType
            }
            set (value) {
                builderResult.hasAuthType = true
                builderResult.authType = value
            }
        }
        internal func setAuthType(value:Message_.AuthType) -> Com.Seagate.Kinetic.Proto.Message_.Builder {
          self.authType = value
          return self
        }
        internal func clearAuthType() -> Com.Seagate.Kinetic.Proto.Message_.Builder {
           builderResult.hasAuthType = false
           builderResult.authType = .InvalidAuthType
           return self
        }
      var hasHmacAuth:Bool {
           get {
               return builderResult.hasHmacAuth
           }
      }
      var hmacAuth:Com.Seagate.Kinetic.Proto.Message_.Hmacauth! {
           get {
               if hmacAuthBuilder_ != nil {
                  builderResult.hmacAuth = hmacAuthBuilder_.getMessage()
               }
               return builderResult.hmacAuth
           }
           set (value) {
               builderResult.hasHmacAuth = true
               builderResult.hmacAuth = value
           }
      }
      private var hmacAuthBuilder_:Com.Seagate.Kinetic.Proto.Message_.Hmacauth.Builder! {
           didSet {
              builderResult.hasHmacAuth = true
           }
      }
      internal func getHmacAuthBuilder() -> Com.Seagate.Kinetic.Proto.Message_.Hmacauth.Builder {
        if hmacAuthBuilder_ == nil {
           hmacAuthBuilder_ = Com.Seagate.Kinetic.Proto.Message_.Hmacauth.Builder()
           builderResult.hmacAuth = hmacAuthBuilder_.getMessage()
           if hmacAuth != nil {
              try! hmacAuthBuilder_.mergeFrom(hmacAuth)
           }
        }
        return hmacAuthBuilder_
      }
      func setHmacAuth(value:Com.Seagate.Kinetic.Proto.Message_.Hmacauth!) -> Com.Seagate.Kinetic.Proto.Message_.Builder {
        self.hmacAuth = value
        return self
      }
      internal func mergeHmacAuth(value:Com.Seagate.Kinetic.Proto.Message_.Hmacauth) throws -> Com.Seagate.Kinetic.Proto.Message_.Builder {
        if builderResult.hasHmacAuth {
          builderResult.hmacAuth = try Com.Seagate.Kinetic.Proto.Message_.Hmacauth.builderWithPrototype(builderResult.hmacAuth).mergeFrom(value).buildPartial()
        } else {
          builderResult.hmacAuth = value
        }
        builderResult.hasHmacAuth = true
        return self
      }
      internal func clearHmacAuth() -> Com.Seagate.Kinetic.Proto.Message_.Builder {
        hmacAuthBuilder_ = nil
        builderResult.hasHmacAuth = false
        builderResult.hmacAuth = nil
        return self
      }
      var hasPinAuth:Bool {
           get {
               return builderResult.hasPinAuth
           }
      }
      var pinAuth:Com.Seagate.Kinetic.Proto.Message_.Pinauth! {
           get {
               if pinAuthBuilder_ != nil {
                  builderResult.pinAuth = pinAuthBuilder_.getMessage()
               }
               return builderResult.pinAuth
           }
           set (value) {
               builderResult.hasPinAuth = true
               builderResult.pinAuth = value
           }
      }
      private var pinAuthBuilder_:Com.Seagate.Kinetic.Proto.Message_.Pinauth.Builder! {
           didSet {
              builderResult.hasPinAuth = true
           }
      }
      internal func getPinAuthBuilder() -> Com.Seagate.Kinetic.Proto.Message_.Pinauth.Builder {
        if pinAuthBuilder_ == nil {
           pinAuthBuilder_ = Com.Seagate.Kinetic.Proto.Message_.Pinauth.Builder()
           builderResult.pinAuth = pinAuthBuilder_.getMessage()
           if pinAuth != nil {
              try! pinAuthBuilder_.mergeFrom(pinAuth)
           }
        }
        return pinAuthBuilder_
      }
      func setPinAuth(value:Com.Seagate.Kinetic.Proto.Message_.Pinauth!) -> Com.Seagate.Kinetic.Proto.Message_.Builder {
        self.pinAuth = value
        return self
      }
      internal func mergePinAuth(value:Com.Seagate.Kinetic.Proto.Message_.Pinauth) throws -> Com.Seagate.Kinetic.Proto.Message_.Builder {
        if builderResult.hasPinAuth {
          builderResult.pinAuth = try Com.Seagate.Kinetic.Proto.Message_.Pinauth.builderWithPrototype(builderResult.pinAuth).mergeFrom(value).buildPartial()
        } else {
          builderResult.pinAuth = value
        }
        builderResult.hasPinAuth = true
        return self
      }
      internal func clearPinAuth() -> Com.Seagate.Kinetic.Proto.Message_.Builder {
        pinAuthBuilder_ = nil
        builderResult.hasPinAuth = false
        builderResult.pinAuth = nil
        return self
      }
      var hasCommandBytes:Bool {
           get {
                return builderResult.hasCommandBytes
           }
      }
      var commandBytes:NSData {
           get {
                return builderResult.commandBytes
           }
           set (value) {
               builderResult.hasCommandBytes = true
               builderResult.commandBytes = value
           }
      }
      func setCommandBytes(value:NSData) -> Com.Seagate.Kinetic.Proto.Message_.Builder {
        self.commandBytes = value
        return self
      }
      internal func clearCommandBytes() -> Com.Seagate.Kinetic.Proto.Message_.Builder{
           builderResult.hasCommandBytes = false
           builderResult.commandBytes = NSData()
           return self
      }
      override internal var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      internal override func clear() -> Com.Seagate.Kinetic.Proto.Message_.Builder {
        builderResult = Com.Seagate.Kinetic.Proto.Message_()
        return self
      }
      internal override func clone() throws -> Com.Seagate.Kinetic.Proto.Message_.Builder {
        return try Com.Seagate.Kinetic.Proto.Message_.builderWithPrototype(builderResult)
      }
      internal override func build() throws -> Com.Seagate.Kinetic.Proto.Message_ {
           try checkInitialized()
           return buildPartial()
      }
      internal func buildPartial() -> Com.Seagate.Kinetic.Proto.Message_ {
        let returnMe:Com.Seagate.Kinetic.Proto.Message_ = builderResult
        return returnMe
      }
      internal func mergeFrom(other:Com.Seagate.Kinetic.Proto.Message_) throws -> Com.Seagate.Kinetic.Proto.Message_.Builder {
        if other == Com.Seagate.Kinetic.Proto.Message_() {
         return self
        }
        if other.hasAuthType {
             authType = other.authType
        }
        if (other.hasHmacAuth) {
            try mergeHmacAuth(other.hmacAuth)
        }
        if (other.hasPinAuth) {
            try mergePinAuth(other.pinAuth)
        }
        if other.hasCommandBytes {
             commandBytes = other.commandBytes
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      internal override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Message_.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      internal override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Message_.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let tag = try input.readTag()
          switch tag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 32 :
            let valueIntauthType = try input.readEnum()
            if let enumsauthType = Message_.AuthType(rawValue:valueIntauthType){
                 authType = enumsauthType
            } else {
                 try unknownFieldsBuilder.mergeVarintField(4, value:Int64(valueIntauthType))
            }

          case 42 :
            let subBuilder:Com.Seagate.Kinetic.Proto.Message_.Hmacauth.Builder = Com.Seagate.Kinetic.Proto.Message_.Hmacauth.Builder()
            if hasHmacAuth {
              try subBuilder.mergeFrom(hmacAuth)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            hmacAuth = subBuilder.buildPartial()

          case 50 :
            let subBuilder:Com.Seagate.Kinetic.Proto.Message_.Pinauth.Builder = Com.Seagate.Kinetic.Proto.Message_.Pinauth.Builder()
            if hasPinAuth {
              try subBuilder.mergeFrom(pinAuth)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            pinAuth = subBuilder.buildPartial()

          case 58 :
            commandBytes = try input.readData()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }

  }

  final internal class Command : GeneratedMessage, GeneratedMessageProtocol {


    //Nested type declaration start

      final internal class Header : GeneratedMessage, GeneratedMessageProtocol {
        private(set) var hasClusterVersion:Bool = false
        private(set) var clusterVersion:Int64 = Int64(0)

        private(set) var hasConnectionId:Bool = false
        private(set) var connectionId:Int64 = Int64(0)

        private(set) var hasSequence:Bool = false
        private(set) var sequence:Int64 = Int64(0)

        private(set) var hasAckSequence:Bool = false
        private(set) var ackSequence:Int64 = Int64(0)

        private(set) var messageType:Command.MessageType = Command.MessageType.InvalidMessageType
        private(set) var hasMessageType:Bool = false
        private(set) var hasTimeout:Bool = false
        private(set) var timeout:Int64 = Int64(0)

        private(set) var hasEarlyExit:Bool = false
        private(set) var earlyExit:Bool = false

        private(set) var priority:Command.Priority = Command.Priority.Normal
        private(set) var hasPriority:Bool = false
        private(set) var hasTimeQuanta:Bool = false
        private(set) var timeQuanta:Int64 = Int64(0)

        private(set) var hasBatchId:Bool = false
        private(set) var batchId:UInt32 = UInt32(0)

        required internal init() {
             super.init()
        }
        override internal func isInitialized() -> Bool {
         return true
        }
        override internal func writeToCodedOutputStream(output:CodedOutputStream) throws {
          if hasClusterVersion {
            try output.writeInt64(1, value:clusterVersion)
          }
          if hasConnectionId {
            try output.writeInt64(3, value:connectionId)
          }
          if hasSequence {
            try output.writeInt64(4, value:sequence)
          }
          if hasAckSequence {
            try output.writeInt64(6, value:ackSequence)
          }
          if hasMessageType {
            try output.writeEnum(7, value:messageType.rawValue)
          }
          if hasTimeout {
            try output.writeInt64(9, value:timeout)
          }
          if hasEarlyExit {
            try output.writeBool(10, value:earlyExit)
          }
          if hasPriority {
            try output.writeEnum(12, value:priority.rawValue)
          }
          if hasTimeQuanta {
            try output.writeInt64(13, value:timeQuanta)
          }
          if hasBatchId {
            try output.writeUInt32(14, value:batchId)
          }
          try unknownFields.writeToCodedOutputStream(output)
        }
        override internal func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          if hasClusterVersion {
            serialize_size += clusterVersion.computeInt64Size(1)
          }
          if hasConnectionId {
            serialize_size += connectionId.computeInt64Size(3)
          }
          if hasSequence {
            serialize_size += sequence.computeInt64Size(4)
          }
          if hasAckSequence {
            serialize_size += ackSequence.computeInt64Size(6)
          }
          if (hasMessageType) {
            serialize_size += messageType.rawValue.computeEnumSize(7)
          }
          if hasTimeout {
            serialize_size += timeout.computeInt64Size(9)
          }
          if hasEarlyExit {
            serialize_size += earlyExit.computeBoolSize(10)
          }
          if (hasPriority) {
            serialize_size += priority.rawValue.computeEnumSize(12)
          }
          if hasTimeQuanta {
            serialize_size += timeQuanta.computeInt64Size(13)
          }
          if hasBatchId {
            serialize_size += batchId.computeUInt32Size(14)
          }
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        internal class func parseFromData(data:NSData) throws -> Com.Seagate.Kinetic.Proto.Command.Header {
          return try Com.Seagate.Kinetic.Proto.Command.Header.Builder().mergeFromData(data, extensionRegistry:Com.Seagate.Kinetic.Proto.KineticRoot.sharedInstance.extensionRegistry).build()
        }
        internal class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.Header {
          return try Com.Seagate.Kinetic.Proto.Command.Header.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
        }
        internal class func parseFromInputStream(input:NSInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.Header {
          return try Com.Seagate.Kinetic.Proto.Command.Header.Builder().mergeFromInputStream(input).build()
        }
        internal class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.Header {
          return try Com.Seagate.Kinetic.Proto.Command.Header.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        internal class func parseFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.Header {
          return try Com.Seagate.Kinetic.Proto.Command.Header.Builder().mergeFromCodedInputStream(input).build()
        }
        internal class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.Header {
          return try Com.Seagate.Kinetic.Proto.Command.Header.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        internal class func getBuilder() -> Com.Seagate.Kinetic.Proto.Command.Header.Builder {
          return Com.Seagate.Kinetic.Proto.Command.Header.classBuilder() as! Com.Seagate.Kinetic.Proto.Command.Header.Builder
        }
        internal func getBuilder() -> Com.Seagate.Kinetic.Proto.Command.Header.Builder {
          return classBuilder() as! Com.Seagate.Kinetic.Proto.Command.Header.Builder
        }
        internal override class func classBuilder() -> MessageBuilder {
          return Com.Seagate.Kinetic.Proto.Command.Header.Builder()
        }
        internal override func classBuilder() -> MessageBuilder {
          return Com.Seagate.Kinetic.Proto.Command.Header.Builder()
        }
        internal func toBuilder() throws -> Com.Seagate.Kinetic.Proto.Command.Header.Builder {
          return try Com.Seagate.Kinetic.Proto.Command.Header.builderWithPrototype(self)
        }
        internal class func builderWithPrototype(prototype:Com.Seagate.Kinetic.Proto.Command.Header) throws -> Com.Seagate.Kinetic.Proto.Command.Header.Builder {
          return try Com.Seagate.Kinetic.Proto.Command.Header.Builder().mergeFrom(prototype)
        }
        override internal func writeDescriptionTo(inout output:String, indent:String) throws {
          if hasClusterVersion {
            output += "\(indent) clusterVersion: \(clusterVersion) \n"
          }
          if hasConnectionId {
            output += "\(indent) connectionId: \(connectionId) \n"
          }
          if hasSequence {
            output += "\(indent) sequence: \(sequence) \n"
          }
          if hasAckSequence {
            output += "\(indent) ackSequence: \(ackSequence) \n"
          }
          if (hasMessageType) {
            output += "\(indent) messageType: \(messageType.rawValue)\n"
          }
          if hasTimeout {
            output += "\(indent) timeout: \(timeout) \n"
          }
          if hasEarlyExit {
            output += "\(indent) earlyExit: \(earlyExit) \n"
          }
          if (hasPriority) {
            output += "\(indent) priority: \(priority.rawValue)\n"
          }
          if hasTimeQuanta {
            output += "\(indent) timeQuanta: \(timeQuanta) \n"
          }
          if hasBatchId {
            output += "\(indent) batchId: \(batchId) \n"
          }
          unknownFields.writeDescriptionTo(&output, indent:indent)
        }
        override internal var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasClusterVersion {
                   hashCode = (hashCode &* 31) &+ clusterVersion.hashValue
                }
                if hasConnectionId {
                   hashCode = (hashCode &* 31) &+ connectionId.hashValue
                }
                if hasSequence {
                   hashCode = (hashCode &* 31) &+ sequence.hashValue
                }
                if hasAckSequence {
                   hashCode = (hashCode &* 31) &+ ackSequence.hashValue
                }
                if hasMessageType {
                   hashCode = (hashCode &* 31) &+ Int(messageType.rawValue)
                }
                if hasTimeout {
                   hashCode = (hashCode &* 31) &+ timeout.hashValue
                }
                if hasEarlyExit {
                   hashCode = (hashCode &* 31) &+ earlyExit.hashValue
                }
                if hasPriority {
                   hashCode = (hashCode &* 31) &+ Int(priority.rawValue)
                }
                if hasTimeQuanta {
                   hashCode = (hashCode &* 31) &+ timeQuanta.hashValue
                }
                if hasBatchId {
                   hashCode = (hashCode &* 31) &+ batchId.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override internal class func className() -> String {
            return "Com.Seagate.Kinetic.Proto.Command.Header"
        }
        override internal func className() -> String {
            return "Com.Seagate.Kinetic.Proto.Command.Header"
        }
        override internal func classMetaType() -> GeneratedMessage.Type {
            return Com.Seagate.Kinetic.Proto.Command.Header.self
        }
        //Meta information declaration end

        final internal class Builder : GeneratedMessageBuilder {
          private var builderResult:Com.Seagate.Kinetic.Proto.Command.Header = Com.Seagate.Kinetic.Proto.Command.Header()
          internal func getMessage() -> Com.Seagate.Kinetic.Proto.Command.Header {
              return builderResult
          }

          required override internal init () {
             super.init()
          }
          var hasClusterVersion:Bool {
               get {
                    return builderResult.hasClusterVersion
               }
          }
          var clusterVersion:Int64 {
               get {
                    return builderResult.clusterVersion
               }
               set (value) {
                   builderResult.hasClusterVersion = true
                   builderResult.clusterVersion = value
               }
          }
          func setClusterVersion(value:Int64) -> Com.Seagate.Kinetic.Proto.Command.Header.Builder {
            self.clusterVersion = value
            return self
          }
          internal func clearClusterVersion() -> Com.Seagate.Kinetic.Proto.Command.Header.Builder{
               builderResult.hasClusterVersion = false
               builderResult.clusterVersion = Int64(0)
               return self
          }
          var hasConnectionId:Bool {
               get {
                    return builderResult.hasConnectionId
               }
          }
          var connectionId:Int64 {
               get {
                    return builderResult.connectionId
               }
               set (value) {
                   builderResult.hasConnectionId = true
                   builderResult.connectionId = value
               }
          }
          func setConnectionId(value:Int64) -> Com.Seagate.Kinetic.Proto.Command.Header.Builder {
            self.connectionId = value
            return self
          }
          internal func clearConnectionId() -> Com.Seagate.Kinetic.Proto.Command.Header.Builder{
               builderResult.hasConnectionId = false
               builderResult.connectionId = Int64(0)
               return self
          }
          var hasSequence:Bool {
               get {
                    return builderResult.hasSequence
               }
          }
          var sequence:Int64 {
               get {
                    return builderResult.sequence
               }
               set (value) {
                   builderResult.hasSequence = true
                   builderResult.sequence = value
               }
          }
          func setSequence(value:Int64) -> Com.Seagate.Kinetic.Proto.Command.Header.Builder {
            self.sequence = value
            return self
          }
          internal func clearSequence() -> Com.Seagate.Kinetic.Proto.Command.Header.Builder{
               builderResult.hasSequence = false
               builderResult.sequence = Int64(0)
               return self
          }
          var hasAckSequence:Bool {
               get {
                    return builderResult.hasAckSequence
               }
          }
          var ackSequence:Int64 {
               get {
                    return builderResult.ackSequence
               }
               set (value) {
                   builderResult.hasAckSequence = true
                   builderResult.ackSequence = value
               }
          }
          func setAckSequence(value:Int64) -> Com.Seagate.Kinetic.Proto.Command.Header.Builder {
            self.ackSequence = value
            return self
          }
          internal func clearAckSequence() -> Com.Seagate.Kinetic.Proto.Command.Header.Builder{
               builderResult.hasAckSequence = false
               builderResult.ackSequence = Int64(0)
               return self
          }
            var hasMessageType:Bool{
                get {
                    return builderResult.hasMessageType
                }
            }
            var messageType:Command.MessageType {
                get {
                    return builderResult.messageType
                }
                set (value) {
                    builderResult.hasMessageType = true
                    builderResult.messageType = value
                }
            }
            internal func setMessageType(value:Command.MessageType) -> Com.Seagate.Kinetic.Proto.Command.Header.Builder {
              self.messageType = value
              return self
            }
            internal func clearMessageType() -> Com.Seagate.Kinetic.Proto.Command.Header.Builder {
               builderResult.hasMessageType = false
               builderResult.messageType = .InvalidMessageType
               return self
            }
          var hasTimeout:Bool {
               get {
                    return builderResult.hasTimeout
               }
          }
          var timeout:Int64 {
               get {
                    return builderResult.timeout
               }
               set (value) {
                   builderResult.hasTimeout = true
                   builderResult.timeout = value
               }
          }
          func setTimeout(value:Int64) -> Com.Seagate.Kinetic.Proto.Command.Header.Builder {
            self.timeout = value
            return self
          }
          internal func clearTimeout() -> Com.Seagate.Kinetic.Proto.Command.Header.Builder{
               builderResult.hasTimeout = false
               builderResult.timeout = Int64(0)
               return self
          }
          var hasEarlyExit:Bool {
               get {
                    return builderResult.hasEarlyExit
               }
          }
          var earlyExit:Bool {
               get {
                    return builderResult.earlyExit
               }
               set (value) {
                   builderResult.hasEarlyExit = true
                   builderResult.earlyExit = value
               }
          }
          func setEarlyExit(value:Bool) -> Com.Seagate.Kinetic.Proto.Command.Header.Builder {
            self.earlyExit = value
            return self
          }
          internal func clearEarlyExit() -> Com.Seagate.Kinetic.Proto.Command.Header.Builder{
               builderResult.hasEarlyExit = false
               builderResult.earlyExit = false
               return self
          }
            var hasPriority:Bool{
                get {
                    return builderResult.hasPriority
                }
            }
            var priority:Command.Priority {
                get {
                    return builderResult.priority
                }
                set (value) {
                    builderResult.hasPriority = true
                    builderResult.priority = value
                }
            }
            internal func setPriority(value:Command.Priority) -> Com.Seagate.Kinetic.Proto.Command.Header.Builder {
              self.priority = value
              return self
            }
            internal func clearPriority() -> Com.Seagate.Kinetic.Proto.Command.Header.Builder {
               builderResult.hasPriority = false
               builderResult.priority = .Normal
               return self
            }
          var hasTimeQuanta:Bool {
               get {
                    return builderResult.hasTimeQuanta
               }
          }
          var timeQuanta:Int64 {
               get {
                    return builderResult.timeQuanta
               }
               set (value) {
                   builderResult.hasTimeQuanta = true
                   builderResult.timeQuanta = value
               }
          }
          func setTimeQuanta(value:Int64) -> Com.Seagate.Kinetic.Proto.Command.Header.Builder {
            self.timeQuanta = value
            return self
          }
          internal func clearTimeQuanta() -> Com.Seagate.Kinetic.Proto.Command.Header.Builder{
               builderResult.hasTimeQuanta = false
               builderResult.timeQuanta = Int64(0)
               return self
          }
          var hasBatchId:Bool {
               get {
                    return builderResult.hasBatchId
               }
          }
          var batchId:UInt32 {
               get {
                    return builderResult.batchId
               }
               set (value) {
                   builderResult.hasBatchId = true
                   builderResult.batchId = value
               }
          }
          func setBatchId(value:UInt32) -> Com.Seagate.Kinetic.Proto.Command.Header.Builder {
            self.batchId = value
            return self
          }
          internal func clearBatchId() -> Com.Seagate.Kinetic.Proto.Command.Header.Builder{
               builderResult.hasBatchId = false
               builderResult.batchId = UInt32(0)
               return self
          }
          override internal var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          internal override func clear() -> Com.Seagate.Kinetic.Proto.Command.Header.Builder {
            builderResult = Com.Seagate.Kinetic.Proto.Command.Header()
            return self
          }
          internal override func clone() throws -> Com.Seagate.Kinetic.Proto.Command.Header.Builder {
            return try Com.Seagate.Kinetic.Proto.Command.Header.builderWithPrototype(builderResult)
          }
          internal override func build() throws -> Com.Seagate.Kinetic.Proto.Command.Header {
               try checkInitialized()
               return buildPartial()
          }
          internal func buildPartial() -> Com.Seagate.Kinetic.Proto.Command.Header {
            let returnMe:Com.Seagate.Kinetic.Proto.Command.Header = builderResult
            return returnMe
          }
          internal func mergeFrom(other:Com.Seagate.Kinetic.Proto.Command.Header) throws -> Com.Seagate.Kinetic.Proto.Command.Header.Builder {
            if other == Com.Seagate.Kinetic.Proto.Command.Header() {
             return self
            }
            if other.hasClusterVersion {
                 clusterVersion = other.clusterVersion
            }
            if other.hasConnectionId {
                 connectionId = other.connectionId
            }
            if other.hasSequence {
                 sequence = other.sequence
            }
            if other.hasAckSequence {
                 ackSequence = other.ackSequence
            }
            if other.hasMessageType {
                 messageType = other.messageType
            }
            if other.hasTimeout {
                 timeout = other.timeout
            }
            if other.hasEarlyExit {
                 earlyExit = other.earlyExit
            }
            if other.hasPriority {
                 priority = other.priority
            }
            if other.hasTimeQuanta {
                 timeQuanta = other.timeQuanta
            }
            if other.hasBatchId {
                 batchId = other.batchId
            }
            try mergeUnknownFields(other.unknownFields)
            return self
          }
          internal override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.Header.Builder {
               return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
          }
          internal override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.Header.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
            while (true) {
              let tag = try input.readTag()
              switch tag {
              case 0: 
                self.unknownFields = try unknownFieldsBuilder.build()
                return self

              case 8 :
                clusterVersion = try input.readInt64()

              case 24 :
                connectionId = try input.readInt64()

              case 32 :
                sequence = try input.readInt64()

              case 48 :
                ackSequence = try input.readInt64()

              case 56 :
                let valueIntmessageType = try input.readEnum()
                if let enumsmessageType = Command.MessageType(rawValue:valueIntmessageType){
                     messageType = enumsmessageType
                } else {
                     try unknownFieldsBuilder.mergeVarintField(7, value:Int64(valueIntmessageType))
                }

              case 72 :
                timeout = try input.readInt64()

              case 80 :
                earlyExit = try input.readBool()

              case 96 :
                let valueIntpriority = try input.readEnum()
                if let enumspriority = Command.Priority(rawValue:valueIntpriority){
                     priority = enumspriority
                } else {
                     try unknownFieldsBuilder.mergeVarintField(12, value:Int64(valueIntpriority))
                }

              case 104 :
                timeQuanta = try input.readInt64()

              case 112 :
                batchId = try input.readUInt32()

              default:
                if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag))) {
                   unknownFields = try unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
        }

      }

    //Nested type declaration end



    //Nested type declaration start

      final internal class Body : GeneratedMessage, GeneratedMessageProtocol {
        private(set) var hasKeyValue:Bool = false
        private(set) var keyValue:Com.Seagate.Kinetic.Proto.Command.KeyValue!
        private(set) var hasRange:Bool = false
        private(set) var range:Com.Seagate.Kinetic.Proto.Command.Range!
        private(set) var hasSetup:Bool = false
        private(set) var setup:Com.Seagate.Kinetic.Proto.Command.Setup!
        private(set) var hasP2POperation:Bool = false
        private(set) var p2POperation:Com.Seagate.Kinetic.Proto.Command.P2Poperation!
        private(set) var hasGetLog:Bool = false
        private(set) var getLog:Com.Seagate.Kinetic.Proto.Command.GetLog!
        private(set) var hasSecurity:Bool = false
        private(set) var security:Com.Seagate.Kinetic.Proto.Command.Security!
        private(set) var hasPinOp:Bool = false
        private(set) var pinOp:Com.Seagate.Kinetic.Proto.Command.PinOperation!
        private(set) var hasBatch:Bool = false
        private(set) var batch:Com.Seagate.Kinetic.Proto.Command.Batch!
        required internal init() {
             super.init()
        }
        override internal func isInitialized() -> Bool {
         return true
        }
        override internal func writeToCodedOutputStream(output:CodedOutputStream) throws {
          if hasKeyValue {
            try output.writeMessage(1, value:keyValue)
          }
          if hasRange {
            try output.writeMessage(2, value:range)
          }
          if hasSetup {
            try output.writeMessage(3, value:setup)
          }
          if hasP2POperation {
            try output.writeMessage(4, value:p2POperation)
          }
          if hasGetLog {
            try output.writeMessage(6, value:getLog)
          }
          if hasSecurity {
            try output.writeMessage(7, value:security)
          }
          if hasPinOp {
            try output.writeMessage(8, value:pinOp)
          }
          if hasBatch {
            try output.writeMessage(9, value:batch)
          }
          try unknownFields.writeToCodedOutputStream(output)
        }
        override internal func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          if hasKeyValue {
              if let varSizekeyValue = keyValue?.computeMessageSize(1) {
                  serialize_size += varSizekeyValue
              }
          }
          if hasRange {
              if let varSizerange = range?.computeMessageSize(2) {
                  serialize_size += varSizerange
              }
          }
          if hasSetup {
              if let varSizesetup = setup?.computeMessageSize(3) {
                  serialize_size += varSizesetup
              }
          }
          if hasP2POperation {
              if let varSizep2POperation = p2POperation?.computeMessageSize(4) {
                  serialize_size += varSizep2POperation
              }
          }
          if hasGetLog {
              if let varSizegetLog = getLog?.computeMessageSize(6) {
                  serialize_size += varSizegetLog
              }
          }
          if hasSecurity {
              if let varSizesecurity = security?.computeMessageSize(7) {
                  serialize_size += varSizesecurity
              }
          }
          if hasPinOp {
              if let varSizepinOp = pinOp?.computeMessageSize(8) {
                  serialize_size += varSizepinOp
              }
          }
          if hasBatch {
              if let varSizebatch = batch?.computeMessageSize(9) {
                  serialize_size += varSizebatch
              }
          }
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        internal class func parseFromData(data:NSData) throws -> Com.Seagate.Kinetic.Proto.Command.Body {
          return try Com.Seagate.Kinetic.Proto.Command.Body.Builder().mergeFromData(data, extensionRegistry:Com.Seagate.Kinetic.Proto.KineticRoot.sharedInstance.extensionRegistry).build()
        }
        internal class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.Body {
          return try Com.Seagate.Kinetic.Proto.Command.Body.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
        }
        internal class func parseFromInputStream(input:NSInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.Body {
          return try Com.Seagate.Kinetic.Proto.Command.Body.Builder().mergeFromInputStream(input).build()
        }
        internal class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.Body {
          return try Com.Seagate.Kinetic.Proto.Command.Body.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        internal class func parseFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.Body {
          return try Com.Seagate.Kinetic.Proto.Command.Body.Builder().mergeFromCodedInputStream(input).build()
        }
        internal class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.Body {
          return try Com.Seagate.Kinetic.Proto.Command.Body.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        internal class func getBuilder() -> Com.Seagate.Kinetic.Proto.Command.Body.Builder {
          return Com.Seagate.Kinetic.Proto.Command.Body.classBuilder() as! Com.Seagate.Kinetic.Proto.Command.Body.Builder
        }
        internal func getBuilder() -> Com.Seagate.Kinetic.Proto.Command.Body.Builder {
          return classBuilder() as! Com.Seagate.Kinetic.Proto.Command.Body.Builder
        }
        internal override class func classBuilder() -> MessageBuilder {
          return Com.Seagate.Kinetic.Proto.Command.Body.Builder()
        }
        internal override func classBuilder() -> MessageBuilder {
          return Com.Seagate.Kinetic.Proto.Command.Body.Builder()
        }
        internal func toBuilder() throws -> Com.Seagate.Kinetic.Proto.Command.Body.Builder {
          return try Com.Seagate.Kinetic.Proto.Command.Body.builderWithPrototype(self)
        }
        internal class func builderWithPrototype(prototype:Com.Seagate.Kinetic.Proto.Command.Body) throws -> Com.Seagate.Kinetic.Proto.Command.Body.Builder {
          return try Com.Seagate.Kinetic.Proto.Command.Body.Builder().mergeFrom(prototype)
        }
        override internal func writeDescriptionTo(inout output:String, indent:String) throws {
          if hasKeyValue {
            output += "\(indent) keyValue {\n"
            try keyValue?.writeDescriptionTo(&output, indent:"\(indent)  ")
            output += "\(indent) }\n"
          }
          if hasRange {
            output += "\(indent) range {\n"
            try range?.writeDescriptionTo(&output, indent:"\(indent)  ")
            output += "\(indent) }\n"
          }
          if hasSetup {
            output += "\(indent) setup {\n"
            try setup?.writeDescriptionTo(&output, indent:"\(indent)  ")
            output += "\(indent) }\n"
          }
          if hasP2POperation {
            output += "\(indent) p2POperation {\n"
            try p2POperation?.writeDescriptionTo(&output, indent:"\(indent)  ")
            output += "\(indent) }\n"
          }
          if hasGetLog {
            output += "\(indent) getLog {\n"
            try getLog?.writeDescriptionTo(&output, indent:"\(indent)  ")
            output += "\(indent) }\n"
          }
          if hasSecurity {
            output += "\(indent) security {\n"
            try security?.writeDescriptionTo(&output, indent:"\(indent)  ")
            output += "\(indent) }\n"
          }
          if hasPinOp {
            output += "\(indent) pinOp {\n"
            try pinOp?.writeDescriptionTo(&output, indent:"\(indent)  ")
            output += "\(indent) }\n"
          }
          if hasBatch {
            output += "\(indent) batch {\n"
            try batch?.writeDescriptionTo(&output, indent:"\(indent)  ")
            output += "\(indent) }\n"
          }
          unknownFields.writeDescriptionTo(&output, indent:indent)
        }
        override internal var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasKeyValue {
                    if let hashValuekeyValue = keyValue?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuekeyValue
                    }
                }
                if hasRange {
                    if let hashValuerange = range?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuerange
                    }
                }
                if hasSetup {
                    if let hashValuesetup = setup?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuesetup
                    }
                }
                if hasP2POperation {
                    if let hashValuep2POperation = p2POperation?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuep2POperation
                    }
                }
                if hasGetLog {
                    if let hashValuegetLog = getLog?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuegetLog
                    }
                }
                if hasSecurity {
                    if let hashValuesecurity = security?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuesecurity
                    }
                }
                if hasPinOp {
                    if let hashValuepinOp = pinOp?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuepinOp
                    }
                }
                if hasBatch {
                    if let hashValuebatch = batch?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuebatch
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override internal class func className() -> String {
            return "Com.Seagate.Kinetic.Proto.Command.Body"
        }
        override internal func className() -> String {
            return "Com.Seagate.Kinetic.Proto.Command.Body"
        }
        override internal func classMetaType() -> GeneratedMessage.Type {
            return Com.Seagate.Kinetic.Proto.Command.Body.self
        }
        //Meta information declaration end

        final internal class Builder : GeneratedMessageBuilder {
          private var builderResult:Com.Seagate.Kinetic.Proto.Command.Body = Com.Seagate.Kinetic.Proto.Command.Body()
          internal func getMessage() -> Com.Seagate.Kinetic.Proto.Command.Body {
              return builderResult
          }

          required override internal init () {
             super.init()
          }
          var hasKeyValue:Bool {
               get {
                   return builderResult.hasKeyValue
               }
          }
          var keyValue:Com.Seagate.Kinetic.Proto.Command.KeyValue! {
               get {
                   if keyValueBuilder_ != nil {
                      builderResult.keyValue = keyValueBuilder_.getMessage()
                   }
                   return builderResult.keyValue
               }
               set (value) {
                   builderResult.hasKeyValue = true
                   builderResult.keyValue = value
               }
          }
          private var keyValueBuilder_:Com.Seagate.Kinetic.Proto.Command.KeyValue.Builder! {
               didSet {
                  builderResult.hasKeyValue = true
               }
          }
          internal func getKeyValueBuilder() -> Com.Seagate.Kinetic.Proto.Command.KeyValue.Builder {
            if keyValueBuilder_ == nil {
               keyValueBuilder_ = Com.Seagate.Kinetic.Proto.Command.KeyValue.Builder()
               builderResult.keyValue = keyValueBuilder_.getMessage()
               if keyValue != nil {
                  try! keyValueBuilder_.mergeFrom(keyValue)
               }
            }
            return keyValueBuilder_
          }
          func setKeyValue(value:Com.Seagate.Kinetic.Proto.Command.KeyValue!) -> Com.Seagate.Kinetic.Proto.Command.Body.Builder {
            self.keyValue = value
            return self
          }
          internal func mergeKeyValue(value:Com.Seagate.Kinetic.Proto.Command.KeyValue) throws -> Com.Seagate.Kinetic.Proto.Command.Body.Builder {
            if builderResult.hasKeyValue {
              builderResult.keyValue = try Com.Seagate.Kinetic.Proto.Command.KeyValue.builderWithPrototype(builderResult.keyValue).mergeFrom(value).buildPartial()
            } else {
              builderResult.keyValue = value
            }
            builderResult.hasKeyValue = true
            return self
          }
          internal func clearKeyValue() -> Com.Seagate.Kinetic.Proto.Command.Body.Builder {
            keyValueBuilder_ = nil
            builderResult.hasKeyValue = false
            builderResult.keyValue = nil
            return self
          }
          var hasRange:Bool {
               get {
                   return builderResult.hasRange
               }
          }
          var range:Com.Seagate.Kinetic.Proto.Command.Range! {
               get {
                   if rangeBuilder_ != nil {
                      builderResult.range = rangeBuilder_.getMessage()
                   }
                   return builderResult.range
               }
               set (value) {
                   builderResult.hasRange = true
                   builderResult.range = value
               }
          }
          private var rangeBuilder_:Com.Seagate.Kinetic.Proto.Command.Range.Builder! {
               didSet {
                  builderResult.hasRange = true
               }
          }
          internal func getRangeBuilder() -> Com.Seagate.Kinetic.Proto.Command.Range.Builder {
            if rangeBuilder_ == nil {
               rangeBuilder_ = Com.Seagate.Kinetic.Proto.Command.Range.Builder()
               builderResult.range = rangeBuilder_.getMessage()
               if range != nil {
                  try! rangeBuilder_.mergeFrom(range)
               }
            }
            return rangeBuilder_
          }
          func setRange(value:Com.Seagate.Kinetic.Proto.Command.Range!) -> Com.Seagate.Kinetic.Proto.Command.Body.Builder {
            self.range = value
            return self
          }
          internal func mergeRange(value:Com.Seagate.Kinetic.Proto.Command.Range) throws -> Com.Seagate.Kinetic.Proto.Command.Body.Builder {
            if builderResult.hasRange {
              builderResult.range = try Com.Seagate.Kinetic.Proto.Command.Range.builderWithPrototype(builderResult.range).mergeFrom(value).buildPartial()
            } else {
              builderResult.range = value
            }
            builderResult.hasRange = true
            return self
          }
          internal func clearRange() -> Com.Seagate.Kinetic.Proto.Command.Body.Builder {
            rangeBuilder_ = nil
            builderResult.hasRange = false
            builderResult.range = nil
            return self
          }
          var hasSetup:Bool {
               get {
                   return builderResult.hasSetup
               }
          }
          var setup:Com.Seagate.Kinetic.Proto.Command.Setup! {
               get {
                   if setupBuilder_ != nil {
                      builderResult.setup = setupBuilder_.getMessage()
                   }
                   return builderResult.setup
               }
               set (value) {
                   builderResult.hasSetup = true
                   builderResult.setup = value
               }
          }
          private var setupBuilder_:Com.Seagate.Kinetic.Proto.Command.Setup.Builder! {
               didSet {
                  builderResult.hasSetup = true
               }
          }
          internal func getSetupBuilder() -> Com.Seagate.Kinetic.Proto.Command.Setup.Builder {
            if setupBuilder_ == nil {
               setupBuilder_ = Com.Seagate.Kinetic.Proto.Command.Setup.Builder()
               builderResult.setup = setupBuilder_.getMessage()
               if setup != nil {
                  try! setupBuilder_.mergeFrom(setup)
               }
            }
            return setupBuilder_
          }
          func setSetup(value:Com.Seagate.Kinetic.Proto.Command.Setup!) -> Com.Seagate.Kinetic.Proto.Command.Body.Builder {
            self.setup = value
            return self
          }
          internal func mergeSetup(value:Com.Seagate.Kinetic.Proto.Command.Setup) throws -> Com.Seagate.Kinetic.Proto.Command.Body.Builder {
            if builderResult.hasSetup {
              builderResult.setup = try Com.Seagate.Kinetic.Proto.Command.Setup.builderWithPrototype(builderResult.setup).mergeFrom(value).buildPartial()
            } else {
              builderResult.setup = value
            }
            builderResult.hasSetup = true
            return self
          }
          internal func clearSetup() -> Com.Seagate.Kinetic.Proto.Command.Body.Builder {
            setupBuilder_ = nil
            builderResult.hasSetup = false
            builderResult.setup = nil
            return self
          }
          var hasP2POperation:Bool {
               get {
                   return builderResult.hasP2POperation
               }
          }
          var p2POperation:Com.Seagate.Kinetic.Proto.Command.P2Poperation! {
               get {
                   if p2POperationBuilder_ != nil {
                      builderResult.p2POperation = p2POperationBuilder_.getMessage()
                   }
                   return builderResult.p2POperation
               }
               set (value) {
                   builderResult.hasP2POperation = true
                   builderResult.p2POperation = value
               }
          }
          private var p2POperationBuilder_:Com.Seagate.Kinetic.Proto.Command.P2Poperation.Builder! {
               didSet {
                  builderResult.hasP2POperation = true
               }
          }
          internal func getP2POperationBuilder() -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Builder {
            if p2POperationBuilder_ == nil {
               p2POperationBuilder_ = Com.Seagate.Kinetic.Proto.Command.P2Poperation.Builder()
               builderResult.p2POperation = p2POperationBuilder_.getMessage()
               if p2POperation != nil {
                  try! p2POperationBuilder_.mergeFrom(p2POperation)
               }
            }
            return p2POperationBuilder_
          }
          func setP2POperation(value:Com.Seagate.Kinetic.Proto.Command.P2Poperation!) -> Com.Seagate.Kinetic.Proto.Command.Body.Builder {
            self.p2POperation = value
            return self
          }
          internal func mergeP2POperation(value:Com.Seagate.Kinetic.Proto.Command.P2Poperation) throws -> Com.Seagate.Kinetic.Proto.Command.Body.Builder {
            if builderResult.hasP2POperation {
              builderResult.p2POperation = try Com.Seagate.Kinetic.Proto.Command.P2Poperation.builderWithPrototype(builderResult.p2POperation).mergeFrom(value).buildPartial()
            } else {
              builderResult.p2POperation = value
            }
            builderResult.hasP2POperation = true
            return self
          }
          internal func clearP2POperation() -> Com.Seagate.Kinetic.Proto.Command.Body.Builder {
            p2POperationBuilder_ = nil
            builderResult.hasP2POperation = false
            builderResult.p2POperation = nil
            return self
          }
          var hasGetLog:Bool {
               get {
                   return builderResult.hasGetLog
               }
          }
          var getLog:Com.Seagate.Kinetic.Proto.Command.GetLog! {
               get {
                   if getLogBuilder_ != nil {
                      builderResult.getLog = getLogBuilder_.getMessage()
                   }
                   return builderResult.getLog
               }
               set (value) {
                   builderResult.hasGetLog = true
                   builderResult.getLog = value
               }
          }
          private var getLogBuilder_:Com.Seagate.Kinetic.Proto.Command.GetLog.Builder! {
               didSet {
                  builderResult.hasGetLog = true
               }
          }
          internal func getGetLogBuilder() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Builder {
            if getLogBuilder_ == nil {
               getLogBuilder_ = Com.Seagate.Kinetic.Proto.Command.GetLog.Builder()
               builderResult.getLog = getLogBuilder_.getMessage()
               if getLog != nil {
                  try! getLogBuilder_.mergeFrom(getLog)
               }
            }
            return getLogBuilder_
          }
          func setGetLog(value:Com.Seagate.Kinetic.Proto.Command.GetLog!) -> Com.Seagate.Kinetic.Proto.Command.Body.Builder {
            self.getLog = value
            return self
          }
          internal func mergeGetLog(value:Com.Seagate.Kinetic.Proto.Command.GetLog) throws -> Com.Seagate.Kinetic.Proto.Command.Body.Builder {
            if builderResult.hasGetLog {
              builderResult.getLog = try Com.Seagate.Kinetic.Proto.Command.GetLog.builderWithPrototype(builderResult.getLog).mergeFrom(value).buildPartial()
            } else {
              builderResult.getLog = value
            }
            builderResult.hasGetLog = true
            return self
          }
          internal func clearGetLog() -> Com.Seagate.Kinetic.Proto.Command.Body.Builder {
            getLogBuilder_ = nil
            builderResult.hasGetLog = false
            builderResult.getLog = nil
            return self
          }
          var hasSecurity:Bool {
               get {
                   return builderResult.hasSecurity
               }
          }
          var security:Com.Seagate.Kinetic.Proto.Command.Security! {
               get {
                   if securityBuilder_ != nil {
                      builderResult.security = securityBuilder_.getMessage()
                   }
                   return builderResult.security
               }
               set (value) {
                   builderResult.hasSecurity = true
                   builderResult.security = value
               }
          }
          private var securityBuilder_:Com.Seagate.Kinetic.Proto.Command.Security.Builder! {
               didSet {
                  builderResult.hasSecurity = true
               }
          }
          internal func getSecurityBuilder() -> Com.Seagate.Kinetic.Proto.Command.Security.Builder {
            if securityBuilder_ == nil {
               securityBuilder_ = Com.Seagate.Kinetic.Proto.Command.Security.Builder()
               builderResult.security = securityBuilder_.getMessage()
               if security != nil {
                  try! securityBuilder_.mergeFrom(security)
               }
            }
            return securityBuilder_
          }
          func setSecurity(value:Com.Seagate.Kinetic.Proto.Command.Security!) -> Com.Seagate.Kinetic.Proto.Command.Body.Builder {
            self.security = value
            return self
          }
          internal func mergeSecurity(value:Com.Seagate.Kinetic.Proto.Command.Security) throws -> Com.Seagate.Kinetic.Proto.Command.Body.Builder {
            if builderResult.hasSecurity {
              builderResult.security = try Com.Seagate.Kinetic.Proto.Command.Security.builderWithPrototype(builderResult.security).mergeFrom(value).buildPartial()
            } else {
              builderResult.security = value
            }
            builderResult.hasSecurity = true
            return self
          }
          internal func clearSecurity() -> Com.Seagate.Kinetic.Proto.Command.Body.Builder {
            securityBuilder_ = nil
            builderResult.hasSecurity = false
            builderResult.security = nil
            return self
          }
          var hasPinOp:Bool {
               get {
                   return builderResult.hasPinOp
               }
          }
          var pinOp:Com.Seagate.Kinetic.Proto.Command.PinOperation! {
               get {
                   if pinOpBuilder_ != nil {
                      builderResult.pinOp = pinOpBuilder_.getMessage()
                   }
                   return builderResult.pinOp
               }
               set (value) {
                   builderResult.hasPinOp = true
                   builderResult.pinOp = value
               }
          }
          private var pinOpBuilder_:Com.Seagate.Kinetic.Proto.Command.PinOperation.Builder! {
               didSet {
                  builderResult.hasPinOp = true
               }
          }
          internal func getPinOpBuilder() -> Com.Seagate.Kinetic.Proto.Command.PinOperation.Builder {
            if pinOpBuilder_ == nil {
               pinOpBuilder_ = Com.Seagate.Kinetic.Proto.Command.PinOperation.Builder()
               builderResult.pinOp = pinOpBuilder_.getMessage()
               if pinOp != nil {
                  try! pinOpBuilder_.mergeFrom(pinOp)
               }
            }
            return pinOpBuilder_
          }
          func setPinOp(value:Com.Seagate.Kinetic.Proto.Command.PinOperation!) -> Com.Seagate.Kinetic.Proto.Command.Body.Builder {
            self.pinOp = value
            return self
          }
          internal func mergePinOp(value:Com.Seagate.Kinetic.Proto.Command.PinOperation) throws -> Com.Seagate.Kinetic.Proto.Command.Body.Builder {
            if builderResult.hasPinOp {
              builderResult.pinOp = try Com.Seagate.Kinetic.Proto.Command.PinOperation.builderWithPrototype(builderResult.pinOp).mergeFrom(value).buildPartial()
            } else {
              builderResult.pinOp = value
            }
            builderResult.hasPinOp = true
            return self
          }
          internal func clearPinOp() -> Com.Seagate.Kinetic.Proto.Command.Body.Builder {
            pinOpBuilder_ = nil
            builderResult.hasPinOp = false
            builderResult.pinOp = nil
            return self
          }
          var hasBatch:Bool {
               get {
                   return builderResult.hasBatch
               }
          }
          var batch:Com.Seagate.Kinetic.Proto.Command.Batch! {
               get {
                   if batchBuilder_ != nil {
                      builderResult.batch = batchBuilder_.getMessage()
                   }
                   return builderResult.batch
               }
               set (value) {
                   builderResult.hasBatch = true
                   builderResult.batch = value
               }
          }
          private var batchBuilder_:Com.Seagate.Kinetic.Proto.Command.Batch.Builder! {
               didSet {
                  builderResult.hasBatch = true
               }
          }
          internal func getBatchBuilder() -> Com.Seagate.Kinetic.Proto.Command.Batch.Builder {
            if batchBuilder_ == nil {
               batchBuilder_ = Com.Seagate.Kinetic.Proto.Command.Batch.Builder()
               builderResult.batch = batchBuilder_.getMessage()
               if batch != nil {
                  try! batchBuilder_.mergeFrom(batch)
               }
            }
            return batchBuilder_
          }
          func setBatch(value:Com.Seagate.Kinetic.Proto.Command.Batch!) -> Com.Seagate.Kinetic.Proto.Command.Body.Builder {
            self.batch = value
            return self
          }
          internal func mergeBatch(value:Com.Seagate.Kinetic.Proto.Command.Batch) throws -> Com.Seagate.Kinetic.Proto.Command.Body.Builder {
            if builderResult.hasBatch {
              builderResult.batch = try Com.Seagate.Kinetic.Proto.Command.Batch.builderWithPrototype(builderResult.batch).mergeFrom(value).buildPartial()
            } else {
              builderResult.batch = value
            }
            builderResult.hasBatch = true
            return self
          }
          internal func clearBatch() -> Com.Seagate.Kinetic.Proto.Command.Body.Builder {
            batchBuilder_ = nil
            builderResult.hasBatch = false
            builderResult.batch = nil
            return self
          }
          override internal var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          internal override func clear() -> Com.Seagate.Kinetic.Proto.Command.Body.Builder {
            builderResult = Com.Seagate.Kinetic.Proto.Command.Body()
            return self
          }
          internal override func clone() throws -> Com.Seagate.Kinetic.Proto.Command.Body.Builder {
            return try Com.Seagate.Kinetic.Proto.Command.Body.builderWithPrototype(builderResult)
          }
          internal override func build() throws -> Com.Seagate.Kinetic.Proto.Command.Body {
               try checkInitialized()
               return buildPartial()
          }
          internal func buildPartial() -> Com.Seagate.Kinetic.Proto.Command.Body {
            let returnMe:Com.Seagate.Kinetic.Proto.Command.Body = builderResult
            return returnMe
          }
          internal func mergeFrom(other:Com.Seagate.Kinetic.Proto.Command.Body) throws -> Com.Seagate.Kinetic.Proto.Command.Body.Builder {
            if other == Com.Seagate.Kinetic.Proto.Command.Body() {
             return self
            }
            if (other.hasKeyValue) {
                try mergeKeyValue(other.keyValue)
            }
            if (other.hasRange) {
                try mergeRange(other.range)
            }
            if (other.hasSetup) {
                try mergeSetup(other.setup)
            }
            if (other.hasP2POperation) {
                try mergeP2POperation(other.p2POperation)
            }
            if (other.hasGetLog) {
                try mergeGetLog(other.getLog)
            }
            if (other.hasSecurity) {
                try mergeSecurity(other.security)
            }
            if (other.hasPinOp) {
                try mergePinOp(other.pinOp)
            }
            if (other.hasBatch) {
                try mergeBatch(other.batch)
            }
            try mergeUnknownFields(other.unknownFields)
            return self
          }
          internal override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.Body.Builder {
               return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
          }
          internal override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.Body.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
            while (true) {
              let tag = try input.readTag()
              switch tag {
              case 0: 
                self.unknownFields = try unknownFieldsBuilder.build()
                return self

              case 10 :
                let subBuilder:Com.Seagate.Kinetic.Proto.Command.KeyValue.Builder = Com.Seagate.Kinetic.Proto.Command.KeyValue.Builder()
                if hasKeyValue {
                  try subBuilder.mergeFrom(keyValue)
                }
                try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
                keyValue = subBuilder.buildPartial()

              case 18 :
                let subBuilder:Com.Seagate.Kinetic.Proto.Command.Range.Builder = Com.Seagate.Kinetic.Proto.Command.Range.Builder()
                if hasRange {
                  try subBuilder.mergeFrom(range)
                }
                try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
                range = subBuilder.buildPartial()

              case 26 :
                let subBuilder:Com.Seagate.Kinetic.Proto.Command.Setup.Builder = Com.Seagate.Kinetic.Proto.Command.Setup.Builder()
                if hasSetup {
                  try subBuilder.mergeFrom(setup)
                }
                try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
                setup = subBuilder.buildPartial()

              case 34 :
                let subBuilder:Com.Seagate.Kinetic.Proto.Command.P2Poperation.Builder = Com.Seagate.Kinetic.Proto.Command.P2Poperation.Builder()
                if hasP2POperation {
                  try subBuilder.mergeFrom(p2POperation)
                }
                try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
                p2POperation = subBuilder.buildPartial()

              case 50 :
                let subBuilder:Com.Seagate.Kinetic.Proto.Command.GetLog.Builder = Com.Seagate.Kinetic.Proto.Command.GetLog.Builder()
                if hasGetLog {
                  try subBuilder.mergeFrom(getLog)
                }
                try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
                getLog = subBuilder.buildPartial()

              case 58 :
                let subBuilder:Com.Seagate.Kinetic.Proto.Command.Security.Builder = Com.Seagate.Kinetic.Proto.Command.Security.Builder()
                if hasSecurity {
                  try subBuilder.mergeFrom(security)
                }
                try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
                security = subBuilder.buildPartial()

              case 66 :
                let subBuilder:Com.Seagate.Kinetic.Proto.Command.PinOperation.Builder = Com.Seagate.Kinetic.Proto.Command.PinOperation.Builder()
                if hasPinOp {
                  try subBuilder.mergeFrom(pinOp)
                }
                try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
                pinOp = subBuilder.buildPartial()

              case 74 :
                let subBuilder:Com.Seagate.Kinetic.Proto.Command.Batch.Builder = Com.Seagate.Kinetic.Proto.Command.Batch.Builder()
                if hasBatch {
                  try subBuilder.mergeFrom(batch)
                }
                try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
                batch = subBuilder.buildPartial()

              default:
                if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag))) {
                   unknownFields = try unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
        }

      }

    //Nested type declaration end



    //Nested type declaration start

      final internal class Batch : GeneratedMessage, GeneratedMessageProtocol {
        private(set) var hasCount:Bool = false
        private(set) var count:Int32 = Int32(0)

        private(set) var sequence:Array<Int64> = Array<Int64>()
        private var sequenceMemoizedSerializedSize:Int32 = -1
        private(set) var hasFailedSequence:Bool = false
        private(set) var failedSequence:Int64 = Int64(0)

        required internal init() {
             super.init()
        }
        override internal func isInitialized() -> Bool {
         return true
        }
        override internal func writeToCodedOutputStream(output:CodedOutputStream) throws {
          if hasCount {
            try output.writeInt32(1, value:count)
          }
          if !sequence.isEmpty {
            try output.writeRawVarint32(18)
            try output.writeRawVarint32(sequenceMemoizedSerializedSize)
            for oneValuesequence in sequence {
              try output.writeInt64NoTag(oneValuesequence)
            }
          }
          if hasFailedSequence {
            try output.writeInt64(3, value:failedSequence)
          }
          try unknownFields.writeToCodedOutputStream(output)
        }
        override internal func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          if hasCount {
            serialize_size += count.computeInt32Size(1)
          }
          var dataSizeSequence:Int32 = 0
          for oneValuesequence in sequence {
              dataSizeSequence += oneValuesequence.computeInt64SizeNoTag()
          }
          serialize_size += dataSizeSequence
          if !sequence.isEmpty {
            serialize_size += 1
            serialize_size += dataSizeSequence.computeInt32SizeNoTag()
          }
          sequenceMemoizedSerializedSize = dataSizeSequence
          if hasFailedSequence {
            serialize_size += failedSequence.computeInt64Size(3)
          }
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        internal class func parseFromData(data:NSData) throws -> Com.Seagate.Kinetic.Proto.Command.Batch {
          return try Com.Seagate.Kinetic.Proto.Command.Batch.Builder().mergeFromData(data, extensionRegistry:Com.Seagate.Kinetic.Proto.KineticRoot.sharedInstance.extensionRegistry).build()
        }
        internal class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.Batch {
          return try Com.Seagate.Kinetic.Proto.Command.Batch.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
        }
        internal class func parseFromInputStream(input:NSInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.Batch {
          return try Com.Seagate.Kinetic.Proto.Command.Batch.Builder().mergeFromInputStream(input).build()
        }
        internal class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.Batch {
          return try Com.Seagate.Kinetic.Proto.Command.Batch.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        internal class func parseFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.Batch {
          return try Com.Seagate.Kinetic.Proto.Command.Batch.Builder().mergeFromCodedInputStream(input).build()
        }
        internal class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.Batch {
          return try Com.Seagate.Kinetic.Proto.Command.Batch.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        internal class func getBuilder() -> Com.Seagate.Kinetic.Proto.Command.Batch.Builder {
          return Com.Seagate.Kinetic.Proto.Command.Batch.classBuilder() as! Com.Seagate.Kinetic.Proto.Command.Batch.Builder
        }
        internal func getBuilder() -> Com.Seagate.Kinetic.Proto.Command.Batch.Builder {
          return classBuilder() as! Com.Seagate.Kinetic.Proto.Command.Batch.Builder
        }
        internal override class func classBuilder() -> MessageBuilder {
          return Com.Seagate.Kinetic.Proto.Command.Batch.Builder()
        }
        internal override func classBuilder() -> MessageBuilder {
          return Com.Seagate.Kinetic.Proto.Command.Batch.Builder()
        }
        internal func toBuilder() throws -> Com.Seagate.Kinetic.Proto.Command.Batch.Builder {
          return try Com.Seagate.Kinetic.Proto.Command.Batch.builderWithPrototype(self)
        }
        internal class func builderWithPrototype(prototype:Com.Seagate.Kinetic.Proto.Command.Batch) throws -> Com.Seagate.Kinetic.Proto.Command.Batch.Builder {
          return try Com.Seagate.Kinetic.Proto.Command.Batch.Builder().mergeFrom(prototype)
        }
        override internal func writeDescriptionTo(inout output:String, indent:String) throws {
          if hasCount {
            output += "\(indent) count: \(count) \n"
          }
          var sequenceElementIndex:Int = 0
          for oneValuesequence in sequence  {
              output += "\(indent) sequence[\(sequenceElementIndex)]: \(oneValuesequence)\n"
              sequenceElementIndex++
          }
          if hasFailedSequence {
            output += "\(indent) failedSequence: \(failedSequence) \n"
          }
          unknownFields.writeDescriptionTo(&output, indent:indent)
        }
        override internal var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasCount {
                   hashCode = (hashCode &* 31) &+ count.hashValue
                }
                for oneValuesequence in sequence {
                    hashCode = (hashCode &* 31) &+ oneValuesequence.hashValue
                }
                if hasFailedSequence {
                   hashCode = (hashCode &* 31) &+ failedSequence.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override internal class func className() -> String {
            return "Com.Seagate.Kinetic.Proto.Command.Batch"
        }
        override internal func className() -> String {
            return "Com.Seagate.Kinetic.Proto.Command.Batch"
        }
        override internal func classMetaType() -> GeneratedMessage.Type {
            return Com.Seagate.Kinetic.Proto.Command.Batch.self
        }
        //Meta information declaration end

        final internal class Builder : GeneratedMessageBuilder {
          private var builderResult:Com.Seagate.Kinetic.Proto.Command.Batch = Com.Seagate.Kinetic.Proto.Command.Batch()
          internal func getMessage() -> Com.Seagate.Kinetic.Proto.Command.Batch {
              return builderResult
          }

          required override internal init () {
             super.init()
          }
          var hasCount:Bool {
               get {
                    return builderResult.hasCount
               }
          }
          var count:Int32 {
               get {
                    return builderResult.count
               }
               set (value) {
                   builderResult.hasCount = true
                   builderResult.count = value
               }
          }
          func setCount(value:Int32) -> Com.Seagate.Kinetic.Proto.Command.Batch.Builder {
            self.count = value
            return self
          }
          internal func clearCount() -> Com.Seagate.Kinetic.Proto.Command.Batch.Builder{
               builderResult.hasCount = false
               builderResult.count = Int32(0)
               return self
          }
          var sequence:Array<Int64> {
               get {
                   return builderResult.sequence
               }
               set (array) {
                   builderResult.sequence = array
               }
          }
          func setSequence(value:Array<Int64>) -> Com.Seagate.Kinetic.Proto.Command.Batch.Builder {
            self.sequence = value
            return self
          }
          internal func clearSequence() -> Com.Seagate.Kinetic.Proto.Command.Batch.Builder {
             builderResult.sequence.removeAll(keepCapacity: false)
             return self
          }
          var hasFailedSequence:Bool {
               get {
                    return builderResult.hasFailedSequence
               }
          }
          var failedSequence:Int64 {
               get {
                    return builderResult.failedSequence
               }
               set (value) {
                   builderResult.hasFailedSequence = true
                   builderResult.failedSequence = value
               }
          }
          func setFailedSequence(value:Int64) -> Com.Seagate.Kinetic.Proto.Command.Batch.Builder {
            self.failedSequence = value
            return self
          }
          internal func clearFailedSequence() -> Com.Seagate.Kinetic.Proto.Command.Batch.Builder{
               builderResult.hasFailedSequence = false
               builderResult.failedSequence = Int64(0)
               return self
          }
          override internal var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          internal override func clear() -> Com.Seagate.Kinetic.Proto.Command.Batch.Builder {
            builderResult = Com.Seagate.Kinetic.Proto.Command.Batch()
            return self
          }
          internal override func clone() throws -> Com.Seagate.Kinetic.Proto.Command.Batch.Builder {
            return try Com.Seagate.Kinetic.Proto.Command.Batch.builderWithPrototype(builderResult)
          }
          internal override func build() throws -> Com.Seagate.Kinetic.Proto.Command.Batch {
               try checkInitialized()
               return buildPartial()
          }
          internal func buildPartial() -> Com.Seagate.Kinetic.Proto.Command.Batch {
            let returnMe:Com.Seagate.Kinetic.Proto.Command.Batch = builderResult
            return returnMe
          }
          internal func mergeFrom(other:Com.Seagate.Kinetic.Proto.Command.Batch) throws -> Com.Seagate.Kinetic.Proto.Command.Batch.Builder {
            if other == Com.Seagate.Kinetic.Proto.Command.Batch() {
             return self
            }
            if other.hasCount {
                 count = other.count
            }
            if !other.sequence.isEmpty {
                builderResult.sequence += other.sequence
            }
            if other.hasFailedSequence {
                 failedSequence = other.failedSequence
            }
            try mergeUnknownFields(other.unknownFields)
            return self
          }
          internal override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.Batch.Builder {
               return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
          }
          internal override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.Batch.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
            while (true) {
              let tag = try input.readTag()
              switch tag {
              case 0: 
                self.unknownFields = try unknownFieldsBuilder.build()
                return self

              case 8 :
                count = try input.readInt32()

              case 18 :
                let length:Int32 = try input.readRawVarint32()
                let limit:Int32 = try input.pushLimit(length)
                while (input.bytesUntilLimit() > 0) {
                  builderResult.sequence += [try input.readInt64()]
                }
                input.popLimit(limit)

              case 24 :
                failedSequence = try input.readInt64()

              default:
                if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag))) {
                   unknownFields = try unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
        }

      }

    //Nested type declaration end



    //Nested type declaration start

      final internal class Status : GeneratedMessage, GeneratedMessageProtocol {


          //Enum type declaration start 

          internal enum StatusCode:Int32 {
            case InvalidStatusCode = -1
            case NotAttempted = 0
            case Success = 1
            case HmacFailure = 2
            case NotAuthorized = 3
            case VersionFailure = 4
            case InternalError = 5
            case HeaderRequired = 6
            case NotFound = 7
            case VersionMismatch = 8
            case ServiceBusy = 9
            case Expired = 10
            case DataError = 11
            case PermDataError = 12
            case RemoteConnectionError = 13
            case NoSpace = 14
            case NoSuchHmacAlgorithm = 15
            case InvalidRequest = 16
            case NestedOperationErrors = 17
            case DeviceLocked = 18
            case DeviceAlreadyUnlocked = 19
            case ConnectionTerminated = 20
            case InvalidBatch = 21

          }

          //Enum type declaration end 

        private(set) var code:Command.Status.StatusCode = Command.Status.StatusCode.InvalidStatusCode
        private(set) var hasCode:Bool = false
        private(set) var hasStatusMessage:Bool = false
        private(set) var statusMessage:String = ""

        private(set) var hasDetailedMessage:Bool = false
        private(set) var detailedMessage:NSData = NSData()

        required internal init() {
             super.init()
        }
        override internal func isInitialized() -> Bool {
         return true
        }
        override internal func writeToCodedOutputStream(output:CodedOutputStream) throws {
          if hasCode {
            try output.writeEnum(1, value:code.rawValue)
          }
          if hasStatusMessage {
            try output.writeString(2, value:statusMessage)
          }
          if hasDetailedMessage {
            try output.writeData(3, value:detailedMessage)
          }
          try unknownFields.writeToCodedOutputStream(output)
        }
        override internal func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          if (hasCode) {
            serialize_size += code.rawValue.computeEnumSize(1)
          }
          if hasStatusMessage {
            serialize_size += statusMessage.computeStringSize(2)
          }
          if hasDetailedMessage {
            serialize_size += detailedMessage.computeDataSize(3)
          }
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        internal class func parseFromData(data:NSData) throws -> Com.Seagate.Kinetic.Proto.Command.Status {
          return try Com.Seagate.Kinetic.Proto.Command.Status.Builder().mergeFromData(data, extensionRegistry:Com.Seagate.Kinetic.Proto.KineticRoot.sharedInstance.extensionRegistry).build()
        }
        internal class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.Status {
          return try Com.Seagate.Kinetic.Proto.Command.Status.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
        }
        internal class func parseFromInputStream(input:NSInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.Status {
          return try Com.Seagate.Kinetic.Proto.Command.Status.Builder().mergeFromInputStream(input).build()
        }
        internal class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.Status {
          return try Com.Seagate.Kinetic.Proto.Command.Status.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        internal class func parseFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.Status {
          return try Com.Seagate.Kinetic.Proto.Command.Status.Builder().mergeFromCodedInputStream(input).build()
        }
        internal class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.Status {
          return try Com.Seagate.Kinetic.Proto.Command.Status.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        internal class func getBuilder() -> Com.Seagate.Kinetic.Proto.Command.Status.Builder {
          return Com.Seagate.Kinetic.Proto.Command.Status.classBuilder() as! Com.Seagate.Kinetic.Proto.Command.Status.Builder
        }
        internal func getBuilder() -> Com.Seagate.Kinetic.Proto.Command.Status.Builder {
          return classBuilder() as! Com.Seagate.Kinetic.Proto.Command.Status.Builder
        }
        internal override class func classBuilder() -> MessageBuilder {
          return Com.Seagate.Kinetic.Proto.Command.Status.Builder()
        }
        internal override func classBuilder() -> MessageBuilder {
          return Com.Seagate.Kinetic.Proto.Command.Status.Builder()
        }
        internal func toBuilder() throws -> Com.Seagate.Kinetic.Proto.Command.Status.Builder {
          return try Com.Seagate.Kinetic.Proto.Command.Status.builderWithPrototype(self)
        }
        internal class func builderWithPrototype(prototype:Com.Seagate.Kinetic.Proto.Command.Status) throws -> Com.Seagate.Kinetic.Proto.Command.Status.Builder {
          return try Com.Seagate.Kinetic.Proto.Command.Status.Builder().mergeFrom(prototype)
        }
        override internal func writeDescriptionTo(inout output:String, indent:String) throws {
          if (hasCode) {
            output += "\(indent) code: \(code.rawValue)\n"
          }
          if hasStatusMessage {
            output += "\(indent) statusMessage: \(statusMessage) \n"
          }
          if hasDetailedMessage {
            output += "\(indent) detailedMessage: \(detailedMessage) \n"
          }
          unknownFields.writeDescriptionTo(&output, indent:indent)
        }
        override internal var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasCode {
                   hashCode = (hashCode &* 31) &+ Int(code.rawValue)
                }
                if hasStatusMessage {
                   hashCode = (hashCode &* 31) &+ statusMessage.hashValue
                }
                if hasDetailedMessage {
                   hashCode = (hashCode &* 31) &+ detailedMessage.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override internal class func className() -> String {
            return "Com.Seagate.Kinetic.Proto.Command.Status"
        }
        override internal func className() -> String {
            return "Com.Seagate.Kinetic.Proto.Command.Status"
        }
        override internal func classMetaType() -> GeneratedMessage.Type {
            return Com.Seagate.Kinetic.Proto.Command.Status.self
        }
        //Meta information declaration end

        final internal class Builder : GeneratedMessageBuilder {
          private var builderResult:Com.Seagate.Kinetic.Proto.Command.Status = Com.Seagate.Kinetic.Proto.Command.Status()
          internal func getMessage() -> Com.Seagate.Kinetic.Proto.Command.Status {
              return builderResult
          }

          required override internal init () {
             super.init()
          }
            var hasCode:Bool{
                get {
                    return builderResult.hasCode
                }
            }
            var code:Command.Status.StatusCode {
                get {
                    return builderResult.code
                }
                set (value) {
                    builderResult.hasCode = true
                    builderResult.code = value
                }
            }
            internal func setCode(value:Command.Status.StatusCode) -> Com.Seagate.Kinetic.Proto.Command.Status.Builder {
              self.code = value
              return self
            }
            internal func clearCode() -> Com.Seagate.Kinetic.Proto.Command.Status.Builder {
               builderResult.hasCode = false
               builderResult.code = .InvalidStatusCode
               return self
            }
          var hasStatusMessage:Bool {
               get {
                    return builderResult.hasStatusMessage
               }
          }
          var statusMessage:String {
               get {
                    return builderResult.statusMessage
               }
               set (value) {
                   builderResult.hasStatusMessage = true
                   builderResult.statusMessage = value
               }
          }
          func setStatusMessage(value:String) -> Com.Seagate.Kinetic.Proto.Command.Status.Builder {
            self.statusMessage = value
            return self
          }
          internal func clearStatusMessage() -> Com.Seagate.Kinetic.Proto.Command.Status.Builder{
               builderResult.hasStatusMessage = false
               builderResult.statusMessage = ""
               return self
          }
          var hasDetailedMessage:Bool {
               get {
                    return builderResult.hasDetailedMessage
               }
          }
          var detailedMessage:NSData {
               get {
                    return builderResult.detailedMessage
               }
               set (value) {
                   builderResult.hasDetailedMessage = true
                   builderResult.detailedMessage = value
               }
          }
          func setDetailedMessage(value:NSData) -> Com.Seagate.Kinetic.Proto.Command.Status.Builder {
            self.detailedMessage = value
            return self
          }
          internal func clearDetailedMessage() -> Com.Seagate.Kinetic.Proto.Command.Status.Builder{
               builderResult.hasDetailedMessage = false
               builderResult.detailedMessage = NSData()
               return self
          }
          override internal var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          internal override func clear() -> Com.Seagate.Kinetic.Proto.Command.Status.Builder {
            builderResult = Com.Seagate.Kinetic.Proto.Command.Status()
            return self
          }
          internal override func clone() throws -> Com.Seagate.Kinetic.Proto.Command.Status.Builder {
            return try Com.Seagate.Kinetic.Proto.Command.Status.builderWithPrototype(builderResult)
          }
          internal override func build() throws -> Com.Seagate.Kinetic.Proto.Command.Status {
               try checkInitialized()
               return buildPartial()
          }
          internal func buildPartial() -> Com.Seagate.Kinetic.Proto.Command.Status {
            let returnMe:Com.Seagate.Kinetic.Proto.Command.Status = builderResult
            return returnMe
          }
          internal func mergeFrom(other:Com.Seagate.Kinetic.Proto.Command.Status) throws -> Com.Seagate.Kinetic.Proto.Command.Status.Builder {
            if other == Com.Seagate.Kinetic.Proto.Command.Status() {
             return self
            }
            if other.hasCode {
                 code = other.code
            }
            if other.hasStatusMessage {
                 statusMessage = other.statusMessage
            }
            if other.hasDetailedMessage {
                 detailedMessage = other.detailedMessage
            }
            try mergeUnknownFields(other.unknownFields)
            return self
          }
          internal override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.Status.Builder {
               return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
          }
          internal override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.Status.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
            while (true) {
              let tag = try input.readTag()
              switch tag {
              case 0: 
                self.unknownFields = try unknownFieldsBuilder.build()
                return self

              case 8 :
                let valueIntcode = try input.readEnum()
                if let enumscode = Command.Status.StatusCode(rawValue:valueIntcode){
                     code = enumscode
                } else {
                     try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntcode))
                }

              case 18 :
                statusMessage = try input.readString()

              case 26 :
                detailedMessage = try input.readData()

              default:
                if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag))) {
                   unknownFields = try unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
        }

      }

    //Nested type declaration end



    //Nested type declaration start

      final internal class KeyValue : GeneratedMessage, GeneratedMessageProtocol {
        private(set) var hasNewVersion:Bool = false
        private(set) var newVersion:NSData = NSData()

        private(set) var hasForce:Bool = false
        private(set) var force:Bool = false

        private(set) var hasKey:Bool = false
        private(set) var key:NSData = NSData()

        private(set) var hasDbVersion:Bool = false
        private(set) var dbVersion:NSData = NSData()

        private(set) var hasTag:Bool = false
        private(set) var tag:NSData = NSData()

        private(set) var algorithm:Command.Algorithm = Command.Algorithm.InvalidAlgorithm
        private(set) var hasAlgorithm:Bool = false
        private(set) var hasMetadataOnly:Bool = false
        private(set) var metadataOnly:Bool = false

        private(set) var synchronization:Command.Synchronization = Command.Synchronization.InvalidSynchronization
        private(set) var hasSynchronization:Bool = false
        required internal init() {
             super.init()
        }
        override internal func isInitialized() -> Bool {
         return true
        }
        override internal func writeToCodedOutputStream(output:CodedOutputStream) throws {
          if hasNewVersion {
            try output.writeData(2, value:newVersion)
          }
          if hasKey {
            try output.writeData(3, value:key)
          }
          if hasDbVersion {
            try output.writeData(4, value:dbVersion)
          }
          if hasTag {
            try output.writeData(5, value:tag)
          }
          if hasAlgorithm {
            try output.writeEnum(6, value:algorithm.rawValue)
          }
          if hasMetadataOnly {
            try output.writeBool(7, value:metadataOnly)
          }
          if hasForce {
            try output.writeBool(8, value:force)
          }
          if hasSynchronization {
            try output.writeEnum(9, value:synchronization.rawValue)
          }
          try unknownFields.writeToCodedOutputStream(output)
        }
        override internal func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          if hasNewVersion {
            serialize_size += newVersion.computeDataSize(2)
          }
          if hasKey {
            serialize_size += key.computeDataSize(3)
          }
          if hasDbVersion {
            serialize_size += dbVersion.computeDataSize(4)
          }
          if hasTag {
            serialize_size += tag.computeDataSize(5)
          }
          if (hasAlgorithm) {
            serialize_size += algorithm.rawValue.computeEnumSize(6)
          }
          if hasMetadataOnly {
            serialize_size += metadataOnly.computeBoolSize(7)
          }
          if hasForce {
            serialize_size += force.computeBoolSize(8)
          }
          if (hasSynchronization) {
            serialize_size += synchronization.rawValue.computeEnumSize(9)
          }
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        internal class func parseFromData(data:NSData) throws -> Com.Seagate.Kinetic.Proto.Command.KeyValue {
          return try Com.Seagate.Kinetic.Proto.Command.KeyValue.Builder().mergeFromData(data, extensionRegistry:Com.Seagate.Kinetic.Proto.KineticRoot.sharedInstance.extensionRegistry).build()
        }
        internal class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.KeyValue {
          return try Com.Seagate.Kinetic.Proto.Command.KeyValue.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
        }
        internal class func parseFromInputStream(input:NSInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.KeyValue {
          return try Com.Seagate.Kinetic.Proto.Command.KeyValue.Builder().mergeFromInputStream(input).build()
        }
        internal class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.KeyValue {
          return try Com.Seagate.Kinetic.Proto.Command.KeyValue.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        internal class func parseFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.KeyValue {
          return try Com.Seagate.Kinetic.Proto.Command.KeyValue.Builder().mergeFromCodedInputStream(input).build()
        }
        internal class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.KeyValue {
          return try Com.Seagate.Kinetic.Proto.Command.KeyValue.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        internal class func getBuilder() -> Com.Seagate.Kinetic.Proto.Command.KeyValue.Builder {
          return Com.Seagate.Kinetic.Proto.Command.KeyValue.classBuilder() as! Com.Seagate.Kinetic.Proto.Command.KeyValue.Builder
        }
        internal func getBuilder() -> Com.Seagate.Kinetic.Proto.Command.KeyValue.Builder {
          return classBuilder() as! Com.Seagate.Kinetic.Proto.Command.KeyValue.Builder
        }
        internal override class func classBuilder() -> MessageBuilder {
          return Com.Seagate.Kinetic.Proto.Command.KeyValue.Builder()
        }
        internal override func classBuilder() -> MessageBuilder {
          return Com.Seagate.Kinetic.Proto.Command.KeyValue.Builder()
        }
        internal func toBuilder() throws -> Com.Seagate.Kinetic.Proto.Command.KeyValue.Builder {
          return try Com.Seagate.Kinetic.Proto.Command.KeyValue.builderWithPrototype(self)
        }
        internal class func builderWithPrototype(prototype:Com.Seagate.Kinetic.Proto.Command.KeyValue) throws -> Com.Seagate.Kinetic.Proto.Command.KeyValue.Builder {
          return try Com.Seagate.Kinetic.Proto.Command.KeyValue.Builder().mergeFrom(prototype)
        }
        override internal func writeDescriptionTo(inout output:String, indent:String) throws {
          if hasNewVersion {
            output += "\(indent) newVersion: \(newVersion) \n"
          }
          if hasKey {
            output += "\(indent) key: \(key) \n"
          }
          if hasDbVersion {
            output += "\(indent) dbVersion: \(dbVersion) \n"
          }
          if hasTag {
            output += "\(indent) tag: \(tag) \n"
          }
          if (hasAlgorithm) {
            output += "\(indent) algorithm: \(algorithm.rawValue)\n"
          }
          if hasMetadataOnly {
            output += "\(indent) metadataOnly: \(metadataOnly) \n"
          }
          if hasForce {
            output += "\(indent) force: \(force) \n"
          }
          if (hasSynchronization) {
            output += "\(indent) synchronization: \(synchronization.rawValue)\n"
          }
          unknownFields.writeDescriptionTo(&output, indent:indent)
        }
        override internal var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasNewVersion {
                   hashCode = (hashCode &* 31) &+ newVersion.hashValue
                }
                if hasKey {
                   hashCode = (hashCode &* 31) &+ key.hashValue
                }
                if hasDbVersion {
                   hashCode = (hashCode &* 31) &+ dbVersion.hashValue
                }
                if hasTag {
                   hashCode = (hashCode &* 31) &+ tag.hashValue
                }
                if hasAlgorithm {
                   hashCode = (hashCode &* 31) &+ Int(algorithm.rawValue)
                }
                if hasMetadataOnly {
                   hashCode = (hashCode &* 31) &+ metadataOnly.hashValue
                }
                if hasForce {
                   hashCode = (hashCode &* 31) &+ force.hashValue
                }
                if hasSynchronization {
                   hashCode = (hashCode &* 31) &+ Int(synchronization.rawValue)
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override internal class func className() -> String {
            return "Com.Seagate.Kinetic.Proto.Command.KeyValue"
        }
        override internal func className() -> String {
            return "Com.Seagate.Kinetic.Proto.Command.KeyValue"
        }
        override internal func classMetaType() -> GeneratedMessage.Type {
            return Com.Seagate.Kinetic.Proto.Command.KeyValue.self
        }
        //Meta information declaration end

        final internal class Builder : GeneratedMessageBuilder {
          private var builderResult:Com.Seagate.Kinetic.Proto.Command.KeyValue = Com.Seagate.Kinetic.Proto.Command.KeyValue()
          internal func getMessage() -> Com.Seagate.Kinetic.Proto.Command.KeyValue {
              return builderResult
          }

          required override internal init () {
             super.init()
          }
          var hasNewVersion:Bool {
               get {
                    return builderResult.hasNewVersion
               }
          }
          var newVersion:NSData {
               get {
                    return builderResult.newVersion
               }
               set (value) {
                   builderResult.hasNewVersion = true
                   builderResult.newVersion = value
               }
          }
          func setNewVersion(value:NSData) -> Com.Seagate.Kinetic.Proto.Command.KeyValue.Builder {
            self.newVersion = value
            return self
          }
          internal func clearNewVersion() -> Com.Seagate.Kinetic.Proto.Command.KeyValue.Builder{
               builderResult.hasNewVersion = false
               builderResult.newVersion = NSData()
               return self
          }
          var hasForce:Bool {
               get {
                    return builderResult.hasForce
               }
          }
          var force:Bool {
               get {
                    return builderResult.force
               }
               set (value) {
                   builderResult.hasForce = true
                   builderResult.force = value
               }
          }
          func setForce(value:Bool) -> Com.Seagate.Kinetic.Proto.Command.KeyValue.Builder {
            self.force = value
            return self
          }
          internal func clearForce() -> Com.Seagate.Kinetic.Proto.Command.KeyValue.Builder{
               builderResult.hasForce = false
               builderResult.force = false
               return self
          }
          var hasKey:Bool {
               get {
                    return builderResult.hasKey
               }
          }
          var key:NSData {
               get {
                    return builderResult.key
               }
               set (value) {
                   builderResult.hasKey = true
                   builderResult.key = value
               }
          }
          func setKey(value:NSData) -> Com.Seagate.Kinetic.Proto.Command.KeyValue.Builder {
            self.key = value
            return self
          }
          internal func clearKey() -> Com.Seagate.Kinetic.Proto.Command.KeyValue.Builder{
               builderResult.hasKey = false
               builderResult.key = NSData()
               return self
          }
          var hasDbVersion:Bool {
               get {
                    return builderResult.hasDbVersion
               }
          }
          var dbVersion:NSData {
               get {
                    return builderResult.dbVersion
               }
               set (value) {
                   builderResult.hasDbVersion = true
                   builderResult.dbVersion = value
               }
          }
          func setDbVersion(value:NSData) -> Com.Seagate.Kinetic.Proto.Command.KeyValue.Builder {
            self.dbVersion = value
            return self
          }
          internal func clearDbVersion() -> Com.Seagate.Kinetic.Proto.Command.KeyValue.Builder{
               builderResult.hasDbVersion = false
               builderResult.dbVersion = NSData()
               return self
          }
          var hasTag:Bool {
               get {
                    return builderResult.hasTag
               }
          }
          var tag:NSData {
               get {
                    return builderResult.tag
               }
               set (value) {
                   builderResult.hasTag = true
                   builderResult.tag = value
               }
          }
          func setTag(value:NSData) -> Com.Seagate.Kinetic.Proto.Command.KeyValue.Builder {
            self.tag = value
            return self
          }
          internal func clearTag() -> Com.Seagate.Kinetic.Proto.Command.KeyValue.Builder{
               builderResult.hasTag = false
               builderResult.tag = NSData()
               return self
          }
            var hasAlgorithm:Bool{
                get {
                    return builderResult.hasAlgorithm
                }
            }
            var algorithm:Command.Algorithm {
                get {
                    return builderResult.algorithm
                }
                set (value) {
                    builderResult.hasAlgorithm = true
                    builderResult.algorithm = value
                }
            }
            internal func setAlgorithm(value:Command.Algorithm) -> Com.Seagate.Kinetic.Proto.Command.KeyValue.Builder {
              self.algorithm = value
              return self
            }
            internal func clearAlgorithm() -> Com.Seagate.Kinetic.Proto.Command.KeyValue.Builder {
               builderResult.hasAlgorithm = false
               builderResult.algorithm = .InvalidAlgorithm
               return self
            }
          var hasMetadataOnly:Bool {
               get {
                    return builderResult.hasMetadataOnly
               }
          }
          var metadataOnly:Bool {
               get {
                    return builderResult.metadataOnly
               }
               set (value) {
                   builderResult.hasMetadataOnly = true
                   builderResult.metadataOnly = value
               }
          }
          func setMetadataOnly(value:Bool) -> Com.Seagate.Kinetic.Proto.Command.KeyValue.Builder {
            self.metadataOnly = value
            return self
          }
          internal func clearMetadataOnly() -> Com.Seagate.Kinetic.Proto.Command.KeyValue.Builder{
               builderResult.hasMetadataOnly = false
               builderResult.metadataOnly = false
               return self
          }
            var hasSynchronization:Bool{
                get {
                    return builderResult.hasSynchronization
                }
            }
            var synchronization:Command.Synchronization {
                get {
                    return builderResult.synchronization
                }
                set (value) {
                    builderResult.hasSynchronization = true
                    builderResult.synchronization = value
                }
            }
            internal func setSynchronization(value:Command.Synchronization) -> Com.Seagate.Kinetic.Proto.Command.KeyValue.Builder {
              self.synchronization = value
              return self
            }
            internal func clearSynchronization() -> Com.Seagate.Kinetic.Proto.Command.KeyValue.Builder {
               builderResult.hasSynchronization = false
               builderResult.synchronization = .InvalidSynchronization
               return self
            }
          override internal var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          internal override func clear() -> Com.Seagate.Kinetic.Proto.Command.KeyValue.Builder {
            builderResult = Com.Seagate.Kinetic.Proto.Command.KeyValue()
            return self
          }
          internal override func clone() throws -> Com.Seagate.Kinetic.Proto.Command.KeyValue.Builder {
            return try Com.Seagate.Kinetic.Proto.Command.KeyValue.builderWithPrototype(builderResult)
          }
          internal override func build() throws -> Com.Seagate.Kinetic.Proto.Command.KeyValue {
               try checkInitialized()
               return buildPartial()
          }
          internal func buildPartial() -> Com.Seagate.Kinetic.Proto.Command.KeyValue {
            let returnMe:Com.Seagate.Kinetic.Proto.Command.KeyValue = builderResult
            return returnMe
          }
          internal func mergeFrom(other:Com.Seagate.Kinetic.Proto.Command.KeyValue) throws -> Com.Seagate.Kinetic.Proto.Command.KeyValue.Builder {
            if other == Com.Seagate.Kinetic.Proto.Command.KeyValue() {
             return self
            }
            if other.hasNewVersion {
                 newVersion = other.newVersion
            }
            if other.hasForce {
                 force = other.force
            }
            if other.hasKey {
                 key = other.key
            }
            if other.hasDbVersion {
                 dbVersion = other.dbVersion
            }
            if other.hasTag {
                 tag = other.tag
            }
            if other.hasAlgorithm {
                 algorithm = other.algorithm
            }
            if other.hasMetadataOnly {
                 metadataOnly = other.metadataOnly
            }
            if other.hasSynchronization {
                 synchronization = other.synchronization
            }
            try mergeUnknownFields(other.unknownFields)
            return self
          }
          internal override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.KeyValue.Builder {
               return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
          }
          internal override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.KeyValue.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
            while (true) {
              let tag = try input.readTag()
              switch tag {
              case 0: 
                self.unknownFields = try unknownFieldsBuilder.build()
                return self

              case 18 :
                newVersion = try input.readData()

              case 26 :
                key = try input.readData()

              case 34 :
                dbVersion = try input.readData()
              //
              //case 42 :
              //  tag = try input.readData()

              case 48 :
                let valueIntalgorithm = try input.readEnum()
                if let enumsalgorithm = Command.Algorithm(rawValue:valueIntalgorithm){
                     algorithm = enumsalgorithm
                } else {
                     try unknownFieldsBuilder.mergeVarintField(6, value:Int64(valueIntalgorithm))
                }

              case 56 :
                metadataOnly = try input.readBool()

              case 64 :
                force = try input.readBool()

              case 72 :
                let valueIntsynchronization = try input.readEnum()
                if let enumssynchronization = Command.Synchronization(rawValue:valueIntsynchronization){
                     synchronization = enumssynchronization
                } else {
                     try unknownFieldsBuilder.mergeVarintField(9, value:Int64(valueIntsynchronization))
                }

              default:
                if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag))) {
                   unknownFields = try unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
        }

      }

    //Nested type declaration end



    //Nested type declaration start

      final internal class Range : GeneratedMessage, GeneratedMessageProtocol {
        private(set) var hasStartKey:Bool = false
        private(set) var startKey:NSData = NSData()

        private(set) var hasEndKey:Bool = false
        private(set) var endKey:NSData = NSData()

        private(set) var hasStartKeyInclusive:Bool = false
        private(set) var startKeyInclusive:Bool = false

        private(set) var hasEndKeyInclusive:Bool = false
        private(set) var endKeyInclusive:Bool = false

        private(set) var hasMaxReturned:Bool = false
        private(set) var maxReturned:Int32 = Int32(0)

        private(set) var hasReverse:Bool = false
        private(set) var reverse:Bool = false

        private(set) var keys:Array<NSData> = Array<NSData>()
        required internal init() {
             super.init()
        }
        override internal func isInitialized() -> Bool {
         return true
        }
        override internal func writeToCodedOutputStream(output:CodedOutputStream) throws {
          if hasStartKey {
            try output.writeData(1, value:startKey)
          }
          if hasEndKey {
            try output.writeData(2, value:endKey)
          }
          if hasStartKeyInclusive {
            try output.writeBool(3, value:startKeyInclusive)
          }
          if hasEndKeyInclusive {
            try output.writeBool(4, value:endKeyInclusive)
          }
          if hasMaxReturned {
            try output.writeInt32(5, value:maxReturned)
          }
          if hasReverse {
            try output.writeBool(6, value:reverse)
          }
          if !keys.isEmpty {
            for oneValuekeys in keys {
              try output.writeData(8, value:oneValuekeys)
            }
          }
          try unknownFields.writeToCodedOutputStream(output)
        }
        override internal func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          if hasStartKey {
            serialize_size += startKey.computeDataSize(1)
          }
          if hasEndKey {
            serialize_size += endKey.computeDataSize(2)
          }
          if hasStartKeyInclusive {
            serialize_size += startKeyInclusive.computeBoolSize(3)
          }
          if hasEndKeyInclusive {
            serialize_size += endKeyInclusive.computeBoolSize(4)
          }
          if hasMaxReturned {
            serialize_size += maxReturned.computeInt32Size(5)
          }
          if hasReverse {
            serialize_size += reverse.computeBoolSize(6)
          }
          var dataSizeKeys:Int32 = 0
          for oneValuekeys in keys {
              dataSizeKeys += oneValuekeys.computeDataSizeNoTag()
          }
          serialize_size += dataSizeKeys
          serialize_size += 1 * Int32(keys.count)
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        internal class func parseFromData(data:NSData) throws -> Com.Seagate.Kinetic.Proto.Command.Range {
          return try Com.Seagate.Kinetic.Proto.Command.Range.Builder().mergeFromData(data, extensionRegistry:Com.Seagate.Kinetic.Proto.KineticRoot.sharedInstance.extensionRegistry).build()
        }
        internal class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.Range {
          return try Com.Seagate.Kinetic.Proto.Command.Range.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
        }
        internal class func parseFromInputStream(input:NSInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.Range {
          return try Com.Seagate.Kinetic.Proto.Command.Range.Builder().mergeFromInputStream(input).build()
        }
        internal class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.Range {
          return try Com.Seagate.Kinetic.Proto.Command.Range.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        internal class func parseFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.Range {
          return try Com.Seagate.Kinetic.Proto.Command.Range.Builder().mergeFromCodedInputStream(input).build()
        }
        internal class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.Range {
          return try Com.Seagate.Kinetic.Proto.Command.Range.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        internal class func getBuilder() -> Com.Seagate.Kinetic.Proto.Command.Range.Builder {
          return Com.Seagate.Kinetic.Proto.Command.Range.classBuilder() as! Com.Seagate.Kinetic.Proto.Command.Range.Builder
        }
        internal func getBuilder() -> Com.Seagate.Kinetic.Proto.Command.Range.Builder {
          return classBuilder() as! Com.Seagate.Kinetic.Proto.Command.Range.Builder
        }
        internal override class func classBuilder() -> MessageBuilder {
          return Com.Seagate.Kinetic.Proto.Command.Range.Builder()
        }
        internal override func classBuilder() -> MessageBuilder {
          return Com.Seagate.Kinetic.Proto.Command.Range.Builder()
        }
        internal func toBuilder() throws -> Com.Seagate.Kinetic.Proto.Command.Range.Builder {
          return try Com.Seagate.Kinetic.Proto.Command.Range.builderWithPrototype(self)
        }
        internal class func builderWithPrototype(prototype:Com.Seagate.Kinetic.Proto.Command.Range) throws -> Com.Seagate.Kinetic.Proto.Command.Range.Builder {
          return try Com.Seagate.Kinetic.Proto.Command.Range.Builder().mergeFrom(prototype)
        }
        override internal func writeDescriptionTo(inout output:String, indent:String) throws {
          if hasStartKey {
            output += "\(indent) startKey: \(startKey) \n"
          }
          if hasEndKey {
            output += "\(indent) endKey: \(endKey) \n"
          }
          if hasStartKeyInclusive {
            output += "\(indent) startKeyInclusive: \(startKeyInclusive) \n"
          }
          if hasEndKeyInclusive {
            output += "\(indent) endKeyInclusive: \(endKeyInclusive) \n"
          }
          if hasMaxReturned {
            output += "\(indent) maxReturned: \(maxReturned) \n"
          }
          if hasReverse {
            output += "\(indent) reverse: \(reverse) \n"
          }
          var keysElementIndex:Int = 0
          for oneValuekeys in keys  {
              output += "\(indent) keys[\(keysElementIndex)]: \(oneValuekeys)\n"
              keysElementIndex++
          }
          unknownFields.writeDescriptionTo(&output, indent:indent)
        }
        override internal var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasStartKey {
                   hashCode = (hashCode &* 31) &+ startKey.hashValue
                }
                if hasEndKey {
                   hashCode = (hashCode &* 31) &+ endKey.hashValue
                }
                if hasStartKeyInclusive {
                   hashCode = (hashCode &* 31) &+ startKeyInclusive.hashValue
                }
                if hasEndKeyInclusive {
                   hashCode = (hashCode &* 31) &+ endKeyInclusive.hashValue
                }
                if hasMaxReturned {
                   hashCode = (hashCode &* 31) &+ maxReturned.hashValue
                }
                if hasReverse {
                   hashCode = (hashCode &* 31) &+ reverse.hashValue
                }
                for oneValuekeys in keys {
                    hashCode = (hashCode &* 31) &+ oneValuekeys.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override internal class func className() -> String {
            return "Com.Seagate.Kinetic.Proto.Command.Range"
        }
        override internal func className() -> String {
            return "Com.Seagate.Kinetic.Proto.Command.Range"
        }
        override internal func classMetaType() -> GeneratedMessage.Type {
            return Com.Seagate.Kinetic.Proto.Command.Range.self
        }
        //Meta information declaration end

        final internal class Builder : GeneratedMessageBuilder {
          private var builderResult:Com.Seagate.Kinetic.Proto.Command.Range = Com.Seagate.Kinetic.Proto.Command.Range()
          internal func getMessage() -> Com.Seagate.Kinetic.Proto.Command.Range {
              return builderResult
          }

          required override internal init () {
             super.init()
          }
          var hasStartKey:Bool {
               get {
                    return builderResult.hasStartKey
               }
          }
          var startKey:NSData {
               get {
                    return builderResult.startKey
               }
               set (value) {
                   builderResult.hasStartKey = true
                   builderResult.startKey = value
               }
          }
          func setStartKey(value:NSData) -> Com.Seagate.Kinetic.Proto.Command.Range.Builder {
            self.startKey = value
            return self
          }
          internal func clearStartKey() -> Com.Seagate.Kinetic.Proto.Command.Range.Builder{
               builderResult.hasStartKey = false
               builderResult.startKey = NSData()
               return self
          }
          var hasEndKey:Bool {
               get {
                    return builderResult.hasEndKey
               }
          }
          var endKey:NSData {
               get {
                    return builderResult.endKey
               }
               set (value) {
                   builderResult.hasEndKey = true
                   builderResult.endKey = value
               }
          }
          func setEndKey(value:NSData) -> Com.Seagate.Kinetic.Proto.Command.Range.Builder {
            self.endKey = value
            return self
          }
          internal func clearEndKey() -> Com.Seagate.Kinetic.Proto.Command.Range.Builder{
               builderResult.hasEndKey = false
               builderResult.endKey = NSData()
               return self
          }
          var hasStartKeyInclusive:Bool {
               get {
                    return builderResult.hasStartKeyInclusive
               }
          }
          var startKeyInclusive:Bool {
               get {
                    return builderResult.startKeyInclusive
               }
               set (value) {
                   builderResult.hasStartKeyInclusive = true
                   builderResult.startKeyInclusive = value
               }
          }
          func setStartKeyInclusive(value:Bool) -> Com.Seagate.Kinetic.Proto.Command.Range.Builder {
            self.startKeyInclusive = value
            return self
          }
          internal func clearStartKeyInclusive() -> Com.Seagate.Kinetic.Proto.Command.Range.Builder{
               builderResult.hasStartKeyInclusive = false
               builderResult.startKeyInclusive = false
               return self
          }
          var hasEndKeyInclusive:Bool {
               get {
                    return builderResult.hasEndKeyInclusive
               }
          }
          var endKeyInclusive:Bool {
               get {
                    return builderResult.endKeyInclusive
               }
               set (value) {
                   builderResult.hasEndKeyInclusive = true
                   builderResult.endKeyInclusive = value
               }
          }
          func setEndKeyInclusive(value:Bool) -> Com.Seagate.Kinetic.Proto.Command.Range.Builder {
            self.endKeyInclusive = value
            return self
          }
          internal func clearEndKeyInclusive() -> Com.Seagate.Kinetic.Proto.Command.Range.Builder{
               builderResult.hasEndKeyInclusive = false
               builderResult.endKeyInclusive = false
               return self
          }
          var hasMaxReturned:Bool {
               get {
                    return builderResult.hasMaxReturned
               }
          }
          var maxReturned:Int32 {
               get {
                    return builderResult.maxReturned
               }
               set (value) {
                   builderResult.hasMaxReturned = true
                   builderResult.maxReturned = value
               }
          }
          func setMaxReturned(value:Int32) -> Com.Seagate.Kinetic.Proto.Command.Range.Builder {
            self.maxReturned = value
            return self
          }
          internal func clearMaxReturned() -> Com.Seagate.Kinetic.Proto.Command.Range.Builder{
               builderResult.hasMaxReturned = false
               builderResult.maxReturned = Int32(0)
               return self
          }
          var hasReverse:Bool {
               get {
                    return builderResult.hasReverse
               }
          }
          var reverse:Bool {
               get {
                    return builderResult.reverse
               }
               set (value) {
                   builderResult.hasReverse = true
                   builderResult.reverse = value
               }
          }
          func setReverse(value:Bool) -> Com.Seagate.Kinetic.Proto.Command.Range.Builder {
            self.reverse = value
            return self
          }
          internal func clearReverse() -> Com.Seagate.Kinetic.Proto.Command.Range.Builder{
               builderResult.hasReverse = false
               builderResult.reverse = false
               return self
          }
          var keys:Array<NSData> {
               get {
                   return builderResult.keys
               }
               set (array) {
                   builderResult.keys = array
               }
          }
          func setKeys(value:Array<NSData>) -> Com.Seagate.Kinetic.Proto.Command.Range.Builder {
            self.keys = value
            return self
          }
          internal func clearKeys() -> Com.Seagate.Kinetic.Proto.Command.Range.Builder {
             builderResult.keys.removeAll(keepCapacity: false)
             return self
          }
          override internal var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          internal override func clear() -> Com.Seagate.Kinetic.Proto.Command.Range.Builder {
            builderResult = Com.Seagate.Kinetic.Proto.Command.Range()
            return self
          }
          internal override func clone() throws -> Com.Seagate.Kinetic.Proto.Command.Range.Builder {
            return try Com.Seagate.Kinetic.Proto.Command.Range.builderWithPrototype(builderResult)
          }
          internal override func build() throws -> Com.Seagate.Kinetic.Proto.Command.Range {
               try checkInitialized()
               return buildPartial()
          }
          internal func buildPartial() -> Com.Seagate.Kinetic.Proto.Command.Range {
            let returnMe:Com.Seagate.Kinetic.Proto.Command.Range = builderResult
            return returnMe
          }
          internal func mergeFrom(other:Com.Seagate.Kinetic.Proto.Command.Range) throws -> Com.Seagate.Kinetic.Proto.Command.Range.Builder {
            if other == Com.Seagate.Kinetic.Proto.Command.Range() {
             return self
            }
            if other.hasStartKey {
                 startKey = other.startKey
            }
            if other.hasEndKey {
                 endKey = other.endKey
            }
            if other.hasStartKeyInclusive {
                 startKeyInclusive = other.startKeyInclusive
            }
            if other.hasEndKeyInclusive {
                 endKeyInclusive = other.endKeyInclusive
            }
            if other.hasMaxReturned {
                 maxReturned = other.maxReturned
            }
            if other.hasReverse {
                 reverse = other.reverse
            }
            if !other.keys.isEmpty {
                builderResult.keys += other.keys
            }
            try mergeUnknownFields(other.unknownFields)
            return self
          }
          internal override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.Range.Builder {
               return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
          }
          internal override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.Range.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
            while (true) {
              let tag = try input.readTag()
              switch tag {
              case 0: 
                self.unknownFields = try unknownFieldsBuilder.build()
                return self

              case 10 :
                startKey = try input.readData()

              case 18 :
                endKey = try input.readData()

              case 24 :
                startKeyInclusive = try input.readBool()

              case 32 :
                endKeyInclusive = try input.readBool()

              case 40 :
                maxReturned = try input.readInt32()

              case 48 :
                reverse = try input.readBool()

              case 66 :
                keys += [try input.readData()]

              default:
                if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag))) {
                   unknownFields = try unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
        }

      }

    //Nested type declaration end



    //Nested type declaration start

      final internal class Setup : GeneratedMessage, GeneratedMessageProtocol {
        private(set) var hasNewClusterVersion:Bool = false
        private(set) var newClusterVersion:Int64 = Int64(0)

        private(set) var hasFirmwareDownload:Bool = false
        private(set) var firmwareDownload:Bool = false

        required internal init() {
             super.init()
        }
        override internal func isInitialized() -> Bool {
         return true
        }
        override internal func writeToCodedOutputStream(output:CodedOutputStream) throws {
          if hasNewClusterVersion {
            try output.writeInt64(1, value:newClusterVersion)
          }
          if hasFirmwareDownload {
            try output.writeBool(5, value:firmwareDownload)
          }
          try unknownFields.writeToCodedOutputStream(output)
        }
        override internal func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          if hasNewClusterVersion {
            serialize_size += newClusterVersion.computeInt64Size(1)
          }
          if hasFirmwareDownload {
            serialize_size += firmwareDownload.computeBoolSize(5)
          }
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        internal class func parseFromData(data:NSData) throws -> Com.Seagate.Kinetic.Proto.Command.Setup {
          return try Com.Seagate.Kinetic.Proto.Command.Setup.Builder().mergeFromData(data, extensionRegistry:Com.Seagate.Kinetic.Proto.KineticRoot.sharedInstance.extensionRegistry).build()
        }
        internal class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.Setup {
          return try Com.Seagate.Kinetic.Proto.Command.Setup.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
        }
        internal class func parseFromInputStream(input:NSInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.Setup {
          return try Com.Seagate.Kinetic.Proto.Command.Setup.Builder().mergeFromInputStream(input).build()
        }
        internal class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.Setup {
          return try Com.Seagate.Kinetic.Proto.Command.Setup.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        internal class func parseFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.Setup {
          return try Com.Seagate.Kinetic.Proto.Command.Setup.Builder().mergeFromCodedInputStream(input).build()
        }
        internal class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.Setup {
          return try Com.Seagate.Kinetic.Proto.Command.Setup.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        internal class func getBuilder() -> Com.Seagate.Kinetic.Proto.Command.Setup.Builder {
          return Com.Seagate.Kinetic.Proto.Command.Setup.classBuilder() as! Com.Seagate.Kinetic.Proto.Command.Setup.Builder
        }
        internal func getBuilder() -> Com.Seagate.Kinetic.Proto.Command.Setup.Builder {
          return classBuilder() as! Com.Seagate.Kinetic.Proto.Command.Setup.Builder
        }
        internal override class func classBuilder() -> MessageBuilder {
          return Com.Seagate.Kinetic.Proto.Command.Setup.Builder()
        }
        internal override func classBuilder() -> MessageBuilder {
          return Com.Seagate.Kinetic.Proto.Command.Setup.Builder()
        }
        internal func toBuilder() throws -> Com.Seagate.Kinetic.Proto.Command.Setup.Builder {
          return try Com.Seagate.Kinetic.Proto.Command.Setup.builderWithPrototype(self)
        }
        internal class func builderWithPrototype(prototype:Com.Seagate.Kinetic.Proto.Command.Setup) throws -> Com.Seagate.Kinetic.Proto.Command.Setup.Builder {
          return try Com.Seagate.Kinetic.Proto.Command.Setup.Builder().mergeFrom(prototype)
        }
        override internal func writeDescriptionTo(inout output:String, indent:String) throws {
          if hasNewClusterVersion {
            output += "\(indent) newClusterVersion: \(newClusterVersion) \n"
          }
          if hasFirmwareDownload {
            output += "\(indent) firmwareDownload: \(firmwareDownload) \n"
          }
          unknownFields.writeDescriptionTo(&output, indent:indent)
        }
        override internal var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasNewClusterVersion {
                   hashCode = (hashCode &* 31) &+ newClusterVersion.hashValue
                }
                if hasFirmwareDownload {
                   hashCode = (hashCode &* 31) &+ firmwareDownload.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override internal class func className() -> String {
            return "Com.Seagate.Kinetic.Proto.Command.Setup"
        }
        override internal func className() -> String {
            return "Com.Seagate.Kinetic.Proto.Command.Setup"
        }
        override internal func classMetaType() -> GeneratedMessage.Type {
            return Com.Seagate.Kinetic.Proto.Command.Setup.self
        }
        //Meta information declaration end

        final internal class Builder : GeneratedMessageBuilder {
          private var builderResult:Com.Seagate.Kinetic.Proto.Command.Setup = Com.Seagate.Kinetic.Proto.Command.Setup()
          internal func getMessage() -> Com.Seagate.Kinetic.Proto.Command.Setup {
              return builderResult
          }

          required override internal init () {
             super.init()
          }
          var hasNewClusterVersion:Bool {
               get {
                    return builderResult.hasNewClusterVersion
               }
          }
          var newClusterVersion:Int64 {
               get {
                    return builderResult.newClusterVersion
               }
               set (value) {
                   builderResult.hasNewClusterVersion = true
                   builderResult.newClusterVersion = value
               }
          }
          func setNewClusterVersion(value:Int64) -> Com.Seagate.Kinetic.Proto.Command.Setup.Builder {
            self.newClusterVersion = value
            return self
          }
          internal func clearNewClusterVersion() -> Com.Seagate.Kinetic.Proto.Command.Setup.Builder{
               builderResult.hasNewClusterVersion = false
               builderResult.newClusterVersion = Int64(0)
               return self
          }
          var hasFirmwareDownload:Bool {
               get {
                    return builderResult.hasFirmwareDownload
               }
          }
          var firmwareDownload:Bool {
               get {
                    return builderResult.firmwareDownload
               }
               set (value) {
                   builderResult.hasFirmwareDownload = true
                   builderResult.firmwareDownload = value
               }
          }
          func setFirmwareDownload(value:Bool) -> Com.Seagate.Kinetic.Proto.Command.Setup.Builder {
            self.firmwareDownload = value
            return self
          }
          internal func clearFirmwareDownload() -> Com.Seagate.Kinetic.Proto.Command.Setup.Builder{
               builderResult.hasFirmwareDownload = false
               builderResult.firmwareDownload = false
               return self
          }
          override internal var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          internal override func clear() -> Com.Seagate.Kinetic.Proto.Command.Setup.Builder {
            builderResult = Com.Seagate.Kinetic.Proto.Command.Setup()
            return self
          }
          internal override func clone() throws -> Com.Seagate.Kinetic.Proto.Command.Setup.Builder {
            return try Com.Seagate.Kinetic.Proto.Command.Setup.builderWithPrototype(builderResult)
          }
          internal override func build() throws -> Com.Seagate.Kinetic.Proto.Command.Setup {
               try checkInitialized()
               return buildPartial()
          }
          internal func buildPartial() -> Com.Seagate.Kinetic.Proto.Command.Setup {
            let returnMe:Com.Seagate.Kinetic.Proto.Command.Setup = builderResult
            return returnMe
          }
          internal func mergeFrom(other:Com.Seagate.Kinetic.Proto.Command.Setup) throws -> Com.Seagate.Kinetic.Proto.Command.Setup.Builder {
            if other == Com.Seagate.Kinetic.Proto.Command.Setup() {
             return self
            }
            if other.hasNewClusterVersion {
                 newClusterVersion = other.newClusterVersion
            }
            if other.hasFirmwareDownload {
                 firmwareDownload = other.firmwareDownload
            }
            try mergeUnknownFields(other.unknownFields)
            return self
          }
          internal override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.Setup.Builder {
               return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
          }
          internal override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.Setup.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
            while (true) {
              let tag = try input.readTag()
              switch tag {
              case 0: 
                self.unknownFields = try unknownFieldsBuilder.build()
                return self

              case 8 :
                newClusterVersion = try input.readInt64()

              case 40 :
                firmwareDownload = try input.readBool()

              default:
                if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag))) {
                   unknownFields = try unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
        }

      }

    //Nested type declaration end



    //Nested type declaration start

      final internal class P2Poperation : GeneratedMessage, GeneratedMessageProtocol {


        //Nested type declaration start

          final internal class Operation : GeneratedMessage, GeneratedMessageProtocol {
            private(set) var hasKey:Bool = false
            private(set) var key:NSData = NSData()

            private(set) var hasVersion:Bool = false
            private(set) var version:NSData = NSData()

            private(set) var hasNewKey:Bool = false
            private(set) var newKey:NSData = NSData()

            private(set) var hasForce:Bool = false
            private(set) var force:Bool = false

            private(set) var hasStatus:Bool = false
            private(set) var status:Com.Seagate.Kinetic.Proto.Command.Status!
            private(set) var hasP2Pop:Bool = false
            private(set) var p2Pop:Com.Seagate.Kinetic.Proto.Command.P2Poperation!
            required internal init() {
                 super.init()
            }
            override internal func isInitialized() -> Bool {
             return true
            }
            override internal func writeToCodedOutputStream(output:CodedOutputStream) throws {
              if hasKey {
                try output.writeData(3, value:key)
              }
              if hasVersion {
                try output.writeData(4, value:version)
              }
              if hasNewKey {
                try output.writeData(5, value:newKey)
              }
              if hasForce {
                try output.writeBool(6, value:force)
              }
              if hasStatus {
                try output.writeMessage(7, value:status)
              }
              if hasP2Pop {
                try output.writeMessage(8, value:p2Pop)
              }
              try unknownFields.writeToCodedOutputStream(output)
            }
            override internal func serializedSize() -> Int32 {
              var serialize_size:Int32 = memoizedSerializedSize
              if serialize_size != -1 {
               return serialize_size
              }

              serialize_size = 0
              if hasKey {
                serialize_size += key.computeDataSize(3)
              }
              if hasVersion {
                serialize_size += version.computeDataSize(4)
              }
              if hasNewKey {
                serialize_size += newKey.computeDataSize(5)
              }
              if hasForce {
                serialize_size += force.computeBoolSize(6)
              }
              if hasStatus {
                  if let varSizestatus = status?.computeMessageSize(7) {
                      serialize_size += varSizestatus
                  }
              }
              if hasP2Pop {
                  if let varSizep2Pop = p2Pop?.computeMessageSize(8) {
                      serialize_size += varSizep2Pop
                  }
              }
              serialize_size += unknownFields.serializedSize()
              memoizedSerializedSize = serialize_size
              return serialize_size
            }
            internal class func parseFromData(data:NSData) throws -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation {
              return try Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation.Builder().mergeFromData(data, extensionRegistry:Com.Seagate.Kinetic.Proto.KineticRoot.sharedInstance.extensionRegistry).build()
            }
            internal class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation {
              return try Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
            }
            internal class func parseFromInputStream(input:NSInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation {
              return try Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation.Builder().mergeFromInputStream(input).build()
            }
            internal class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation {
              return try Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
            }
            internal class func parseFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation {
              return try Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation.Builder().mergeFromCodedInputStream(input).build()
            }
            internal class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation {
              return try Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
            }
            internal class func getBuilder() -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation.Builder {
              return Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation.classBuilder() as! Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation.Builder
            }
            internal func getBuilder() -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation.Builder {
              return classBuilder() as! Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation.Builder
            }
            internal override class func classBuilder() -> MessageBuilder {
              return Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation.Builder()
            }
            internal override func classBuilder() -> MessageBuilder {
              return Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation.Builder()
            }
            internal func toBuilder() throws -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation.Builder {
              return try Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation.builderWithPrototype(self)
            }
            internal class func builderWithPrototype(prototype:Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation) throws -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation.Builder {
              return try Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation.Builder().mergeFrom(prototype)
            }
            override internal func writeDescriptionTo(inout output:String, indent:String) throws {
              if hasKey {
                output += "\(indent) key: \(key) \n"
              }
              if hasVersion {
                output += "\(indent) version: \(version) \n"
              }
              if hasNewKey {
                output += "\(indent) newKey: \(newKey) \n"
              }
              if hasForce {
                output += "\(indent) force: \(force) \n"
              }
              if hasStatus {
                output += "\(indent) status {\n"
                try status?.writeDescriptionTo(&output, indent:"\(indent)  ")
                output += "\(indent) }\n"
              }
              if hasP2Pop {
                output += "\(indent) p2Pop {\n"
                try p2Pop?.writeDescriptionTo(&output, indent:"\(indent)  ")
                output += "\(indent) }\n"
              }
              unknownFields.writeDescriptionTo(&output, indent:indent)
            }
            override internal var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasKey {
                       hashCode = (hashCode &* 31) &+ key.hashValue
                    }
                    if hasVersion {
                       hashCode = (hashCode &* 31) &+ version.hashValue
                    }
                    if hasNewKey {
                       hashCode = (hashCode &* 31) &+ newKey.hashValue
                    }
                    if hasForce {
                       hashCode = (hashCode &* 31) &+ force.hashValue
                    }
                    if hasStatus {
                        if let hashValuestatus = status?.hashValue {
                            hashCode = (hashCode &* 31) &+ hashValuestatus
                        }
                    }
                    if hasP2Pop {
                        if let hashValuep2Pop = p2Pop?.hashValue {
                            hashCode = (hashCode &* 31) &+ hashValuep2Pop
                        }
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override internal class func className() -> String {
                return "Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation"
            }
            override internal func className() -> String {
                return "Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation"
            }
            override internal func classMetaType() -> GeneratedMessage.Type {
                return Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation.self
            }
            //Meta information declaration end

            final internal class Builder : GeneratedMessageBuilder {
              private var builderResult:Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation = Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation()
              internal func getMessage() -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation {
                  return builderResult
              }

              required override internal init () {
                 super.init()
              }
              var hasKey:Bool {
                   get {
                        return builderResult.hasKey
                   }
              }
              var key:NSData {
                   get {
                        return builderResult.key
                   }
                   set (value) {
                       builderResult.hasKey = true
                       builderResult.key = value
                   }
              }
              func setKey(value:NSData) -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation.Builder {
                self.key = value
                return self
              }
              internal func clearKey() -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation.Builder{
                   builderResult.hasKey = false
                   builderResult.key = NSData()
                   return self
              }
              var hasVersion:Bool {
                   get {
                        return builderResult.hasVersion
                   }
              }
              var version:NSData {
                   get {
                        return builderResult.version
                   }
                   set (value) {
                       builderResult.hasVersion = true
                       builderResult.version = value
                   }
              }
              func setVersion(value:NSData) -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation.Builder {
                self.version = value
                return self
              }
              internal func clearVersion() -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation.Builder{
                   builderResult.hasVersion = false
                   builderResult.version = NSData()
                   return self
              }
              var hasNewKey:Bool {
                   get {
                        return builderResult.hasNewKey
                   }
              }
              var newKey:NSData {
                   get {
                        return builderResult.newKey
                   }
                   set (value) {
                       builderResult.hasNewKey = true
                       builderResult.newKey = value
                   }
              }
              func setNewKey(value:NSData) -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation.Builder {
                self.newKey = value
                return self
              }
              internal func clearNewKey() -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation.Builder{
                   builderResult.hasNewKey = false
                   builderResult.newKey = NSData()
                   return self
              }
              var hasForce:Bool {
                   get {
                        return builderResult.hasForce
                   }
              }
              var force:Bool {
                   get {
                        return builderResult.force
                   }
                   set (value) {
                       builderResult.hasForce = true
                       builderResult.force = value
                   }
              }
              func setForce(value:Bool) -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation.Builder {
                self.force = value
                return self
              }
              internal func clearForce() -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation.Builder{
                   builderResult.hasForce = false
                   builderResult.force = false
                   return self
              }
              var hasStatus:Bool {
                   get {
                       return builderResult.hasStatus
                   }
              }
              var status:Com.Seagate.Kinetic.Proto.Command.Status! {
                   get {
                       if statusBuilder_ != nil {
                          builderResult.status = statusBuilder_.getMessage()
                       }
                       return builderResult.status
                   }
                   set (value) {
                       builderResult.hasStatus = true
                       builderResult.status = value
                   }
              }
              private var statusBuilder_:Com.Seagate.Kinetic.Proto.Command.Status.Builder! {
                   didSet {
                      builderResult.hasStatus = true
                   }
              }
              internal func getStatusBuilder() -> Com.Seagate.Kinetic.Proto.Command.Status.Builder {
                if statusBuilder_ == nil {
                   statusBuilder_ = Com.Seagate.Kinetic.Proto.Command.Status.Builder()
                   builderResult.status = statusBuilder_.getMessage()
                   if status != nil {
                      try! statusBuilder_.mergeFrom(status)
                   }
                }
                return statusBuilder_
              }
              func setStatus(value:Com.Seagate.Kinetic.Proto.Command.Status!) -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation.Builder {
                self.status = value
                return self
              }
              internal func mergeStatus(value:Com.Seagate.Kinetic.Proto.Command.Status) throws -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation.Builder {
                if builderResult.hasStatus {
                  builderResult.status = try Com.Seagate.Kinetic.Proto.Command.Status.builderWithPrototype(builderResult.status).mergeFrom(value).buildPartial()
                } else {
                  builderResult.status = value
                }
                builderResult.hasStatus = true
                return self
              }
              internal func clearStatus() -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation.Builder {
                statusBuilder_ = nil
                builderResult.hasStatus = false
                builderResult.status = nil
                return self
              }
              var hasP2Pop:Bool {
                   get {
                       return builderResult.hasP2Pop
                   }
              }
              var p2Pop:Com.Seagate.Kinetic.Proto.Command.P2Poperation! {
                   get {
                       if p2PopBuilder_ != nil {
                          builderResult.p2Pop = p2PopBuilder_.getMessage()
                       }
                       return builderResult.p2Pop
                   }
                   set (value) {
                       builderResult.hasP2Pop = true
                       builderResult.p2Pop = value
                   }
              }
              private var p2PopBuilder_:Com.Seagate.Kinetic.Proto.Command.P2Poperation.Builder! {
                   didSet {
                      builderResult.hasP2Pop = true
                   }
              }
              internal func getP2PopBuilder() -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Builder {
                if p2PopBuilder_ == nil {
                   p2PopBuilder_ = Com.Seagate.Kinetic.Proto.Command.P2Poperation.Builder()
                   builderResult.p2Pop = p2PopBuilder_.getMessage()
                   if p2Pop != nil {
                      try! p2PopBuilder_.mergeFrom(p2Pop)
                   }
                }
                return p2PopBuilder_
              }
              func setP2Pop(value:Com.Seagate.Kinetic.Proto.Command.P2Poperation!) -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation.Builder {
                self.p2Pop = value
                return self
              }
              internal func mergeP2Pop(value:Com.Seagate.Kinetic.Proto.Command.P2Poperation) throws -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation.Builder {
                if builderResult.hasP2Pop {
                  builderResult.p2Pop = try Com.Seagate.Kinetic.Proto.Command.P2Poperation.builderWithPrototype(builderResult.p2Pop).mergeFrom(value).buildPartial()
                } else {
                  builderResult.p2Pop = value
                }
                builderResult.hasP2Pop = true
                return self
              }
              internal func clearP2Pop() -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation.Builder {
                p2PopBuilder_ = nil
                builderResult.hasP2Pop = false
                builderResult.p2Pop = nil
                return self
              }
              override internal var internalGetResult:GeneratedMessage {
                   get {
                      return builderResult
                   }
              }
              internal override func clear() -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation.Builder {
                builderResult = Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation()
                return self
              }
              internal override func clone() throws -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation.Builder {
                return try Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation.builderWithPrototype(builderResult)
              }
              internal override func build() throws -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation {
                   try checkInitialized()
                   return buildPartial()
              }
              internal func buildPartial() -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation {
                let returnMe:Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation = builderResult
                return returnMe
              }
              internal func mergeFrom(other:Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation) throws -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation.Builder {
                if other == Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation() {
                 return self
                }
                if other.hasKey {
                     key = other.key
                }
                if other.hasVersion {
                     version = other.version
                }
                if other.hasNewKey {
                     newKey = other.newKey
                }
                if other.hasForce {
                     force = other.force
                }
                if (other.hasStatus) {
                    try mergeStatus(other.status)
                }
                if (other.hasP2Pop) {
                    try mergeP2Pop(other.p2Pop)
                }
                try mergeUnknownFields(other.unknownFields)
                return self
              }
              internal override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation.Builder {
                   return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
              }
              internal override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
                while (true) {
                  let tag = try input.readTag()
                  switch tag {
                  case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                  case 26 :
                    key = try input.readData()

                  case 34 :
                    version = try input.readData()

                  case 42 :
                    newKey = try input.readData()

                  case 48 :
                    force = try input.readBool()

                  case 58 :
                    let subBuilder:Com.Seagate.Kinetic.Proto.Command.Status.Builder = Com.Seagate.Kinetic.Proto.Command.Status.Builder()
                    if hasStatus {
                      try subBuilder.mergeFrom(status)
                    }
                    try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
                    status = subBuilder.buildPartial()

                  case 66 :
                    let subBuilder:Com.Seagate.Kinetic.Proto.Command.P2Poperation.Builder = Com.Seagate.Kinetic.Proto.Command.P2Poperation.Builder()
                    if hasP2Pop {
                      try subBuilder.mergeFrom(p2Pop)
                    }
                    try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
                    p2Pop = subBuilder.buildPartial()

                  default:
                    if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag))) {
                       unknownFields = try unknownFieldsBuilder.build()
                       return self
                    }
                  }
                }
              }
            }

          }

        //Nested type declaration end



        //Nested type declaration start

          final internal class Peer : GeneratedMessage, GeneratedMessageProtocol {
            private(set) var hasHostname:Bool = false
            private(set) var hostname:String = ""

            private(set) var hasPort:Bool = false
            private(set) var port:Int32 = Int32(0)

            private(set) var hasTls:Bool = false
            private(set) var tls:Bool = false

            required internal init() {
                 super.init()
            }
            override internal func isInitialized() -> Bool {
             return true
            }
            override internal func writeToCodedOutputStream(output:CodedOutputStream) throws {
              if hasHostname {
                try output.writeString(1, value:hostname)
              }
              if hasPort {
                try output.writeInt32(2, value:port)
              }
              if hasTls {
                try output.writeBool(3, value:tls)
              }
              try unknownFields.writeToCodedOutputStream(output)
            }
            override internal func serializedSize() -> Int32 {
              var serialize_size:Int32 = memoizedSerializedSize
              if serialize_size != -1 {
               return serialize_size
              }

              serialize_size = 0
              if hasHostname {
                serialize_size += hostname.computeStringSize(1)
              }
              if hasPort {
                serialize_size += port.computeInt32Size(2)
              }
              if hasTls {
                serialize_size += tls.computeBoolSize(3)
              }
              serialize_size += unknownFields.serializedSize()
              memoizedSerializedSize = serialize_size
              return serialize_size
            }
            internal class func parseFromData(data:NSData) throws -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer {
              return try Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer.Builder().mergeFromData(data, extensionRegistry:Com.Seagate.Kinetic.Proto.KineticRoot.sharedInstance.extensionRegistry).build()
            }
            internal class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer {
              return try Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
            }
            internal class func parseFromInputStream(input:NSInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer {
              return try Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer.Builder().mergeFromInputStream(input).build()
            }
            internal class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer {
              return try Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
            }
            internal class func parseFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer {
              return try Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer.Builder().mergeFromCodedInputStream(input).build()
            }
            internal class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer {
              return try Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
            }
            internal class func getBuilder() -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer.Builder {
              return Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer.classBuilder() as! Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer.Builder
            }
            internal func getBuilder() -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer.Builder {
              return classBuilder() as! Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer.Builder
            }
            internal override class func classBuilder() -> MessageBuilder {
              return Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer.Builder()
            }
            internal override func classBuilder() -> MessageBuilder {
              return Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer.Builder()
            }
            internal func toBuilder() throws -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer.Builder {
              return try Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer.builderWithPrototype(self)
            }
            internal class func builderWithPrototype(prototype:Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer) throws -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer.Builder {
              return try Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer.Builder().mergeFrom(prototype)
            }
            override internal func writeDescriptionTo(inout output:String, indent:String) throws {
              if hasHostname {
                output += "\(indent) hostname: \(hostname) \n"
              }
              if hasPort {
                output += "\(indent) port: \(port) \n"
              }
              if hasTls {
                output += "\(indent) tls: \(tls) \n"
              }
              unknownFields.writeDescriptionTo(&output, indent:indent)
            }
            override internal var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasHostname {
                       hashCode = (hashCode &* 31) &+ hostname.hashValue
                    }
                    if hasPort {
                       hashCode = (hashCode &* 31) &+ port.hashValue
                    }
                    if hasTls {
                       hashCode = (hashCode &* 31) &+ tls.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override internal class func className() -> String {
                return "Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer"
            }
            override internal func className() -> String {
                return "Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer"
            }
            override internal func classMetaType() -> GeneratedMessage.Type {
                return Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer.self
            }
            //Meta information declaration end

            final internal class Builder : GeneratedMessageBuilder {
              private var builderResult:Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer = Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer()
              internal func getMessage() -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer {
                  return builderResult
              }

              required override internal init () {
                 super.init()
              }
              var hasHostname:Bool {
                   get {
                        return builderResult.hasHostname
                   }
              }
              var hostname:String {
                   get {
                        return builderResult.hostname
                   }
                   set (value) {
                       builderResult.hasHostname = true
                       builderResult.hostname = value
                   }
              }
              func setHostname(value:String) -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer.Builder {
                self.hostname = value
                return self
              }
              internal func clearHostname() -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer.Builder{
                   builderResult.hasHostname = false
                   builderResult.hostname = ""
                   return self
              }
              var hasPort:Bool {
                   get {
                        return builderResult.hasPort
                   }
              }
              var port:Int32 {
                   get {
                        return builderResult.port
                   }
                   set (value) {
                       builderResult.hasPort = true
                       builderResult.port = value
                   }
              }
              func setPort(value:Int32) -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer.Builder {
                self.port = value
                return self
              }
              internal func clearPort() -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer.Builder{
                   builderResult.hasPort = false
                   builderResult.port = Int32(0)
                   return self
              }
              var hasTls:Bool {
                   get {
                        return builderResult.hasTls
                   }
              }
              var tls:Bool {
                   get {
                        return builderResult.tls
                   }
                   set (value) {
                       builderResult.hasTls = true
                       builderResult.tls = value
                   }
              }
              func setTls(value:Bool) -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer.Builder {
                self.tls = value
                return self
              }
              internal func clearTls() -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer.Builder{
                   builderResult.hasTls = false
                   builderResult.tls = false
                   return self
              }
              override internal var internalGetResult:GeneratedMessage {
                   get {
                      return builderResult
                   }
              }
              internal override func clear() -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer.Builder {
                builderResult = Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer()
                return self
              }
              internal override func clone() throws -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer.Builder {
                return try Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer.builderWithPrototype(builderResult)
              }
              internal override func build() throws -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer {
                   try checkInitialized()
                   return buildPartial()
              }
              internal func buildPartial() -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer {
                let returnMe:Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer = builderResult
                return returnMe
              }
              internal func mergeFrom(other:Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer) throws -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer.Builder {
                if other == Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer() {
                 return self
                }
                if other.hasHostname {
                     hostname = other.hostname
                }
                if other.hasPort {
                     port = other.port
                }
                if other.hasTls {
                     tls = other.tls
                }
                try mergeUnknownFields(other.unknownFields)
                return self
              }
              internal override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer.Builder {
                   return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
              }
              internal override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
                while (true) {
                  let tag = try input.readTag()
                  switch tag {
                  case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                  case 10 :
                    hostname = try input.readString()

                  case 16 :
                    port = try input.readInt32()

                  case 24 :
                    tls = try input.readBool()

                  default:
                    if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag))) {
                       unknownFields = try unknownFieldsBuilder.build()
                       return self
                    }
                  }
                }
              }
            }

          }

        //Nested type declaration end

        private(set) var hasPeer:Bool = false
        private(set) var peer:Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer!
        private(set) var operation:Array<Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation>  = Array<Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation>()
        private(set) var hasAllChildOperationsSucceeded:Bool = false
        private(set) var allChildOperationsSucceeded:Bool = false

        required internal init() {
             super.init()
        }
        override internal func isInitialized() -> Bool {
         return true
        }
        override internal func writeToCodedOutputStream(output:CodedOutputStream) throws {
          if hasPeer {
            try output.writeMessage(1, value:peer)
          }
          for oneElementoperation in operation {
              try output.writeMessage(2, value:oneElementoperation)
          }
          if hasAllChildOperationsSucceeded {
            try output.writeBool(3, value:allChildOperationsSucceeded)
          }
          try unknownFields.writeToCodedOutputStream(output)
        }
        override internal func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          if hasPeer {
              if let varSizepeer = peer?.computeMessageSize(1) {
                  serialize_size += varSizepeer
              }
          }
          for oneElementoperation in operation {
              serialize_size += oneElementoperation.computeMessageSize(2)
          }
          if hasAllChildOperationsSucceeded {
            serialize_size += allChildOperationsSucceeded.computeBoolSize(3)
          }
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        internal class func parseFromData(data:NSData) throws -> Com.Seagate.Kinetic.Proto.Command.P2Poperation {
          return try Com.Seagate.Kinetic.Proto.Command.P2Poperation.Builder().mergeFromData(data, extensionRegistry:Com.Seagate.Kinetic.Proto.KineticRoot.sharedInstance.extensionRegistry).build()
        }
        internal class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.P2Poperation {
          return try Com.Seagate.Kinetic.Proto.Command.P2Poperation.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
        }
        internal class func parseFromInputStream(input:NSInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.P2Poperation {
          return try Com.Seagate.Kinetic.Proto.Command.P2Poperation.Builder().mergeFromInputStream(input).build()
        }
        internal class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.P2Poperation {
          return try Com.Seagate.Kinetic.Proto.Command.P2Poperation.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        internal class func parseFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.P2Poperation {
          return try Com.Seagate.Kinetic.Proto.Command.P2Poperation.Builder().mergeFromCodedInputStream(input).build()
        }
        internal class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.P2Poperation {
          return try Com.Seagate.Kinetic.Proto.Command.P2Poperation.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        internal class func getBuilder() -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Builder {
          return Com.Seagate.Kinetic.Proto.Command.P2Poperation.classBuilder() as! Com.Seagate.Kinetic.Proto.Command.P2Poperation.Builder
        }
        internal func getBuilder() -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Builder {
          return classBuilder() as! Com.Seagate.Kinetic.Proto.Command.P2Poperation.Builder
        }
        internal override class func classBuilder() -> MessageBuilder {
          return Com.Seagate.Kinetic.Proto.Command.P2Poperation.Builder()
        }
        internal override func classBuilder() -> MessageBuilder {
          return Com.Seagate.Kinetic.Proto.Command.P2Poperation.Builder()
        }
        internal func toBuilder() throws -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Builder {
          return try Com.Seagate.Kinetic.Proto.Command.P2Poperation.builderWithPrototype(self)
        }
        internal class func builderWithPrototype(prototype:Com.Seagate.Kinetic.Proto.Command.P2Poperation) throws -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Builder {
          return try Com.Seagate.Kinetic.Proto.Command.P2Poperation.Builder().mergeFrom(prototype)
        }
        override internal func writeDescriptionTo(inout output:String, indent:String) throws {
          if hasPeer {
            output += "\(indent) peer {\n"
            try peer?.writeDescriptionTo(&output, indent:"\(indent)  ")
            output += "\(indent) }\n"
          }
          var operationElementIndex:Int = 0
          for oneElementoperation in operation {
              output += "\(indent) operation[\(operationElementIndex)] {\n"
              try oneElementoperation.writeDescriptionTo(&output, indent:"\(indent)  ")
              output += "\(indent)}\n"
              operationElementIndex++
          }
          if hasAllChildOperationsSucceeded {
            output += "\(indent) allChildOperationsSucceeded: \(allChildOperationsSucceeded) \n"
          }
          unknownFields.writeDescriptionTo(&output, indent:indent)
        }
        override internal var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasPeer {
                    if let hashValuepeer = peer?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuepeer
                    }
                }
                for oneElementoperation in operation {
                    hashCode = (hashCode &* 31) &+ oneElementoperation.hashValue
                }
                if hasAllChildOperationsSucceeded {
                   hashCode = (hashCode &* 31) &+ allChildOperationsSucceeded.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override internal class func className() -> String {
            return "Com.Seagate.Kinetic.Proto.Command.P2Poperation"
        }
        override internal func className() -> String {
            return "Com.Seagate.Kinetic.Proto.Command.P2Poperation"
        }
        override internal func classMetaType() -> GeneratedMessage.Type {
            return Com.Seagate.Kinetic.Proto.Command.P2Poperation.self
        }
        //Meta information declaration end

        final internal class Builder : GeneratedMessageBuilder {
          private var builderResult:Com.Seagate.Kinetic.Proto.Command.P2Poperation = Com.Seagate.Kinetic.Proto.Command.P2Poperation()
          internal func getMessage() -> Com.Seagate.Kinetic.Proto.Command.P2Poperation {
              return builderResult
          }

          required override internal init () {
             super.init()
          }
          var hasPeer:Bool {
               get {
                   return builderResult.hasPeer
               }
          }
          var peer:Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer! {
               get {
                   if peerBuilder_ != nil {
                      builderResult.peer = peerBuilder_.getMessage()
                   }
                   return builderResult.peer
               }
               set (value) {
                   builderResult.hasPeer = true
                   builderResult.peer = value
               }
          }
          private var peerBuilder_:Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer.Builder! {
               didSet {
                  builderResult.hasPeer = true
               }
          }
          internal func getPeerBuilder() -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer.Builder {
            if peerBuilder_ == nil {
               peerBuilder_ = Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer.Builder()
               builderResult.peer = peerBuilder_.getMessage()
               if peer != nil {
                  try! peerBuilder_.mergeFrom(peer)
               }
            }
            return peerBuilder_
          }
          func setPeer(value:Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer!) -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Builder {
            self.peer = value
            return self
          }
          internal func mergePeer(value:Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer) throws -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Builder {
            if builderResult.hasPeer {
              builderResult.peer = try Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer.builderWithPrototype(builderResult.peer).mergeFrom(value).buildPartial()
            } else {
              builderResult.peer = value
            }
            builderResult.hasPeer = true
            return self
          }
          internal func clearPeer() -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Builder {
            peerBuilder_ = nil
            builderResult.hasPeer = false
            builderResult.peer = nil
            return self
          }
          var operation:Array<Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation> {
               get {
                   return builderResult.operation
               }
               set (value) {
                   builderResult.operation = value
               }
          }
          func setOperation(value:Array<Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation>) -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Builder {
            self.operation = value
            return self
          }
          internal func clearOperation() -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Builder {
            builderResult.operation.removeAll(keepCapacity: false)
            return self
          }
          var hasAllChildOperationsSucceeded:Bool {
               get {
                    return builderResult.hasAllChildOperationsSucceeded
               }
          }
          var allChildOperationsSucceeded:Bool {
               get {
                    return builderResult.allChildOperationsSucceeded
               }
               set (value) {
                   builderResult.hasAllChildOperationsSucceeded = true
                   builderResult.allChildOperationsSucceeded = value
               }
          }
          func setAllChildOperationsSucceeded(value:Bool) -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Builder {
            self.allChildOperationsSucceeded = value
            return self
          }
          internal func clearAllChildOperationsSucceeded() -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Builder{
               builderResult.hasAllChildOperationsSucceeded = false
               builderResult.allChildOperationsSucceeded = false
               return self
          }
          override internal var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          internal override func clear() -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Builder {
            builderResult = Com.Seagate.Kinetic.Proto.Command.P2Poperation()
            return self
          }
          internal override func clone() throws -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Builder {
            return try Com.Seagate.Kinetic.Proto.Command.P2Poperation.builderWithPrototype(builderResult)
          }
          internal override func build() throws -> Com.Seagate.Kinetic.Proto.Command.P2Poperation {
               try checkInitialized()
               return buildPartial()
          }
          internal func buildPartial() -> Com.Seagate.Kinetic.Proto.Command.P2Poperation {
            let returnMe:Com.Seagate.Kinetic.Proto.Command.P2Poperation = builderResult
            return returnMe
          }
          internal func mergeFrom(other:Com.Seagate.Kinetic.Proto.Command.P2Poperation) throws -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Builder {
            if other == Com.Seagate.Kinetic.Proto.Command.P2Poperation() {
             return self
            }
            if (other.hasPeer) {
                try mergePeer(other.peer)
            }
            if !other.operation.isEmpty  {
               builderResult.operation += other.operation
            }
            if other.hasAllChildOperationsSucceeded {
                 allChildOperationsSucceeded = other.allChildOperationsSucceeded
            }
            try mergeUnknownFields(other.unknownFields)
            return self
          }
          internal override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Builder {
               return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
          }
          internal override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.P2Poperation.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
            while (true) {
              let tag = try input.readTag()
              switch tag {
              case 0: 
                self.unknownFields = try unknownFieldsBuilder.build()
                return self

              case 10 :
                let subBuilder:Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer.Builder = Com.Seagate.Kinetic.Proto.Command.P2Poperation.Peer.Builder()
                if hasPeer {
                  try subBuilder.mergeFrom(peer)
                }
                try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
                peer = subBuilder.buildPartial()

              case 18 :
                let subBuilder = Com.Seagate.Kinetic.Proto.Command.P2Poperation.Operation.Builder()
                try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
                operation += [subBuilder.buildPartial()]

              case 24 :
                allChildOperationsSucceeded = try input.readBool()

              default:
                if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag))) {
                   unknownFields = try unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
        }

      }

    //Nested type declaration end



    //Nested type declaration start

      final internal class GetLog : GeneratedMessage, GeneratedMessageProtocol {


        //Nested type declaration start

          final internal class Utilization : GeneratedMessage, GeneratedMessageProtocol {
            private(set) var hasName:Bool = false
            private(set) var name:String = ""

            private(set) var hasValue:Bool = false
            private(set) var value:Float = Float(0)

            required internal init() {
                 super.init()
            }
            override internal func isInitialized() -> Bool {
             return true
            }
            override internal func writeToCodedOutputStream(output:CodedOutputStream) throws {
              if hasName {
                try output.writeString(1, value:name)
              }
              if hasValue {
                try output.writeFloat(2, value:value)
              }
              try unknownFields.writeToCodedOutputStream(output)
            }
            override internal func serializedSize() -> Int32 {
              var serialize_size:Int32 = memoizedSerializedSize
              if serialize_size != -1 {
               return serialize_size
              }

              serialize_size = 0
              if hasName {
                serialize_size += name.computeStringSize(1)
              }
              if hasValue {
                serialize_size += value.computeFloatSize(2)
              }
              serialize_size += unknownFields.serializedSize()
              memoizedSerializedSize = serialize_size
              return serialize_size
            }
            internal class func parseFromData(data:NSData) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization.Builder().mergeFromData(data, extensionRegistry:Com.Seagate.Kinetic.Proto.KineticRoot.sharedInstance.extensionRegistry).build()
            }
            internal class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
            }
            internal class func parseFromInputStream(input:NSInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization.Builder().mergeFromInputStream(input).build()
            }
            internal class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
            }
            internal class func parseFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization.Builder().mergeFromCodedInputStream(input).build()
            }
            internal class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
            }
            internal class func getBuilder() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization.Builder {
              return Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization.classBuilder() as! Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization.Builder
            }
            internal func getBuilder() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization.Builder {
              return classBuilder() as! Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization.Builder
            }
            internal override class func classBuilder() -> MessageBuilder {
              return Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization.Builder()
            }
            internal override func classBuilder() -> MessageBuilder {
              return Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization.Builder()
            }
            internal func toBuilder() throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization.Builder {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization.builderWithPrototype(self)
            }
            internal class func builderWithPrototype(prototype:Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization.Builder {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization.Builder().mergeFrom(prototype)
            }
            override internal func writeDescriptionTo(inout output:String, indent:String) throws {
              if hasName {
                output += "\(indent) name: \(name) \n"
              }
              if hasValue {
                output += "\(indent) value: \(value) \n"
              }
              unknownFields.writeDescriptionTo(&output, indent:indent)
            }
            override internal var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasName {
                       hashCode = (hashCode &* 31) &+ name.hashValue
                    }
                    if hasValue {
                       hashCode = (hashCode &* 31) &+ value.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override internal class func className() -> String {
                return "Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization"
            }
            override internal func className() -> String {
                return "Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization"
            }
            override internal func classMetaType() -> GeneratedMessage.Type {
                return Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization.self
            }
            //Meta information declaration end

            final internal class Builder : GeneratedMessageBuilder {
              private var builderResult:Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization = Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization()
              internal func getMessage() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization {
                  return builderResult
              }

              required override internal init () {
                 super.init()
              }
              var hasName:Bool {
                   get {
                        return builderResult.hasName
                   }
              }
              var name:String {
                   get {
                        return builderResult.name
                   }
                   set (value) {
                       builderResult.hasName = true
                       builderResult.name = value
                   }
              }
              func setName(value:String) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization.Builder {
                self.name = value
                return self
              }
              internal func clearName() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization.Builder{
                   builderResult.hasName = false
                   builderResult.name = ""
                   return self
              }
              var hasValue:Bool {
                   get {
                        return builderResult.hasValue
                   }
              }
              var value:Float {
                   get {
                        return builderResult.value
                   }
                   set (value) {
                       builderResult.hasValue = true
                       builderResult.value = value
                   }
              }
              func setValue(value:Float) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization.Builder {
                self.value = value
                return self
              }
              internal func clearValue() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization.Builder{
                   builderResult.hasValue = false
                   builderResult.value = Float(0)
                   return self
              }
              override internal var internalGetResult:GeneratedMessage {
                   get {
                      return builderResult
                   }
              }
              internal override func clear() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization.Builder {
                builderResult = Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization()
                return self
              }
              internal override func clone() throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization.Builder {
                return try Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization.builderWithPrototype(builderResult)
              }
              internal override func build() throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization {
                   try checkInitialized()
                   return buildPartial()
              }
              internal func buildPartial() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization {
                let returnMe:Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization = builderResult
                return returnMe
              }
              internal func mergeFrom(other:Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization.Builder {
                if other == Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization() {
                 return self
                }
                if other.hasName {
                     name = other.name
                }
                if other.hasValue {
                     value = other.value
                }
                try mergeUnknownFields(other.unknownFields)
                return self
              }
              internal override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization.Builder {
                   return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
              }
              internal override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
                while (true) {
                  let tag = try input.readTag()
                  switch tag {
                  case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                  case 10 :
                    name = try input.readString()

                  case 21 :
                    value = try input.readFloat()

                  default:
                    if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag))) {
                       unknownFields = try unknownFieldsBuilder.build()
                       return self
                    }
                  }
                }
              }
            }

          }

        //Nested type declaration end



        //Nested type declaration start

          final internal class Temperature : GeneratedMessage, GeneratedMessageProtocol {
            private(set) var hasName:Bool = false
            private(set) var name:String = ""

            private(set) var hasCurrent:Bool = false
            private(set) var current:Float = Float(0)

            private(set) var hasMinimum:Bool = false
            private(set) var minimum:Float = Float(0)

            private(set) var hasMaximum:Bool = false
            private(set) var maximum:Float = Float(0)

            private(set) var hasTarget:Bool = false
            private(set) var target:Float = Float(0)

            required internal init() {
                 super.init()
            }
            override internal func isInitialized() -> Bool {
             return true
            }
            override internal func writeToCodedOutputStream(output:CodedOutputStream) throws {
              if hasName {
                try output.writeString(1, value:name)
              }
              if hasCurrent {
                try output.writeFloat(2, value:current)
              }
              if hasMinimum {
                try output.writeFloat(3, value:minimum)
              }
              if hasMaximum {
                try output.writeFloat(4, value:maximum)
              }
              if hasTarget {
                try output.writeFloat(5, value:target)
              }
              try unknownFields.writeToCodedOutputStream(output)
            }
            override internal func serializedSize() -> Int32 {
              var serialize_size:Int32 = memoizedSerializedSize
              if serialize_size != -1 {
               return serialize_size
              }

              serialize_size = 0
              if hasName {
                serialize_size += name.computeStringSize(1)
              }
              if hasCurrent {
                serialize_size += current.computeFloatSize(2)
              }
              if hasMinimum {
                serialize_size += minimum.computeFloatSize(3)
              }
              if hasMaximum {
                serialize_size += maximum.computeFloatSize(4)
              }
              if hasTarget {
                serialize_size += target.computeFloatSize(5)
              }
              serialize_size += unknownFields.serializedSize()
              memoizedSerializedSize = serialize_size
              return serialize_size
            }
            internal class func parseFromData(data:NSData) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature.Builder().mergeFromData(data, extensionRegistry:Com.Seagate.Kinetic.Proto.KineticRoot.sharedInstance.extensionRegistry).build()
            }
            internal class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
            }
            internal class func parseFromInputStream(input:NSInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature.Builder().mergeFromInputStream(input).build()
            }
            internal class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
            }
            internal class func parseFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature.Builder().mergeFromCodedInputStream(input).build()
            }
            internal class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
            }
            internal class func getBuilder() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature.Builder {
              return Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature.classBuilder() as! Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature.Builder
            }
            internal func getBuilder() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature.Builder {
              return classBuilder() as! Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature.Builder
            }
            internal override class func classBuilder() -> MessageBuilder {
              return Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature.Builder()
            }
            internal override func classBuilder() -> MessageBuilder {
              return Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature.Builder()
            }
            internal func toBuilder() throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature.Builder {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature.builderWithPrototype(self)
            }
            internal class func builderWithPrototype(prototype:Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature.Builder {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature.Builder().mergeFrom(prototype)
            }
            override internal func writeDescriptionTo(inout output:String, indent:String) throws {
              if hasName {
                output += "\(indent) name: \(name) \n"
              }
              if hasCurrent {
                output += "\(indent) current: \(current) \n"
              }
              if hasMinimum {
                output += "\(indent) minimum: \(minimum) \n"
              }
              if hasMaximum {
                output += "\(indent) maximum: \(maximum) \n"
              }
              if hasTarget {
                output += "\(indent) target: \(target) \n"
              }
              unknownFields.writeDescriptionTo(&output, indent:indent)
            }
            override internal var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasName {
                       hashCode = (hashCode &* 31) &+ name.hashValue
                    }
                    if hasCurrent {
                       hashCode = (hashCode &* 31) &+ current.hashValue
                    }
                    if hasMinimum {
                       hashCode = (hashCode &* 31) &+ minimum.hashValue
                    }
                    if hasMaximum {
                       hashCode = (hashCode &* 31) &+ maximum.hashValue
                    }
                    if hasTarget {
                       hashCode = (hashCode &* 31) &+ target.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override internal class func className() -> String {
                return "Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature"
            }
            override internal func className() -> String {
                return "Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature"
            }
            override internal func classMetaType() -> GeneratedMessage.Type {
                return Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature.self
            }
            //Meta information declaration end

            final internal class Builder : GeneratedMessageBuilder {
              private var builderResult:Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature = Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature()
              internal func getMessage() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature {
                  return builderResult
              }

              required override internal init () {
                 super.init()
              }
              var hasName:Bool {
                   get {
                        return builderResult.hasName
                   }
              }
              var name:String {
                   get {
                        return builderResult.name
                   }
                   set (value) {
                       builderResult.hasName = true
                       builderResult.name = value
                   }
              }
              func setName(value:String) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature.Builder {
                self.name = value
                return self
              }
              internal func clearName() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature.Builder{
                   builderResult.hasName = false
                   builderResult.name = ""
                   return self
              }
              var hasCurrent:Bool {
                   get {
                        return builderResult.hasCurrent
                   }
              }
              var current:Float {
                   get {
                        return builderResult.current
                   }
                   set (value) {
                       builderResult.hasCurrent = true
                       builderResult.current = value
                   }
              }
              func setCurrent(value:Float) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature.Builder {
                self.current = value
                return self
              }
              internal func clearCurrent() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature.Builder{
                   builderResult.hasCurrent = false
                   builderResult.current = Float(0)
                   return self
              }
              var hasMinimum:Bool {
                   get {
                        return builderResult.hasMinimum
                   }
              }
              var minimum:Float {
                   get {
                        return builderResult.minimum
                   }
                   set (value) {
                       builderResult.hasMinimum = true
                       builderResult.minimum = value
                   }
              }
              func setMinimum(value:Float) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature.Builder {
                self.minimum = value
                return self
              }
              internal func clearMinimum() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature.Builder{
                   builderResult.hasMinimum = false
                   builderResult.minimum = Float(0)
                   return self
              }
              var hasMaximum:Bool {
                   get {
                        return builderResult.hasMaximum
                   }
              }
              var maximum:Float {
                   get {
                        return builderResult.maximum
                   }
                   set (value) {
                       builderResult.hasMaximum = true
                       builderResult.maximum = value
                   }
              }
              func setMaximum(value:Float) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature.Builder {
                self.maximum = value
                return self
              }
              internal func clearMaximum() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature.Builder{
                   builderResult.hasMaximum = false
                   builderResult.maximum = Float(0)
                   return self
              }
              var hasTarget:Bool {
                   get {
                        return builderResult.hasTarget
                   }
              }
              var target:Float {
                   get {
                        return builderResult.target
                   }
                   set (value) {
                       builderResult.hasTarget = true
                       builderResult.target = value
                   }
              }
              func setTarget(value:Float) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature.Builder {
                self.target = value
                return self
              }
              internal func clearTarget() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature.Builder{
                   builderResult.hasTarget = false
                   builderResult.target = Float(0)
                   return self
              }
              override internal var internalGetResult:GeneratedMessage {
                   get {
                      return builderResult
                   }
              }
              internal override func clear() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature.Builder {
                builderResult = Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature()
                return self
              }
              internal override func clone() throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature.Builder {
                return try Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature.builderWithPrototype(builderResult)
              }
              internal override func build() throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature {
                   try checkInitialized()
                   return buildPartial()
              }
              internal func buildPartial() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature {
                let returnMe:Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature = builderResult
                return returnMe
              }
              internal func mergeFrom(other:Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature.Builder {
                if other == Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature() {
                 return self
                }
                if other.hasName {
                     name = other.name
                }
                if other.hasCurrent {
                     current = other.current
                }
                if other.hasMinimum {
                     minimum = other.minimum
                }
                if other.hasMaximum {
                     maximum = other.maximum
                }
                if other.hasTarget {
                     target = other.target
                }
                try mergeUnknownFields(other.unknownFields)
                return self
              }
              internal override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature.Builder {
                   return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
              }
              internal override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
                while (true) {
                  let tag = try input.readTag()
                  switch tag {
                  case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                  case 10 :
                    name = try input.readString()

                  case 21 :
                    current = try input.readFloat()

                  case 29 :
                    minimum = try input.readFloat()

                  case 37 :
                    maximum = try input.readFloat()

                  case 45 :
                    target = try input.readFloat()

                  default:
                    if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag))) {
                       unknownFields = try unknownFieldsBuilder.build()
                       return self
                    }
                  }
                }
              }
            }

          }

        //Nested type declaration end



        //Nested type declaration start

          final internal class Capacity : GeneratedMessage, GeneratedMessageProtocol {
            private(set) var hasNominalCapacityInBytes:Bool = false
            private(set) var nominalCapacityInBytes:UInt64 = UInt64(0)

            private(set) var hasPortionFull:Bool = false
            private(set) var portionFull:Float = Float(0)

            required internal init() {
                 super.init()
            }
            override internal func isInitialized() -> Bool {
             return true
            }
            override internal func writeToCodedOutputStream(output:CodedOutputStream) throws {
              if hasNominalCapacityInBytes {
                try output.writeUInt64(4, value:nominalCapacityInBytes)
              }
              if hasPortionFull {
                try output.writeFloat(5, value:portionFull)
              }
              try unknownFields.writeToCodedOutputStream(output)
            }
            override internal func serializedSize() -> Int32 {
              var serialize_size:Int32 = memoizedSerializedSize
              if serialize_size != -1 {
               return serialize_size
              }

              serialize_size = 0
              if hasNominalCapacityInBytes {
                serialize_size += nominalCapacityInBytes.computeUInt64Size(4)
              }
              if hasPortionFull {
                serialize_size += portionFull.computeFloatSize(5)
              }
              serialize_size += unknownFields.serializedSize()
              memoizedSerializedSize = serialize_size
              return serialize_size
            }
            internal class func parseFromData(data:NSData) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity.Builder().mergeFromData(data, extensionRegistry:Com.Seagate.Kinetic.Proto.KineticRoot.sharedInstance.extensionRegistry).build()
            }
            internal class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
            }
            internal class func parseFromInputStream(input:NSInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity.Builder().mergeFromInputStream(input).build()
            }
            internal class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
            }
            internal class func parseFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity.Builder().mergeFromCodedInputStream(input).build()
            }
            internal class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
            }
            internal class func getBuilder() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity.Builder {
              return Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity.classBuilder() as! Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity.Builder
            }
            internal func getBuilder() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity.Builder {
              return classBuilder() as! Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity.Builder
            }
            internal override class func classBuilder() -> MessageBuilder {
              return Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity.Builder()
            }
            internal override func classBuilder() -> MessageBuilder {
              return Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity.Builder()
            }
            internal func toBuilder() throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity.Builder {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity.builderWithPrototype(self)
            }
            internal class func builderWithPrototype(prototype:Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity.Builder {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity.Builder().mergeFrom(prototype)
            }
            override internal func writeDescriptionTo(inout output:String, indent:String) throws {
              if hasNominalCapacityInBytes {
                output += "\(indent) nominalCapacityInBytes: \(nominalCapacityInBytes) \n"
              }
              if hasPortionFull {
                output += "\(indent) portionFull: \(portionFull) \n"
              }
              unknownFields.writeDescriptionTo(&output, indent:indent)
            }
            override internal var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasNominalCapacityInBytes {
                       hashCode = (hashCode &* 31) &+ nominalCapacityInBytes.hashValue
                    }
                    if hasPortionFull {
                       hashCode = (hashCode &* 31) &+ portionFull.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override internal class func className() -> String {
                return "Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity"
            }
            override internal func className() -> String {
                return "Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity"
            }
            override internal func classMetaType() -> GeneratedMessage.Type {
                return Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity.self
            }
            //Meta information declaration end

            final internal class Builder : GeneratedMessageBuilder {
              private var builderResult:Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity = Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity()
              internal func getMessage() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity {
                  return builderResult
              }

              required override internal init () {
                 super.init()
              }
              var hasNominalCapacityInBytes:Bool {
                   get {
                        return builderResult.hasNominalCapacityInBytes
                   }
              }
              var nominalCapacityInBytes:UInt64 {
                   get {
                        return builderResult.nominalCapacityInBytes
                   }
                   set (value) {
                       builderResult.hasNominalCapacityInBytes = true
                       builderResult.nominalCapacityInBytes = value
                   }
              }
              func setNominalCapacityInBytes(value:UInt64) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity.Builder {
                self.nominalCapacityInBytes = value
                return self
              }
              internal func clearNominalCapacityInBytes() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity.Builder{
                   builderResult.hasNominalCapacityInBytes = false
                   builderResult.nominalCapacityInBytes = UInt64(0)
                   return self
              }
              var hasPortionFull:Bool {
                   get {
                        return builderResult.hasPortionFull
                   }
              }
              var portionFull:Float {
                   get {
                        return builderResult.portionFull
                   }
                   set (value) {
                       builderResult.hasPortionFull = true
                       builderResult.portionFull = value
                   }
              }
              func setPortionFull(value:Float) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity.Builder {
                self.portionFull = value
                return self
              }
              internal func clearPortionFull() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity.Builder{
                   builderResult.hasPortionFull = false
                   builderResult.portionFull = Float(0)
                   return self
              }
              override internal var internalGetResult:GeneratedMessage {
                   get {
                      return builderResult
                   }
              }
              internal override func clear() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity.Builder {
                builderResult = Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity()
                return self
              }
              internal override func clone() throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity.Builder {
                return try Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity.builderWithPrototype(builderResult)
              }
              internal override func build() throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity {
                   try checkInitialized()
                   return buildPartial()
              }
              internal func buildPartial() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity {
                let returnMe:Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity = builderResult
                return returnMe
              }
              internal func mergeFrom(other:Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity.Builder {
                if other == Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity() {
                 return self
                }
                if other.hasNominalCapacityInBytes {
                     nominalCapacityInBytes = other.nominalCapacityInBytes
                }
                if other.hasPortionFull {
                     portionFull = other.portionFull
                }
                try mergeUnknownFields(other.unknownFields)
                return self
              }
              internal override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity.Builder {
                   return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
              }
              internal override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
                while (true) {
                  let tag = try input.readTag()
                  switch tag {
                  case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                  case 32 :
                    nominalCapacityInBytes = try input.readUInt64()

                  case 45 :
                    portionFull = try input.readFloat()

                  default:
                    if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag))) {
                       unknownFields = try unknownFieldsBuilder.build()
                       return self
                    }
                  }
                }
              }
            }

          }

        //Nested type declaration end



        //Nested type declaration start

          final internal class Configuration : GeneratedMessage, GeneratedMessageProtocol {


            //Nested type declaration start

              final internal class Interface : GeneratedMessage, GeneratedMessageProtocol {
                private(set) var hasName:Bool = false
                private(set) var name:String = ""

                private(set) var hasMac:Bool = false
                private(set) var mac:NSData = NSData()

                private(set) var hasIpv4Address:Bool = false
                private(set) var ipv4Address:NSData = NSData()

                private(set) var hasIpv6Address:Bool = false
                private(set) var ipv6Address:NSData = NSData()

                required internal init() {
                     super.init()
                }
                override internal func isInitialized() -> Bool {
                 return true
                }
                override internal func writeToCodedOutputStream(output:CodedOutputStream) throws {
                  if hasName {
                    try output.writeString(1, value:name)
                  }
                  if hasMac {
                    try output.writeData(2, value:mac)
                  }
                  if hasIpv4Address {
                    try output.writeData(3, value:ipv4Address)
                  }
                  if hasIpv6Address {
                    try output.writeData(4, value:ipv6Address)
                  }
                  try unknownFields.writeToCodedOutputStream(output)
                }
                override internal func serializedSize() -> Int32 {
                  var serialize_size:Int32 = memoizedSerializedSize
                  if serialize_size != -1 {
                   return serialize_size
                  }

                  serialize_size = 0
                  if hasName {
                    serialize_size += name.computeStringSize(1)
                  }
                  if hasMac {
                    serialize_size += mac.computeDataSize(2)
                  }
                  if hasIpv4Address {
                    serialize_size += ipv4Address.computeDataSize(3)
                  }
                  if hasIpv6Address {
                    serialize_size += ipv6Address.computeDataSize(4)
                  }
                  serialize_size += unknownFields.serializedSize()
                  memoizedSerializedSize = serialize_size
                  return serialize_size
                }
                internal class func parseFromData(data:NSData) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface {
                  return try Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface.Builder().mergeFromData(data, extensionRegistry:Com.Seagate.Kinetic.Proto.KineticRoot.sharedInstance.extensionRegistry).build()
                }
                internal class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface {
                  return try Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
                }
                internal class func parseFromInputStream(input:NSInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface {
                  return try Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface.Builder().mergeFromInputStream(input).build()
                }
                internal class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface {
                  return try Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
                }
                internal class func parseFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface {
                  return try Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface.Builder().mergeFromCodedInputStream(input).build()
                }
                internal class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface {
                  return try Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
                }
                internal class func getBuilder() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface.Builder {
                  return Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface.classBuilder() as! Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface.Builder
                }
                internal func getBuilder() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface.Builder {
                  return classBuilder() as! Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface.Builder
                }
                internal override class func classBuilder() -> MessageBuilder {
                  return Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface.Builder()
                }
                internal override func classBuilder() -> MessageBuilder {
                  return Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface.Builder()
                }
                internal func toBuilder() throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface.Builder {
                  return try Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface.builderWithPrototype(self)
                }
                internal class func builderWithPrototype(prototype:Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface.Builder {
                  return try Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface.Builder().mergeFrom(prototype)
                }
                override internal func writeDescriptionTo(inout output:String, indent:String) throws {
                  if hasName {
                    output += "\(indent) name: \(name) \n"
                  }
                  if hasMac {
                    output += "\(indent) mac: \(mac) \n"
                  }
                  if hasIpv4Address {
                    output += "\(indent) ipv4Address: \(ipv4Address) \n"
                  }
                  if hasIpv6Address {
                    output += "\(indent) ipv6Address: \(ipv6Address) \n"
                  }
                  unknownFields.writeDescriptionTo(&output, indent:indent)
                }
                override internal var hashValue:Int {
                    get {
                        var hashCode:Int = 7
                        if hasName {
                           hashCode = (hashCode &* 31) &+ name.hashValue
                        }
                        if hasMac {
                           hashCode = (hashCode &* 31) &+ mac.hashValue
                        }
                        if hasIpv4Address {
                           hashCode = (hashCode &* 31) &+ ipv4Address.hashValue
                        }
                        if hasIpv6Address {
                           hashCode = (hashCode &* 31) &+ ipv6Address.hashValue
                        }
                        hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                        return hashCode
                    }
                }


                //Meta information declaration start

                override internal class func className() -> String {
                    return "Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface"
                }
                override internal func className() -> String {
                    return "Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface"
                }
                override internal func classMetaType() -> GeneratedMessage.Type {
                    return Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface.self
                }
                //Meta information declaration end

                final internal class Builder : GeneratedMessageBuilder {
                  private var builderResult:Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface = Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface()
                  internal func getMessage() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface {
                      return builderResult
                  }

                  required override internal init () {
                     super.init()
                  }
                  var hasName:Bool {
                       get {
                            return builderResult.hasName
                       }
                  }
                  var name:String {
                       get {
                            return builderResult.name
                       }
                       set (value) {
                           builderResult.hasName = true
                           builderResult.name = value
                       }
                  }
                  func setName(value:String) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface.Builder {
                    self.name = value
                    return self
                  }
                  internal func clearName() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface.Builder{
                       builderResult.hasName = false
                       builderResult.name = ""
                       return self
                  }
                  var hasMac:Bool {
                       get {
                            return builderResult.hasMac
                       }
                  }
                  var mac:NSData {
                       get {
                            return builderResult.mac
                       }
                       set (value) {
                           builderResult.hasMac = true
                           builderResult.mac = value
                       }
                  }
                  func setMac(value:NSData) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface.Builder {
                    self.mac = value
                    return self
                  }
                  internal func clearMac() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface.Builder{
                       builderResult.hasMac = false
                       builderResult.mac = NSData()
                       return self
                  }
                  var hasIpv4Address:Bool {
                       get {
                            return builderResult.hasIpv4Address
                       }
                  }
                  var ipv4Address:NSData {
                       get {
                            return builderResult.ipv4Address
                       }
                       set (value) {
                           builderResult.hasIpv4Address = true
                           builderResult.ipv4Address = value
                       }
                  }
                  func setIpv4Address(value:NSData) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface.Builder {
                    self.ipv4Address = value
                    return self
                  }
                  internal func clearIpv4Address() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface.Builder{
                       builderResult.hasIpv4Address = false
                       builderResult.ipv4Address = NSData()
                       return self
                  }
                  var hasIpv6Address:Bool {
                       get {
                            return builderResult.hasIpv6Address
                       }
                  }
                  var ipv6Address:NSData {
                       get {
                            return builderResult.ipv6Address
                       }
                       set (value) {
                           builderResult.hasIpv6Address = true
                           builderResult.ipv6Address = value
                       }
                  }
                  func setIpv6Address(value:NSData) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface.Builder {
                    self.ipv6Address = value
                    return self
                  }
                  internal func clearIpv6Address() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface.Builder{
                       builderResult.hasIpv6Address = false
                       builderResult.ipv6Address = NSData()
                       return self
                  }
                  override internal var internalGetResult:GeneratedMessage {
                       get {
                          return builderResult
                       }
                  }
                  internal override func clear() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface.Builder {
                    builderResult = Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface()
                    return self
                  }
                  internal override func clone() throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface.Builder {
                    return try Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface.builderWithPrototype(builderResult)
                  }
                  internal override func build() throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface {
                       try checkInitialized()
                       return buildPartial()
                  }
                  internal func buildPartial() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface {
                    let returnMe:Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface = builderResult
                    return returnMe
                  }
                  internal func mergeFrom(other:Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface.Builder {
                    if other == Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface() {
                     return self
                    }
                    if other.hasName {
                         name = other.name
                    }
                    if other.hasMac {
                         mac = other.mac
                    }
                    if other.hasIpv4Address {
                         ipv4Address = other.ipv4Address
                    }
                    if other.hasIpv6Address {
                         ipv6Address = other.ipv6Address
                    }
                    try mergeUnknownFields(other.unknownFields)
                    return self
                  }
                  internal override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface.Builder {
                       return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
                  }
                  internal override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
                    while (true) {
                      let tag = try input.readTag()
                      switch tag {
                      case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                      case 10 :
                        name = try input.readString()

                      case 18 :
                        mac = try input.readData()

                      case 26 :
                        ipv4Address = try input.readData()

                      case 34 :
                        ipv6Address = try input.readData()

                      default:
                        if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag))) {
                           unknownFields = try unknownFieldsBuilder.build()
                           return self
                        }
                      }
                    }
                  }
                }

              }

            //Nested type declaration end

            private(set) var hasVendor:Bool = false
            private(set) var vendor:String = ""

            private(set) var hasModel:Bool = false
            private(set) var model:String = ""

            private(set) var hasSerialNumber:Bool = false
            private(set) var serialNumber:NSData = NSData()

            private(set) var hasWorldWideName:Bool = false
            private(set) var worldWideName:NSData = NSData()

            private(set) var hasVersion:Bool = false
            private(set) var version:String = ""

            private(set) var hasCompilationDate:Bool = false
            private(set) var compilationDate:String = ""

            private(set) var hasSourceHash:Bool = false
            private(set) var sourceHash:String = ""

            private(set) var hasProtocolVersion:Bool = false
            private(set) var protocolVersion:String = ""

            private(set) var hasProtocolCompilationDate:Bool = false
            private(set) var protocolCompilationDate:String = ""

            private(set) var hasProtocolSourceHash:Bool = false
            private(set) var protocolSourceHash:String = ""

            private(set) var interface:Array<Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface>  = Array<Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface>()
            private(set) var hasPort:Bool = false
            private(set) var port:Int32 = Int32(0)

            private(set) var hasTlsPort:Bool = false
            private(set) var tlsPort:Int32 = Int32(0)

            required internal init() {
                 super.init()
            }
            override internal func isInitialized() -> Bool {
             return true
            }
            override internal func writeToCodedOutputStream(output:CodedOutputStream) throws {
              if hasVendor {
                try output.writeString(5, value:vendor)
              }
              if hasModel {
                try output.writeString(6, value:model)
              }
              if hasSerialNumber {
                try output.writeData(7, value:serialNumber)
              }
              if hasVersion {
                try output.writeString(8, value:version)
              }
              for oneElementinterface in interface {
                  try output.writeMessage(9, value:oneElementinterface)
              }
              if hasPort {
                try output.writeInt32(10, value:port)
              }
              if hasTlsPort {
                try output.writeInt32(11, value:tlsPort)
              }
              if hasCompilationDate {
                try output.writeString(12, value:compilationDate)
              }
              if hasSourceHash {
                try output.writeString(13, value:sourceHash)
              }
              if hasWorldWideName {
                try output.writeData(14, value:worldWideName)
              }
              if hasProtocolVersion {
                try output.writeString(15, value:protocolVersion)
              }
              if hasProtocolCompilationDate {
                try output.writeString(16, value:protocolCompilationDate)
              }
              if hasProtocolSourceHash {
                try output.writeString(17, value:protocolSourceHash)
              }
              try unknownFields.writeToCodedOutputStream(output)
            }
            override internal func serializedSize() -> Int32 {
              var serialize_size:Int32 = memoizedSerializedSize
              if serialize_size != -1 {
               return serialize_size
              }

              serialize_size = 0
              if hasVendor {
                serialize_size += vendor.computeStringSize(5)
              }
              if hasModel {
                serialize_size += model.computeStringSize(6)
              }
              if hasSerialNumber {
                serialize_size += serialNumber.computeDataSize(7)
              }
              if hasVersion {
                serialize_size += version.computeStringSize(8)
              }
              for oneElementinterface in interface {
                  serialize_size += oneElementinterface.computeMessageSize(9)
              }
              if hasPort {
                serialize_size += port.computeInt32Size(10)
              }
              if hasTlsPort {
                serialize_size += tlsPort.computeInt32Size(11)
              }
              if hasCompilationDate {
                serialize_size += compilationDate.computeStringSize(12)
              }
              if hasSourceHash {
                serialize_size += sourceHash.computeStringSize(13)
              }
              if hasWorldWideName {
                serialize_size += worldWideName.computeDataSize(14)
              }
              if hasProtocolVersion {
                serialize_size += protocolVersion.computeStringSize(15)
              }
              if hasProtocolCompilationDate {
                serialize_size += protocolCompilationDate.computeStringSize(16)
              }
              if hasProtocolSourceHash {
                serialize_size += protocolSourceHash.computeStringSize(17)
              }
              serialize_size += unknownFields.serializedSize()
              memoizedSerializedSize = serialize_size
              return serialize_size
            }
            internal class func parseFromData(data:NSData) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder().mergeFromData(data, extensionRegistry:Com.Seagate.Kinetic.Proto.KineticRoot.sharedInstance.extensionRegistry).build()
            }
            internal class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
            }
            internal class func parseFromInputStream(input:NSInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder().mergeFromInputStream(input).build()
            }
            internal class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
            }
            internal class func parseFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder().mergeFromCodedInputStream(input).build()
            }
            internal class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
            }
            internal class func getBuilder() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder {
              return Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.classBuilder() as! Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder
            }
            internal func getBuilder() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder {
              return classBuilder() as! Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder
            }
            internal override class func classBuilder() -> MessageBuilder {
              return Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder()
            }
            internal override func classBuilder() -> MessageBuilder {
              return Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder()
            }
            internal func toBuilder() throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.builderWithPrototype(self)
            }
            internal class func builderWithPrototype(prototype:Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder().mergeFrom(prototype)
            }
            override internal func writeDescriptionTo(inout output:String, indent:String) throws {
              if hasVendor {
                output += "\(indent) vendor: \(vendor) \n"
              }
              if hasModel {
                output += "\(indent) model: \(model) \n"
              }
              if hasSerialNumber {
                output += "\(indent) serialNumber: \(serialNumber) \n"
              }
              if hasVersion {
                output += "\(indent) version: \(version) \n"
              }
              var interfaceElementIndex:Int = 0
              for oneElementinterface in interface {
                  output += "\(indent) interface[\(interfaceElementIndex)] {\n"
                  try oneElementinterface.writeDescriptionTo(&output, indent:"\(indent)  ")
                  output += "\(indent)}\n"
                  interfaceElementIndex++
              }
              if hasPort {
                output += "\(indent) port: \(port) \n"
              }
              if hasTlsPort {
                output += "\(indent) tlsPort: \(tlsPort) \n"
              }
              if hasCompilationDate {
                output += "\(indent) compilationDate: \(compilationDate) \n"
              }
              if hasSourceHash {
                output += "\(indent) sourceHash: \(sourceHash) \n"
              }
              if hasWorldWideName {
                output += "\(indent) worldWideName: \(worldWideName) \n"
              }
              if hasProtocolVersion {
                output += "\(indent) protocolVersion: \(protocolVersion) \n"
              }
              if hasProtocolCompilationDate {
                output += "\(indent) protocolCompilationDate: \(protocolCompilationDate) \n"
              }
              if hasProtocolSourceHash {
                output += "\(indent) protocolSourceHash: \(protocolSourceHash) \n"
              }
              unknownFields.writeDescriptionTo(&output, indent:indent)
            }
            override internal var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasVendor {
                       hashCode = (hashCode &* 31) &+ vendor.hashValue
                    }
                    if hasModel {
                       hashCode = (hashCode &* 31) &+ model.hashValue
                    }
                    if hasSerialNumber {
                       hashCode = (hashCode &* 31) &+ serialNumber.hashValue
                    }
                    if hasVersion {
                       hashCode = (hashCode &* 31) &+ version.hashValue
                    }
                    for oneElementinterface in interface {
                        hashCode = (hashCode &* 31) &+ oneElementinterface.hashValue
                    }
                    if hasPort {
                       hashCode = (hashCode &* 31) &+ port.hashValue
                    }
                    if hasTlsPort {
                       hashCode = (hashCode &* 31) &+ tlsPort.hashValue
                    }
                    if hasCompilationDate {
                       hashCode = (hashCode &* 31) &+ compilationDate.hashValue
                    }
                    if hasSourceHash {
                       hashCode = (hashCode &* 31) &+ sourceHash.hashValue
                    }
                    if hasWorldWideName {
                       hashCode = (hashCode &* 31) &+ worldWideName.hashValue
                    }
                    if hasProtocolVersion {
                       hashCode = (hashCode &* 31) &+ protocolVersion.hashValue
                    }
                    if hasProtocolCompilationDate {
                       hashCode = (hashCode &* 31) &+ protocolCompilationDate.hashValue
                    }
                    if hasProtocolSourceHash {
                       hashCode = (hashCode &* 31) &+ protocolSourceHash.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override internal class func className() -> String {
                return "Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration"
            }
            override internal func className() -> String {
                return "Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration"
            }
            override internal func classMetaType() -> GeneratedMessage.Type {
                return Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.self
            }
            //Meta information declaration end

            final internal class Builder : GeneratedMessageBuilder {
              private var builderResult:Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration = Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration()
              internal func getMessage() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration {
                  return builderResult
              }

              required override internal init () {
                 super.init()
              }
              var hasVendor:Bool {
                   get {
                        return builderResult.hasVendor
                   }
              }
              var vendor:String {
                   get {
                        return builderResult.vendor
                   }
                   set (value) {
                       builderResult.hasVendor = true
                       builderResult.vendor = value
                   }
              }
              func setVendor(value:String) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder {
                self.vendor = value
                return self
              }
              internal func clearVendor() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder{
                   builderResult.hasVendor = false
                   builderResult.vendor = ""
                   return self
              }
              var hasModel:Bool {
                   get {
                        return builderResult.hasModel
                   }
              }
              var model:String {
                   get {
                        return builderResult.model
                   }
                   set (value) {
                       builderResult.hasModel = true
                       builderResult.model = value
                   }
              }
              func setModel(value:String) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder {
                self.model = value
                return self
              }
              internal func clearModel() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder{
                   builderResult.hasModel = false
                   builderResult.model = ""
                   return self
              }
              var hasSerialNumber:Bool {
                   get {
                        return builderResult.hasSerialNumber
                   }
              }
              var serialNumber:NSData {
                   get {
                        return builderResult.serialNumber
                   }
                   set (value) {
                       builderResult.hasSerialNumber = true
                       builderResult.serialNumber = value
                   }
              }
              func setSerialNumber(value:NSData) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder {
                self.serialNumber = value
                return self
              }
              internal func clearSerialNumber() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder{
                   builderResult.hasSerialNumber = false
                   builderResult.serialNumber = NSData()
                   return self
              }
              var hasWorldWideName:Bool {
                   get {
                        return builderResult.hasWorldWideName
                   }
              }
              var worldWideName:NSData {
                   get {
                        return builderResult.worldWideName
                   }
                   set (value) {
                       builderResult.hasWorldWideName = true
                       builderResult.worldWideName = value
                   }
              }
              func setWorldWideName(value:NSData) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder {
                self.worldWideName = value
                return self
              }
              internal func clearWorldWideName() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder{
                   builderResult.hasWorldWideName = false
                   builderResult.worldWideName = NSData()
                   return self
              }
              var hasVersion:Bool {
                   get {
                        return builderResult.hasVersion
                   }
              }
              var version:String {
                   get {
                        return builderResult.version
                   }
                   set (value) {
                       builderResult.hasVersion = true
                       builderResult.version = value
                   }
              }
              func setVersion(value:String) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder {
                self.version = value
                return self
              }
              internal func clearVersion() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder{
                   builderResult.hasVersion = false
                   builderResult.version = ""
                   return self
              }
              var hasCompilationDate:Bool {
                   get {
                        return builderResult.hasCompilationDate
                   }
              }
              var compilationDate:String {
                   get {
                        return builderResult.compilationDate
                   }
                   set (value) {
                       builderResult.hasCompilationDate = true
                       builderResult.compilationDate = value
                   }
              }
              func setCompilationDate(value:String) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder {
                self.compilationDate = value
                return self
              }
              internal func clearCompilationDate() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder{
                   builderResult.hasCompilationDate = false
                   builderResult.compilationDate = ""
                   return self
              }
              var hasSourceHash:Bool {
                   get {
                        return builderResult.hasSourceHash
                   }
              }
              var sourceHash:String {
                   get {
                        return builderResult.sourceHash
                   }
                   set (value) {
                       builderResult.hasSourceHash = true
                       builderResult.sourceHash = value
                   }
              }
              func setSourceHash(value:String) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder {
                self.sourceHash = value
                return self
              }
              internal func clearSourceHash() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder{
                   builderResult.hasSourceHash = false
                   builderResult.sourceHash = ""
                   return self
              }
              var hasProtocolVersion:Bool {
                   get {
                        return builderResult.hasProtocolVersion
                   }
              }
              var protocolVersion:String {
                   get {
                        return builderResult.protocolVersion
                   }
                   set (value) {
                       builderResult.hasProtocolVersion = true
                       builderResult.protocolVersion = value
                   }
              }
              func setProtocolVersion(value:String) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder {
                self.protocolVersion = value
                return self
              }
              internal func clearProtocolVersion() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder{
                   builderResult.hasProtocolVersion = false
                   builderResult.protocolVersion = ""
                   return self
              }
              var hasProtocolCompilationDate:Bool {
                   get {
                        return builderResult.hasProtocolCompilationDate
                   }
              }
              var protocolCompilationDate:String {
                   get {
                        return builderResult.protocolCompilationDate
                   }
                   set (value) {
                       builderResult.hasProtocolCompilationDate = true
                       builderResult.protocolCompilationDate = value
                   }
              }
              func setProtocolCompilationDate(value:String) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder {
                self.protocolCompilationDate = value
                return self
              }
              internal func clearProtocolCompilationDate() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder{
                   builderResult.hasProtocolCompilationDate = false
                   builderResult.protocolCompilationDate = ""
                   return self
              }
              var hasProtocolSourceHash:Bool {
                   get {
                        return builderResult.hasProtocolSourceHash
                   }
              }
              var protocolSourceHash:String {
                   get {
                        return builderResult.protocolSourceHash
                   }
                   set (value) {
                       builderResult.hasProtocolSourceHash = true
                       builderResult.protocolSourceHash = value
                   }
              }
              func setProtocolSourceHash(value:String) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder {
                self.protocolSourceHash = value
                return self
              }
              internal func clearProtocolSourceHash() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder{
                   builderResult.hasProtocolSourceHash = false
                   builderResult.protocolSourceHash = ""
                   return self
              }
              var interface:Array<Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface> {
                   get {
                       return builderResult.interface
                   }
                   set (value) {
                       builderResult.interface = value
                   }
              }
              func setInterface(value:Array<Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface>) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder {
                self.interface = value
                return self
              }
              internal func clearInterface() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder {
                builderResult.interface.removeAll(keepCapacity: false)
                return self
              }
              var hasPort:Bool {
                   get {
                        return builderResult.hasPort
                   }
              }
              var port:Int32 {
                   get {
                        return builderResult.port
                   }
                   set (value) {
                       builderResult.hasPort = true
                       builderResult.port = value
                   }
              }
              func setPort(value:Int32) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder {
                self.port = value
                return self
              }
              internal func clearPort() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder{
                   builderResult.hasPort = false
                   builderResult.port = Int32(0)
                   return self
              }
              var hasTlsPort:Bool {
                   get {
                        return builderResult.hasTlsPort
                   }
              }
              var tlsPort:Int32 {
                   get {
                        return builderResult.tlsPort
                   }
                   set (value) {
                       builderResult.hasTlsPort = true
                       builderResult.tlsPort = value
                   }
              }
              func setTlsPort(value:Int32) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder {
                self.tlsPort = value
                return self
              }
              internal func clearTlsPort() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder{
                   builderResult.hasTlsPort = false
                   builderResult.tlsPort = Int32(0)
                   return self
              }
              override internal var internalGetResult:GeneratedMessage {
                   get {
                      return builderResult
                   }
              }
              internal override func clear() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder {
                builderResult = Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration()
                return self
              }
              internal override func clone() throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder {
                return try Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.builderWithPrototype(builderResult)
              }
              internal override func build() throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration {
                   try checkInitialized()
                   return buildPartial()
              }
              internal func buildPartial() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration {
                let returnMe:Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration = builderResult
                return returnMe
              }
              internal func mergeFrom(other:Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder {
                if other == Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration() {
                 return self
                }
                if other.hasVendor {
                     vendor = other.vendor
                }
                if other.hasModel {
                     model = other.model
                }
                if other.hasSerialNumber {
                     serialNumber = other.serialNumber
                }
                if other.hasWorldWideName {
                     worldWideName = other.worldWideName
                }
                if other.hasVersion {
                     version = other.version
                }
                if other.hasCompilationDate {
                     compilationDate = other.compilationDate
                }
                if other.hasSourceHash {
                     sourceHash = other.sourceHash
                }
                if other.hasProtocolVersion {
                     protocolVersion = other.protocolVersion
                }
                if other.hasProtocolCompilationDate {
                     protocolCompilationDate = other.protocolCompilationDate
                }
                if other.hasProtocolSourceHash {
                     protocolSourceHash = other.protocolSourceHash
                }
                if !other.interface.isEmpty  {
                   builderResult.interface += other.interface
                }
                if other.hasPort {
                     port = other.port
                }
                if other.hasTlsPort {
                     tlsPort = other.tlsPort
                }
                try mergeUnknownFields(other.unknownFields)
                return self
              }
              internal override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder {
                   return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
              }
              internal override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
                while (true) {
                  let tag = try input.readTag()
                  switch tag {
                  case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                  case 42 :
                    vendor = try input.readString()

                  case 50 :
                    model = try input.readString()

                  case 58 :
                    serialNumber = try input.readData()

                  case 66 :
                    version = try input.readString()

                  case 74 :
                    let subBuilder = Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Interface.Builder()
                    try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
                    interface += [subBuilder.buildPartial()]

                  case 80 :
                    port = try input.readInt32()

                  case 88 :
                    tlsPort = try input.readInt32()

                  case 98 :
                    compilationDate = try input.readString()

                  case 106 :
                    sourceHash = try input.readString()

                  case 114 :
                    worldWideName = try input.readData()

                  case 122 :
                    protocolVersion = try input.readString()

                  case 130 :
                    protocolCompilationDate = try input.readString()

                  case 138 :
                    protocolSourceHash = try input.readString()

                  default:
                    if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag))) {
                       unknownFields = try unknownFieldsBuilder.build()
                       return self
                    }
                  }
                }
              }
            }

          }

        //Nested type declaration end



        //Nested type declaration start

          final internal class Statistics : GeneratedMessage, GeneratedMessageProtocol {
            private(set) var messageType:Command.MessageType = Command.MessageType.InvalidMessageType
            private(set) var hasMessageType:Bool = false
            private(set) var hasCount:Bool = false
            private(set) var count:UInt64 = UInt64(0)

            private(set) var hasBytes:Bool = false
            private(set) var bytes:UInt64 = UInt64(0)

            required internal init() {
                 super.init()
            }
            override internal func isInitialized() -> Bool {
             return true
            }
            override internal func writeToCodedOutputStream(output:CodedOutputStream) throws {
              if hasMessageType {
                try output.writeEnum(1, value:messageType.rawValue)
              }
              if hasCount {
                try output.writeUInt64(4, value:count)
              }
              if hasBytes {
                try output.writeUInt64(5, value:bytes)
              }
              try unknownFields.writeToCodedOutputStream(output)
            }
            override internal func serializedSize() -> Int32 {
              var serialize_size:Int32 = memoizedSerializedSize
              if serialize_size != -1 {
               return serialize_size
              }

              serialize_size = 0
              if (hasMessageType) {
                serialize_size += messageType.rawValue.computeEnumSize(1)
              }
              if hasCount {
                serialize_size += count.computeUInt64Size(4)
              }
              if hasBytes {
                serialize_size += bytes.computeUInt64Size(5)
              }
              serialize_size += unknownFields.serializedSize()
              memoizedSerializedSize = serialize_size
              return serialize_size
            }
            internal class func parseFromData(data:NSData) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics.Builder().mergeFromData(data, extensionRegistry:Com.Seagate.Kinetic.Proto.KineticRoot.sharedInstance.extensionRegistry).build()
            }
            internal class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
            }
            internal class func parseFromInputStream(input:NSInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics.Builder().mergeFromInputStream(input).build()
            }
            internal class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
            }
            internal class func parseFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics.Builder().mergeFromCodedInputStream(input).build()
            }
            internal class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
            }
            internal class func getBuilder() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics.Builder {
              return Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics.classBuilder() as! Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics.Builder
            }
            internal func getBuilder() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics.Builder {
              return classBuilder() as! Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics.Builder
            }
            internal override class func classBuilder() -> MessageBuilder {
              return Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics.Builder()
            }
            internal override func classBuilder() -> MessageBuilder {
              return Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics.Builder()
            }
            internal func toBuilder() throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics.Builder {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics.builderWithPrototype(self)
            }
            internal class func builderWithPrototype(prototype:Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics.Builder {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics.Builder().mergeFrom(prototype)
            }
            override internal func writeDescriptionTo(inout output:String, indent:String) throws {
              if (hasMessageType) {
                output += "\(indent) messageType: \(messageType.rawValue)\n"
              }
              if hasCount {
                output += "\(indent) count: \(count) \n"
              }
              if hasBytes {
                output += "\(indent) bytes: \(bytes) \n"
              }
              unknownFields.writeDescriptionTo(&output, indent:indent)
            }
            override internal var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasMessageType {
                       hashCode = (hashCode &* 31) &+ Int(messageType.rawValue)
                    }
                    if hasCount {
                       hashCode = (hashCode &* 31) &+ count.hashValue
                    }
                    if hasBytes {
                       hashCode = (hashCode &* 31) &+ bytes.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override internal class func className() -> String {
                return "Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics"
            }
            override internal func className() -> String {
                return "Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics"
            }
            override internal func classMetaType() -> GeneratedMessage.Type {
                return Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics.self
            }
            //Meta information declaration end

            final internal class Builder : GeneratedMessageBuilder {
              private var builderResult:Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics = Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics()
              internal func getMessage() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics {
                  return builderResult
              }

              required override internal init () {
                 super.init()
              }
                var hasMessageType:Bool{
                    get {
                        return builderResult.hasMessageType
                    }
                }
                var messageType:Command.MessageType {
                    get {
                        return builderResult.messageType
                    }
                    set (value) {
                        builderResult.hasMessageType = true
                        builderResult.messageType = value
                    }
                }
                internal func setMessageType(value:Command.MessageType) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics.Builder {
                  self.messageType = value
                  return self
                }
                internal func clearMessageType() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics.Builder {
                   builderResult.hasMessageType = false
                   builderResult.messageType = .InvalidMessageType
                   return self
                }
              var hasCount:Bool {
                   get {
                        return builderResult.hasCount
                   }
              }
              var count:UInt64 {
                   get {
                        return builderResult.count
                   }
                   set (value) {
                       builderResult.hasCount = true
                       builderResult.count = value
                   }
              }
              func setCount(value:UInt64) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics.Builder {
                self.count = value
                return self
              }
              internal func clearCount() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics.Builder{
                   builderResult.hasCount = false
                   builderResult.count = UInt64(0)
                   return self
              }
              var hasBytes:Bool {
                   get {
                        return builderResult.hasBytes
                   }
              }
              var bytes:UInt64 {
                   get {
                        return builderResult.bytes
                   }
                   set (value) {
                       builderResult.hasBytes = true
                       builderResult.bytes = value
                   }
              }
              func setBytes(value:UInt64) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics.Builder {
                self.bytes = value
                return self
              }
              internal func clearBytes() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics.Builder{
                   builderResult.hasBytes = false
                   builderResult.bytes = UInt64(0)
                   return self
              }
              override internal var internalGetResult:GeneratedMessage {
                   get {
                      return builderResult
                   }
              }
              internal override func clear() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics.Builder {
                builderResult = Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics()
                return self
              }
              internal override func clone() throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics.Builder {
                return try Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics.builderWithPrototype(builderResult)
              }
              internal override func build() throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics {
                   try checkInitialized()
                   return buildPartial()
              }
              internal func buildPartial() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics {
                let returnMe:Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics = builderResult
                return returnMe
              }
              internal func mergeFrom(other:Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics.Builder {
                if other == Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics() {
                 return self
                }
                if other.hasMessageType {
                     messageType = other.messageType
                }
                if other.hasCount {
                     count = other.count
                }
                if other.hasBytes {
                     bytes = other.bytes
                }
                try mergeUnknownFields(other.unknownFields)
                return self
              }
              internal override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics.Builder {
                   return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
              }
              internal override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
                while (true) {
                  let tag = try input.readTag()
                  switch tag {
                  case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                  case 8 :
                    let valueIntmessageType = try input.readEnum()
                    if let enumsmessageType = Command.MessageType(rawValue:valueIntmessageType){
                         messageType = enumsmessageType
                    } else {
                         try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntmessageType))
                    }

                  case 32 :
                    count = try input.readUInt64()

                  case 40 :
                    bytes = try input.readUInt64()

                  default:
                    if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag))) {
                       unknownFields = try unknownFieldsBuilder.build()
                       return self
                    }
                  }
                }
              }
            }

          }

        //Nested type declaration end



        //Nested type declaration start

          final internal class Limits : GeneratedMessage, GeneratedMessageProtocol {
            private(set) var hasMaxKeySize:Bool = false
            private(set) var maxKeySize:UInt32 = UInt32(0)

            private(set) var hasMaxValueSize:Bool = false
            private(set) var maxValueSize:UInt32 = UInt32(0)

            private(set) var hasMaxVersionSize:Bool = false
            private(set) var maxVersionSize:UInt32 = UInt32(0)

            private(set) var hasMaxTagSize:Bool = false
            private(set) var maxTagSize:UInt32 = UInt32(0)

            private(set) var hasMaxConnections:Bool = false
            private(set) var maxConnections:UInt32 = UInt32(0)

            private(set) var hasMaxOutstandingReadRequests:Bool = false
            private(set) var maxOutstandingReadRequests:UInt32 = UInt32(0)

            private(set) var hasMaxOutstandingWriteRequests:Bool = false
            private(set) var maxOutstandingWriteRequests:UInt32 = UInt32(0)

            private(set) var hasMaxMessageSize:Bool = false
            private(set) var maxMessageSize:UInt32 = UInt32(0)

            private(set) var hasMaxKeyRangeCount:Bool = false
            private(set) var maxKeyRangeCount:UInt32 = UInt32(0)

            private(set) var hasMaxIdentityCount:Bool = false
            private(set) var maxIdentityCount:UInt32 = UInt32(0)

            private(set) var hasMaxPinSize:Bool = false
            private(set) var maxPinSize:UInt32 = UInt32(0)

            private(set) var hasMaxOperationCountPerBatch:Bool = false
            private(set) var maxOperationCountPerBatch:UInt32 = UInt32(0)

            private(set) var hasMaxBatchCountPerDevice:Bool = false
            private(set) var maxBatchCountPerDevice:UInt32 = UInt32(0)

            required internal init() {
                 super.init()
            }
            override internal func isInitialized() -> Bool {
             return true
            }
            override internal func writeToCodedOutputStream(output:CodedOutputStream) throws {
              if hasMaxKeySize {
                try output.writeUInt32(1, value:maxKeySize)
              }
              if hasMaxValueSize {
                try output.writeUInt32(2, value:maxValueSize)
              }
              if hasMaxVersionSize {
                try output.writeUInt32(3, value:maxVersionSize)
              }
              if hasMaxTagSize {
                try output.writeUInt32(4, value:maxTagSize)
              }
              if hasMaxConnections {
                try output.writeUInt32(5, value:maxConnections)
              }
              if hasMaxOutstandingReadRequests {
                try output.writeUInt32(6, value:maxOutstandingReadRequests)
              }
              if hasMaxOutstandingWriteRequests {
                try output.writeUInt32(7, value:maxOutstandingWriteRequests)
              }
              if hasMaxMessageSize {
                try output.writeUInt32(8, value:maxMessageSize)
              }
              if hasMaxKeyRangeCount {
                try output.writeUInt32(9, value:maxKeyRangeCount)
              }
              if hasMaxIdentityCount {
                try output.writeUInt32(10, value:maxIdentityCount)
              }
              if hasMaxPinSize {
                try output.writeUInt32(11, value:maxPinSize)
              }
              if hasMaxOperationCountPerBatch {
                try output.writeUInt32(12, value:maxOperationCountPerBatch)
              }
              if hasMaxBatchCountPerDevice {
                try output.writeUInt32(13, value:maxBatchCountPerDevice)
              }
              try unknownFields.writeToCodedOutputStream(output)
            }
            override internal func serializedSize() -> Int32 {
              var serialize_size:Int32 = memoizedSerializedSize
              if serialize_size != -1 {
               return serialize_size
              }

              serialize_size = 0
              if hasMaxKeySize {
                serialize_size += maxKeySize.computeUInt32Size(1)
              }
              if hasMaxValueSize {
                serialize_size += maxValueSize.computeUInt32Size(2)
              }
              if hasMaxVersionSize {
                serialize_size += maxVersionSize.computeUInt32Size(3)
              }
              if hasMaxTagSize {
                serialize_size += maxTagSize.computeUInt32Size(4)
              }
              if hasMaxConnections {
                serialize_size += maxConnections.computeUInt32Size(5)
              }
              if hasMaxOutstandingReadRequests {
                serialize_size += maxOutstandingReadRequests.computeUInt32Size(6)
              }
              if hasMaxOutstandingWriteRequests {
                serialize_size += maxOutstandingWriteRequests.computeUInt32Size(7)
              }
              if hasMaxMessageSize {
                serialize_size += maxMessageSize.computeUInt32Size(8)
              }
              if hasMaxKeyRangeCount {
                serialize_size += maxKeyRangeCount.computeUInt32Size(9)
              }
              if hasMaxIdentityCount {
                serialize_size += maxIdentityCount.computeUInt32Size(10)
              }
              if hasMaxPinSize {
                serialize_size += maxPinSize.computeUInt32Size(11)
              }
              if hasMaxOperationCountPerBatch {
                serialize_size += maxOperationCountPerBatch.computeUInt32Size(12)
              }
              if hasMaxBatchCountPerDevice {
                serialize_size += maxBatchCountPerDevice.computeUInt32Size(13)
              }
              serialize_size += unknownFields.serializedSize()
              memoizedSerializedSize = serialize_size
              return serialize_size
            }
            internal class func parseFromData(data:NSData) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Limits {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder().mergeFromData(data, extensionRegistry:Com.Seagate.Kinetic.Proto.KineticRoot.sharedInstance.extensionRegistry).build()
            }
            internal class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Limits {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
            }
            internal class func parseFromInputStream(input:NSInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Limits {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder().mergeFromInputStream(input).build()
            }
            internal class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Limits {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
            }
            internal class func parseFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Limits {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder().mergeFromCodedInputStream(input).build()
            }
            internal class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Limits {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
            }
            internal class func getBuilder() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder {
              return Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.classBuilder() as! Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder
            }
            internal func getBuilder() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder {
              return classBuilder() as! Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder
            }
            internal override class func classBuilder() -> MessageBuilder {
              return Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder()
            }
            internal override func classBuilder() -> MessageBuilder {
              return Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder()
            }
            internal func toBuilder() throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.builderWithPrototype(self)
            }
            internal class func builderWithPrototype(prototype:Com.Seagate.Kinetic.Proto.Command.GetLog.Limits) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder().mergeFrom(prototype)
            }
            override internal func writeDescriptionTo(inout output:String, indent:String) throws {
              if hasMaxKeySize {
                output += "\(indent) maxKeySize: \(maxKeySize) \n"
              }
              if hasMaxValueSize {
                output += "\(indent) maxValueSize: \(maxValueSize) \n"
              }
              if hasMaxVersionSize {
                output += "\(indent) maxVersionSize: \(maxVersionSize) \n"
              }
              if hasMaxTagSize {
                output += "\(indent) maxTagSize: \(maxTagSize) \n"
              }
              if hasMaxConnections {
                output += "\(indent) maxConnections: \(maxConnections) \n"
              }
              if hasMaxOutstandingReadRequests {
                output += "\(indent) maxOutstandingReadRequests: \(maxOutstandingReadRequests) \n"
              }
              if hasMaxOutstandingWriteRequests {
                output += "\(indent) maxOutstandingWriteRequests: \(maxOutstandingWriteRequests) \n"
              }
              if hasMaxMessageSize {
                output += "\(indent) maxMessageSize: \(maxMessageSize) \n"
              }
              if hasMaxKeyRangeCount {
                output += "\(indent) maxKeyRangeCount: \(maxKeyRangeCount) \n"
              }
              if hasMaxIdentityCount {
                output += "\(indent) maxIdentityCount: \(maxIdentityCount) \n"
              }
              if hasMaxPinSize {
                output += "\(indent) maxPinSize: \(maxPinSize) \n"
              }
              if hasMaxOperationCountPerBatch {
                output += "\(indent) maxOperationCountPerBatch: \(maxOperationCountPerBatch) \n"
              }
              if hasMaxBatchCountPerDevice {
                output += "\(indent) maxBatchCountPerDevice: \(maxBatchCountPerDevice) \n"
              }
              unknownFields.writeDescriptionTo(&output, indent:indent)
            }
            override internal var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasMaxKeySize {
                       hashCode = (hashCode &* 31) &+ maxKeySize.hashValue
                    }
                    if hasMaxValueSize {
                       hashCode = (hashCode &* 31) &+ maxValueSize.hashValue
                    }
                    if hasMaxVersionSize {
                       hashCode = (hashCode &* 31) &+ maxVersionSize.hashValue
                    }
                    if hasMaxTagSize {
                       hashCode = (hashCode &* 31) &+ maxTagSize.hashValue
                    }
                    if hasMaxConnections {
                       hashCode = (hashCode &* 31) &+ maxConnections.hashValue
                    }
                    if hasMaxOutstandingReadRequests {
                       hashCode = (hashCode &* 31) &+ maxOutstandingReadRequests.hashValue
                    }
                    if hasMaxOutstandingWriteRequests {
                       hashCode = (hashCode &* 31) &+ maxOutstandingWriteRequests.hashValue
                    }
                    if hasMaxMessageSize {
                       hashCode = (hashCode &* 31) &+ maxMessageSize.hashValue
                    }
                    if hasMaxKeyRangeCount {
                       hashCode = (hashCode &* 31) &+ maxKeyRangeCount.hashValue
                    }
                    if hasMaxIdentityCount {
                       hashCode = (hashCode &* 31) &+ maxIdentityCount.hashValue
                    }
                    if hasMaxPinSize {
                       hashCode = (hashCode &* 31) &+ maxPinSize.hashValue
                    }
                    if hasMaxOperationCountPerBatch {
                       hashCode = (hashCode &* 31) &+ maxOperationCountPerBatch.hashValue
                    }
                    if hasMaxBatchCountPerDevice {
                       hashCode = (hashCode &* 31) &+ maxBatchCountPerDevice.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override internal class func className() -> String {
                return "Com.Seagate.Kinetic.Proto.Command.GetLog.Limits"
            }
            override internal func className() -> String {
                return "Com.Seagate.Kinetic.Proto.Command.GetLog.Limits"
            }
            override internal func classMetaType() -> GeneratedMessage.Type {
                return Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.self
            }
            //Meta information declaration end

            final internal class Builder : GeneratedMessageBuilder {
              private var builderResult:Com.Seagate.Kinetic.Proto.Command.GetLog.Limits = Com.Seagate.Kinetic.Proto.Command.GetLog.Limits()
              internal func getMessage() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Limits {
                  return builderResult
              }

              required override internal init () {
                 super.init()
              }
              var hasMaxKeySize:Bool {
                   get {
                        return builderResult.hasMaxKeySize
                   }
              }
              var maxKeySize:UInt32 {
                   get {
                        return builderResult.maxKeySize
                   }
                   set (value) {
                       builderResult.hasMaxKeySize = true
                       builderResult.maxKeySize = value
                   }
              }
              func setMaxKeySize(value:UInt32) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder {
                self.maxKeySize = value
                return self
              }
              internal func clearMaxKeySize() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder{
                   builderResult.hasMaxKeySize = false
                   builderResult.maxKeySize = UInt32(0)
                   return self
              }
              var hasMaxValueSize:Bool {
                   get {
                        return builderResult.hasMaxValueSize
                   }
              }
              var maxValueSize:UInt32 {
                   get {
                        return builderResult.maxValueSize
                   }
                   set (value) {
                       builderResult.hasMaxValueSize = true
                       builderResult.maxValueSize = value
                   }
              }
              func setMaxValueSize(value:UInt32) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder {
                self.maxValueSize = value
                return self
              }
              internal func clearMaxValueSize() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder{
                   builderResult.hasMaxValueSize = false
                   builderResult.maxValueSize = UInt32(0)
                   return self
              }
              var hasMaxVersionSize:Bool {
                   get {
                        return builderResult.hasMaxVersionSize
                   }
              }
              var maxVersionSize:UInt32 {
                   get {
                        return builderResult.maxVersionSize
                   }
                   set (value) {
                       builderResult.hasMaxVersionSize = true
                       builderResult.maxVersionSize = value
                   }
              }
              func setMaxVersionSize(value:UInt32) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder {
                self.maxVersionSize = value
                return self
              }
              internal func clearMaxVersionSize() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder{
                   builderResult.hasMaxVersionSize = false
                   builderResult.maxVersionSize = UInt32(0)
                   return self
              }
              var hasMaxTagSize:Bool {
                   get {
                        return builderResult.hasMaxTagSize
                   }
              }
              var maxTagSize:UInt32 {
                   get {
                        return builderResult.maxTagSize
                   }
                   set (value) {
                       builderResult.hasMaxTagSize = true
                       builderResult.maxTagSize = value
                   }
              }
              func setMaxTagSize(value:UInt32) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder {
                self.maxTagSize = value
                return self
              }
              internal func clearMaxTagSize() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder{
                   builderResult.hasMaxTagSize = false
                   builderResult.maxTagSize = UInt32(0)
                   return self
              }
              var hasMaxConnections:Bool {
                   get {
                        return builderResult.hasMaxConnections
                   }
              }
              var maxConnections:UInt32 {
                   get {
                        return builderResult.maxConnections
                   }
                   set (value) {
                       builderResult.hasMaxConnections = true
                       builderResult.maxConnections = value
                   }
              }
              func setMaxConnections(value:UInt32) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder {
                self.maxConnections = value
                return self
              }
              internal func clearMaxConnections() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder{
                   builderResult.hasMaxConnections = false
                   builderResult.maxConnections = UInt32(0)
                   return self
              }
              var hasMaxOutstandingReadRequests:Bool {
                   get {
                        return builderResult.hasMaxOutstandingReadRequests
                   }
              }
              var maxOutstandingReadRequests:UInt32 {
                   get {
                        return builderResult.maxOutstandingReadRequests
                   }
                   set (value) {
                       builderResult.hasMaxOutstandingReadRequests = true
                       builderResult.maxOutstandingReadRequests = value
                   }
              }
              func setMaxOutstandingReadRequests(value:UInt32) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder {
                self.maxOutstandingReadRequests = value
                return self
              }
              internal func clearMaxOutstandingReadRequests() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder{
                   builderResult.hasMaxOutstandingReadRequests = false
                   builderResult.maxOutstandingReadRequests = UInt32(0)
                   return self
              }
              var hasMaxOutstandingWriteRequests:Bool {
                   get {
                        return builderResult.hasMaxOutstandingWriteRequests
                   }
              }
              var maxOutstandingWriteRequests:UInt32 {
                   get {
                        return builderResult.maxOutstandingWriteRequests
                   }
                   set (value) {
                       builderResult.hasMaxOutstandingWriteRequests = true
                       builderResult.maxOutstandingWriteRequests = value
                   }
              }
              func setMaxOutstandingWriteRequests(value:UInt32) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder {
                self.maxOutstandingWriteRequests = value
                return self
              }
              internal func clearMaxOutstandingWriteRequests() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder{
                   builderResult.hasMaxOutstandingWriteRequests = false
                   builderResult.maxOutstandingWriteRequests = UInt32(0)
                   return self
              }
              var hasMaxMessageSize:Bool {
                   get {
                        return builderResult.hasMaxMessageSize
                   }
              }
              var maxMessageSize:UInt32 {
                   get {
                        return builderResult.maxMessageSize
                   }
                   set (value) {
                       builderResult.hasMaxMessageSize = true
                       builderResult.maxMessageSize = value
                   }
              }
              func setMaxMessageSize(value:UInt32) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder {
                self.maxMessageSize = value
                return self
              }
              internal func clearMaxMessageSize() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder{
                   builderResult.hasMaxMessageSize = false
                   builderResult.maxMessageSize = UInt32(0)
                   return self
              }
              var hasMaxKeyRangeCount:Bool {
                   get {
                        return builderResult.hasMaxKeyRangeCount
                   }
              }
              var maxKeyRangeCount:UInt32 {
                   get {
                        return builderResult.maxKeyRangeCount
                   }
                   set (value) {
                       builderResult.hasMaxKeyRangeCount = true
                       builderResult.maxKeyRangeCount = value
                   }
              }
              func setMaxKeyRangeCount(value:UInt32) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder {
                self.maxKeyRangeCount = value
                return self
              }
              internal func clearMaxKeyRangeCount() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder{
                   builderResult.hasMaxKeyRangeCount = false
                   builderResult.maxKeyRangeCount = UInt32(0)
                   return self
              }
              var hasMaxIdentityCount:Bool {
                   get {
                        return builderResult.hasMaxIdentityCount
                   }
              }
              var maxIdentityCount:UInt32 {
                   get {
                        return builderResult.maxIdentityCount
                   }
                   set (value) {
                       builderResult.hasMaxIdentityCount = true
                       builderResult.maxIdentityCount = value
                   }
              }
              func setMaxIdentityCount(value:UInt32) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder {
                self.maxIdentityCount = value
                return self
              }
              internal func clearMaxIdentityCount() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder{
                   builderResult.hasMaxIdentityCount = false
                   builderResult.maxIdentityCount = UInt32(0)
                   return self
              }
              var hasMaxPinSize:Bool {
                   get {
                        return builderResult.hasMaxPinSize
                   }
              }
              var maxPinSize:UInt32 {
                   get {
                        return builderResult.maxPinSize
                   }
                   set (value) {
                       builderResult.hasMaxPinSize = true
                       builderResult.maxPinSize = value
                   }
              }
              func setMaxPinSize(value:UInt32) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder {
                self.maxPinSize = value
                return self
              }
              internal func clearMaxPinSize() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder{
                   builderResult.hasMaxPinSize = false
                   builderResult.maxPinSize = UInt32(0)
                   return self
              }
              var hasMaxOperationCountPerBatch:Bool {
                   get {
                        return builderResult.hasMaxOperationCountPerBatch
                   }
              }
              var maxOperationCountPerBatch:UInt32 {
                   get {
                        return builderResult.maxOperationCountPerBatch
                   }
                   set (value) {
                       builderResult.hasMaxOperationCountPerBatch = true
                       builderResult.maxOperationCountPerBatch = value
                   }
              }
              func setMaxOperationCountPerBatch(value:UInt32) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder {
                self.maxOperationCountPerBatch = value
                return self
              }
              internal func clearMaxOperationCountPerBatch() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder{
                   builderResult.hasMaxOperationCountPerBatch = false
                   builderResult.maxOperationCountPerBatch = UInt32(0)
                   return self
              }
              var hasMaxBatchCountPerDevice:Bool {
                   get {
                        return builderResult.hasMaxBatchCountPerDevice
                   }
              }
              var maxBatchCountPerDevice:UInt32 {
                   get {
                        return builderResult.maxBatchCountPerDevice
                   }
                   set (value) {
                       builderResult.hasMaxBatchCountPerDevice = true
                       builderResult.maxBatchCountPerDevice = value
                   }
              }
              func setMaxBatchCountPerDevice(value:UInt32) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder {
                self.maxBatchCountPerDevice = value
                return self
              }
              internal func clearMaxBatchCountPerDevice() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder{
                   builderResult.hasMaxBatchCountPerDevice = false
                   builderResult.maxBatchCountPerDevice = UInt32(0)
                   return self
              }
              override internal var internalGetResult:GeneratedMessage {
                   get {
                      return builderResult
                   }
              }
              internal override func clear() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder {
                builderResult = Com.Seagate.Kinetic.Proto.Command.GetLog.Limits()
                return self
              }
              internal override func clone() throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder {
                return try Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.builderWithPrototype(builderResult)
              }
              internal override func build() throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Limits {
                   try checkInitialized()
                   return buildPartial()
              }
              internal func buildPartial() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Limits {
                let returnMe:Com.Seagate.Kinetic.Proto.Command.GetLog.Limits = builderResult
                return returnMe
              }
              internal func mergeFrom(other:Com.Seagate.Kinetic.Proto.Command.GetLog.Limits) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder {
                if other == Com.Seagate.Kinetic.Proto.Command.GetLog.Limits() {
                 return self
                }
                if other.hasMaxKeySize {
                     maxKeySize = other.maxKeySize
                }
                if other.hasMaxValueSize {
                     maxValueSize = other.maxValueSize
                }
                if other.hasMaxVersionSize {
                     maxVersionSize = other.maxVersionSize
                }
                if other.hasMaxTagSize {
                     maxTagSize = other.maxTagSize
                }
                if other.hasMaxConnections {
                     maxConnections = other.maxConnections
                }
                if other.hasMaxOutstandingReadRequests {
                     maxOutstandingReadRequests = other.maxOutstandingReadRequests
                }
                if other.hasMaxOutstandingWriteRequests {
                     maxOutstandingWriteRequests = other.maxOutstandingWriteRequests
                }
                if other.hasMaxMessageSize {
                     maxMessageSize = other.maxMessageSize
                }
                if other.hasMaxKeyRangeCount {
                     maxKeyRangeCount = other.maxKeyRangeCount
                }
                if other.hasMaxIdentityCount {
                     maxIdentityCount = other.maxIdentityCount
                }
                if other.hasMaxPinSize {
                     maxPinSize = other.maxPinSize
                }
                if other.hasMaxOperationCountPerBatch {
                     maxOperationCountPerBatch = other.maxOperationCountPerBatch
                }
                if other.hasMaxBatchCountPerDevice {
                     maxBatchCountPerDevice = other.maxBatchCountPerDevice
                }
                try mergeUnknownFields(other.unknownFields)
                return self
              }
              internal override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder {
                   return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
              }
              internal override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
                while (true) {
                  let tag = try input.readTag()
                  switch tag {
                  case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                  case 8 :
                    maxKeySize = try input.readUInt32()

                  case 16 :
                    maxValueSize = try input.readUInt32()

                  case 24 :
                    maxVersionSize = try input.readUInt32()

                  case 32 :
                    maxTagSize = try input.readUInt32()

                  case 40 :
                    maxConnections = try input.readUInt32()

                  case 48 :
                    maxOutstandingReadRequests = try input.readUInt32()

                  case 56 :
                    maxOutstandingWriteRequests = try input.readUInt32()

                  case 64 :
                    maxMessageSize = try input.readUInt32()

                  case 72 :
                    maxKeyRangeCount = try input.readUInt32()

                  case 80 :
                    maxIdentityCount = try input.readUInt32()

                  case 88 :
                    maxPinSize = try input.readUInt32()

                  case 96 :
                    maxOperationCountPerBatch = try input.readUInt32()

                  case 104 :
                    maxBatchCountPerDevice = try input.readUInt32()

                  default:
                    if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag))) {
                       unknownFields = try unknownFieldsBuilder.build()
                       return self
                    }
                  }
                }
              }
            }

          }

        //Nested type declaration end



        //Nested type declaration start

          final internal class Device : GeneratedMessage, GeneratedMessageProtocol {
            private(set) var hasName:Bool = false
            private(set) var name:NSData = NSData()

            required internal init() {
                 super.init()
            }
            override internal func isInitialized() -> Bool {
             return true
            }
            override internal func writeToCodedOutputStream(output:CodedOutputStream) throws {
              if hasName {
                try output.writeData(1, value:name)
              }
              try unknownFields.writeToCodedOutputStream(output)
            }
            override internal func serializedSize() -> Int32 {
              var serialize_size:Int32 = memoizedSerializedSize
              if serialize_size != -1 {
               return serialize_size
              }

              serialize_size = 0
              if hasName {
                serialize_size += name.computeDataSize(1)
              }
              serialize_size += unknownFields.serializedSize()
              memoizedSerializedSize = serialize_size
              return serialize_size
            }
            internal class func parseFromData(data:NSData) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Device {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Device.Builder().mergeFromData(data, extensionRegistry:Com.Seagate.Kinetic.Proto.KineticRoot.sharedInstance.extensionRegistry).build()
            }
            internal class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Device {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Device.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
            }
            internal class func parseFromInputStream(input:NSInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Device {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Device.Builder().mergeFromInputStream(input).build()
            }
            internal class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Device {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Device.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
            }
            internal class func parseFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Device {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Device.Builder().mergeFromCodedInputStream(input).build()
            }
            internal class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Device {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Device.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
            }
            internal class func getBuilder() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Device.Builder {
              return Com.Seagate.Kinetic.Proto.Command.GetLog.Device.classBuilder() as! Com.Seagate.Kinetic.Proto.Command.GetLog.Device.Builder
            }
            internal func getBuilder() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Device.Builder {
              return classBuilder() as! Com.Seagate.Kinetic.Proto.Command.GetLog.Device.Builder
            }
            internal override class func classBuilder() -> MessageBuilder {
              return Com.Seagate.Kinetic.Proto.Command.GetLog.Device.Builder()
            }
            internal override func classBuilder() -> MessageBuilder {
              return Com.Seagate.Kinetic.Proto.Command.GetLog.Device.Builder()
            }
            internal func toBuilder() throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Device.Builder {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Device.builderWithPrototype(self)
            }
            internal class func builderWithPrototype(prototype:Com.Seagate.Kinetic.Proto.Command.GetLog.Device) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Device.Builder {
              return try Com.Seagate.Kinetic.Proto.Command.GetLog.Device.Builder().mergeFrom(prototype)
            }
            override internal func writeDescriptionTo(inout output:String, indent:String) throws {
              if hasName {
                output += "\(indent) name: \(name) \n"
              }
              unknownFields.writeDescriptionTo(&output, indent:indent)
            }
            override internal var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasName {
                       hashCode = (hashCode &* 31) &+ name.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override internal class func className() -> String {
                return "Com.Seagate.Kinetic.Proto.Command.GetLog.Device"
            }
            override internal func className() -> String {
                return "Com.Seagate.Kinetic.Proto.Command.GetLog.Device"
            }
            override internal func classMetaType() -> GeneratedMessage.Type {
                return Com.Seagate.Kinetic.Proto.Command.GetLog.Device.self
            }
            //Meta information declaration end

            final internal class Builder : GeneratedMessageBuilder {
              private var builderResult:Com.Seagate.Kinetic.Proto.Command.GetLog.Device = Com.Seagate.Kinetic.Proto.Command.GetLog.Device()
              internal func getMessage() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Device {
                  return builderResult
              }

              required override internal init () {
                 super.init()
              }
              var hasName:Bool {
                   get {
                        return builderResult.hasName
                   }
              }
              var name:NSData {
                   get {
                        return builderResult.name
                   }
                   set (value) {
                       builderResult.hasName = true
                       builderResult.name = value
                   }
              }
              func setName(value:NSData) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Device.Builder {
                self.name = value
                return self
              }
              internal func clearName() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Device.Builder{
                   builderResult.hasName = false
                   builderResult.name = NSData()
                   return self
              }
              override internal var internalGetResult:GeneratedMessage {
                   get {
                      return builderResult
                   }
              }
              internal override func clear() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Device.Builder {
                builderResult = Com.Seagate.Kinetic.Proto.Command.GetLog.Device()
                return self
              }
              internal override func clone() throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Device.Builder {
                return try Com.Seagate.Kinetic.Proto.Command.GetLog.Device.builderWithPrototype(builderResult)
              }
              internal override func build() throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Device {
                   try checkInitialized()
                   return buildPartial()
              }
              internal func buildPartial() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Device {
                let returnMe:Com.Seagate.Kinetic.Proto.Command.GetLog.Device = builderResult
                return returnMe
              }
              internal func mergeFrom(other:Com.Seagate.Kinetic.Proto.Command.GetLog.Device) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Device.Builder {
                if other == Com.Seagate.Kinetic.Proto.Command.GetLog.Device() {
                 return self
                }
                if other.hasName {
                     name = other.name
                }
                try mergeUnknownFields(other.unknownFields)
                return self
              }
              internal override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Device.Builder {
                   return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
              }
              internal override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Device.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
                while (true) {
                  let tag = try input.readTag()
                  switch tag {
                  case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                  case 10 :
                    name = try input.readData()

                  default:
                    if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag))) {
                       unknownFields = try unknownFieldsBuilder.build()
                       return self
                    }
                  }
                }
              }
            }

          }

        //Nested type declaration end



          //Enum type declaration start 

          internal enum Types:Int32 {
            case InvalidType = -1
            case Utilizations = 0
            case Temperatures = 1
            case Capacities = 2
            case Configuration = 3
            case Statistics = 4
            case Messages = 5
            case Limits = 6
            case Device = 7

          }

          //Enum type declaration end 

        private var typesMemoizedSerializedSize:Int32 = 0
        private(set) var types:Array<Command.GetLog.Types> = Array<Command.GetLog.Types>()
        private(set) var utilizations:Array<Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization>  = Array<Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization>()
        private(set) var temperatures:Array<Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature>  = Array<Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature>()
        private(set) var hasCapacity:Bool = false
        private(set) var capacity:Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity!
        private(set) var hasConfiguration:Bool = false
        private(set) var configuration:Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration!
        private(set) var statistics:Array<Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics>  = Array<Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics>()
        private(set) var hasMessages:Bool = false
        private(set) var messages:NSData = NSData()

        private(set) var hasLimits:Bool = false
        private(set) var limits:Com.Seagate.Kinetic.Proto.Command.GetLog.Limits!
        private(set) var hasDevice:Bool = false
        private(set) var device:Com.Seagate.Kinetic.Proto.Command.GetLog.Device!
        required internal init() {
             super.init()
        }
        override internal func isInitialized() -> Bool {
         return true
        }
        override internal func writeToCodedOutputStream(output:CodedOutputStream) throws {
          for oneValueOftypes in types {
              try output.writeEnum(1, value:oneValueOftypes.rawValue)
          }
          for oneElementutilizations in utilizations {
              try output.writeMessage(2, value:oneElementutilizations)
          }
          for oneElementtemperatures in temperatures {
              try output.writeMessage(3, value:oneElementtemperatures)
          }
          if hasCapacity {
            try output.writeMessage(4, value:capacity)
          }
          if hasConfiguration {
            try output.writeMessage(5, value:configuration)
          }
          for oneElementstatistics in statistics {
              try output.writeMessage(6, value:oneElementstatistics)
          }
          if hasMessages {
            try output.writeData(7, value:messages)
          }
          if hasLimits {
            try output.writeMessage(8, value:limits)
          }
          if hasDevice {
            try output.writeMessage(9, value:device)
          }
          try unknownFields.writeToCodedOutputStream(output)
        }
        override internal func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          var dataSizetypes:Int32 = 0
          for oneValueOftypes in types {
              dataSizetypes += oneValueOftypes.rawValue.computeEnumSizeNoTag()
          }
          serialize_size += dataSizetypes
          serialize_size += (1 * Int32(types.count))
          for oneElementutilizations in utilizations {
              serialize_size += oneElementutilizations.computeMessageSize(2)
          }
          for oneElementtemperatures in temperatures {
              serialize_size += oneElementtemperatures.computeMessageSize(3)
          }
          if hasCapacity {
              if let varSizecapacity = capacity?.computeMessageSize(4) {
                  serialize_size += varSizecapacity
              }
          }
          if hasConfiguration {
              if let varSizeconfiguration = configuration?.computeMessageSize(5) {
                  serialize_size += varSizeconfiguration
              }
          }
          for oneElementstatistics in statistics {
              serialize_size += oneElementstatistics.computeMessageSize(6)
          }
          if hasMessages {
            serialize_size += messages.computeDataSize(7)
          }
          if hasLimits {
              if let varSizelimits = limits?.computeMessageSize(8) {
                  serialize_size += varSizelimits
              }
          }
          if hasDevice {
              if let varSizedevice = device?.computeMessageSize(9) {
                  serialize_size += varSizedevice
              }
          }
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        internal class func parseFromData(data:NSData) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog {
          return try Com.Seagate.Kinetic.Proto.Command.GetLog.Builder().mergeFromData(data, extensionRegistry:Com.Seagate.Kinetic.Proto.KineticRoot.sharedInstance.extensionRegistry).build()
        }
        internal class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog {
          return try Com.Seagate.Kinetic.Proto.Command.GetLog.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
        }
        internal class func parseFromInputStream(input:NSInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog {
          return try Com.Seagate.Kinetic.Proto.Command.GetLog.Builder().mergeFromInputStream(input).build()
        }
        internal class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog {
          return try Com.Seagate.Kinetic.Proto.Command.GetLog.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        internal class func parseFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog {
          return try Com.Seagate.Kinetic.Proto.Command.GetLog.Builder().mergeFromCodedInputStream(input).build()
        }
        internal class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog {
          return try Com.Seagate.Kinetic.Proto.Command.GetLog.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        internal class func getBuilder() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Builder {
          return Com.Seagate.Kinetic.Proto.Command.GetLog.classBuilder() as! Com.Seagate.Kinetic.Proto.Command.GetLog.Builder
        }
        internal func getBuilder() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Builder {
          return classBuilder() as! Com.Seagate.Kinetic.Proto.Command.GetLog.Builder
        }
        internal override class func classBuilder() -> MessageBuilder {
          return Com.Seagate.Kinetic.Proto.Command.GetLog.Builder()
        }
        internal override func classBuilder() -> MessageBuilder {
          return Com.Seagate.Kinetic.Proto.Command.GetLog.Builder()
        }
        internal func toBuilder() throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Builder {
          return try Com.Seagate.Kinetic.Proto.Command.GetLog.builderWithPrototype(self)
        }
        internal class func builderWithPrototype(prototype:Com.Seagate.Kinetic.Proto.Command.GetLog) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Builder {
          return try Com.Seagate.Kinetic.Proto.Command.GetLog.Builder().mergeFrom(prototype)
        }
        override internal func writeDescriptionTo(inout output:String, indent:String) throws {
          var typesElementIndex:Int = 0
          for oneValueOftypes in types {
              output += "\(indent) types[\(typesElementIndex)]: \(oneValueOftypes.rawValue)\n"
              typesElementIndex++
          }
          var utilizationsElementIndex:Int = 0
          for oneElementutilizations in utilizations {
              output += "\(indent) utilizations[\(utilizationsElementIndex)] {\n"
              try oneElementutilizations.writeDescriptionTo(&output, indent:"\(indent)  ")
              output += "\(indent)}\n"
              utilizationsElementIndex++
          }
          var temperaturesElementIndex:Int = 0
          for oneElementtemperatures in temperatures {
              output += "\(indent) temperatures[\(temperaturesElementIndex)] {\n"
              try oneElementtemperatures.writeDescriptionTo(&output, indent:"\(indent)  ")
              output += "\(indent)}\n"
              temperaturesElementIndex++
          }
          if hasCapacity {
            output += "\(indent) capacity {\n"
            try capacity?.writeDescriptionTo(&output, indent:"\(indent)  ")
            output += "\(indent) }\n"
          }
          if hasConfiguration {
            output += "\(indent) configuration {\n"
            try configuration?.writeDescriptionTo(&output, indent:"\(indent)  ")
            output += "\(indent) }\n"
          }
          var statisticsElementIndex:Int = 0
          for oneElementstatistics in statistics {
              output += "\(indent) statistics[\(statisticsElementIndex)] {\n"
              try oneElementstatistics.writeDescriptionTo(&output, indent:"\(indent)  ")
              output += "\(indent)}\n"
              statisticsElementIndex++
          }
          if hasMessages {
            output += "\(indent) messages: \(messages) \n"
          }
          if hasLimits {
            output += "\(indent) limits {\n"
            try limits?.writeDescriptionTo(&output, indent:"\(indent)  ")
            output += "\(indent) }\n"
          }
          if hasDevice {
            output += "\(indent) device {\n"
            try device?.writeDescriptionTo(&output, indent:"\(indent)  ")
            output += "\(indent) }\n"
          }
          unknownFields.writeDescriptionTo(&output, indent:indent)
        }
        override internal var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneValueOftypes in types {
                    hashCode = (hashCode &* 31) &+ Int(oneValueOftypes.rawValue)
                }
                for oneElementutilizations in utilizations {
                    hashCode = (hashCode &* 31) &+ oneElementutilizations.hashValue
                }
                for oneElementtemperatures in temperatures {
                    hashCode = (hashCode &* 31) &+ oneElementtemperatures.hashValue
                }
                if hasCapacity {
                    if let hashValuecapacity = capacity?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuecapacity
                    }
                }
                if hasConfiguration {
                    if let hashValueconfiguration = configuration?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueconfiguration
                    }
                }
                for oneElementstatistics in statistics {
                    hashCode = (hashCode &* 31) &+ oneElementstatistics.hashValue
                }
                if hasMessages {
                   hashCode = (hashCode &* 31) &+ messages.hashValue
                }
                if hasLimits {
                    if let hashValuelimits = limits?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuelimits
                    }
                }
                if hasDevice {
                    if let hashValuedevice = device?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuedevice
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override internal class func className() -> String {
            return "Com.Seagate.Kinetic.Proto.Command.GetLog"
        }
        override internal func className() -> String {
            return "Com.Seagate.Kinetic.Proto.Command.GetLog"
        }
        override internal func classMetaType() -> GeneratedMessage.Type {
            return Com.Seagate.Kinetic.Proto.Command.GetLog.self
        }
        //Meta information declaration end

        final internal class Builder : GeneratedMessageBuilder {
          private var builderResult:Com.Seagate.Kinetic.Proto.Command.GetLog = Com.Seagate.Kinetic.Proto.Command.GetLog()
          internal func getMessage() -> Com.Seagate.Kinetic.Proto.Command.GetLog {
              return builderResult
          }

          required override internal init () {
             super.init()
          }
          var types:Array<Command.GetLog.Types> {
              get {
                  return builderResult.types
              }
              set (value) {
                  builderResult.types = value
              }
          }
          func setTypes(value:Array<Command.GetLog.Types>) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Builder {
            self.types = value
            return self
          }
          internal func clearTypes() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Builder {
            builderResult.types.removeAll(keepCapacity: false)
            return self
          }
          var utilizations:Array<Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization> {
               get {
                   return builderResult.utilizations
               }
               set (value) {
                   builderResult.utilizations = value
               }
          }
          func setUtilizations(value:Array<Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization>) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Builder {
            self.utilizations = value
            return self
          }
          internal func clearUtilizations() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Builder {
            builderResult.utilizations.removeAll(keepCapacity: false)
            return self
          }
          var temperatures:Array<Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature> {
               get {
                   return builderResult.temperatures
               }
               set (value) {
                   builderResult.temperatures = value
               }
          }
          func setTemperatures(value:Array<Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature>) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Builder {
            self.temperatures = value
            return self
          }
          internal func clearTemperatures() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Builder {
            builderResult.temperatures.removeAll(keepCapacity: false)
            return self
          }
          var hasCapacity:Bool {
               get {
                   return builderResult.hasCapacity
               }
          }
          var capacity:Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity! {
               get {
                   if capacityBuilder_ != nil {
                      builderResult.capacity = capacityBuilder_.getMessage()
                   }
                   return builderResult.capacity
               }
               set (value) {
                   builderResult.hasCapacity = true
                   builderResult.capacity = value
               }
          }
          private var capacityBuilder_:Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity.Builder! {
               didSet {
                  builderResult.hasCapacity = true
               }
          }
          internal func getCapacityBuilder() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity.Builder {
            if capacityBuilder_ == nil {
               capacityBuilder_ = Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity.Builder()
               builderResult.capacity = capacityBuilder_.getMessage()
               if capacity != nil {
                  try! capacityBuilder_.mergeFrom(capacity)
               }
            }
            return capacityBuilder_
          }
          func setCapacity(value:Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity!) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Builder {
            self.capacity = value
            return self
          }
          internal func mergeCapacity(value:Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Builder {
            if builderResult.hasCapacity {
              builderResult.capacity = try Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity.builderWithPrototype(builderResult.capacity).mergeFrom(value).buildPartial()
            } else {
              builderResult.capacity = value
            }
            builderResult.hasCapacity = true
            return self
          }
          internal func clearCapacity() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Builder {
            capacityBuilder_ = nil
            builderResult.hasCapacity = false
            builderResult.capacity = nil
            return self
          }
          var hasConfiguration:Bool {
               get {
                   return builderResult.hasConfiguration
               }
          }
          var configuration:Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration! {
               get {
                   if configurationBuilder_ != nil {
                      builderResult.configuration = configurationBuilder_.getMessage()
                   }
                   return builderResult.configuration
               }
               set (value) {
                   builderResult.hasConfiguration = true
                   builderResult.configuration = value
               }
          }
          private var configurationBuilder_:Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder! {
               didSet {
                  builderResult.hasConfiguration = true
               }
          }
          internal func getConfigurationBuilder() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder {
            if configurationBuilder_ == nil {
               configurationBuilder_ = Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder()
               builderResult.configuration = configurationBuilder_.getMessage()
               if configuration != nil {
                  try! configurationBuilder_.mergeFrom(configuration)
               }
            }
            return configurationBuilder_
          }
          func setConfiguration(value:Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration!) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Builder {
            self.configuration = value
            return self
          }
          internal func mergeConfiguration(value:Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Builder {
            if builderResult.hasConfiguration {
              builderResult.configuration = try Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.builderWithPrototype(builderResult.configuration).mergeFrom(value).buildPartial()
            } else {
              builderResult.configuration = value
            }
            builderResult.hasConfiguration = true
            return self
          }
          internal func clearConfiguration() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Builder {
            configurationBuilder_ = nil
            builderResult.hasConfiguration = false
            builderResult.configuration = nil
            return self
          }
          var statistics:Array<Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics> {
               get {
                   return builderResult.statistics
               }
               set (value) {
                   builderResult.statistics = value
               }
          }
          func setStatistics(value:Array<Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics>) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Builder {
            self.statistics = value
            return self
          }
          internal func clearStatistics() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Builder {
            builderResult.statistics.removeAll(keepCapacity: false)
            return self
          }
          var hasMessages:Bool {
               get {
                    return builderResult.hasMessages
               }
          }
          var messages:NSData {
               get {
                    return builderResult.messages
               }
               set (value) {
                   builderResult.hasMessages = true
                   builderResult.messages = value
               }
          }
          func setMessages(value:NSData) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Builder {
            self.messages = value
            return self
          }
          internal func clearMessages() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Builder{
               builderResult.hasMessages = false
               builderResult.messages = NSData()
               return self
          }
          var hasLimits:Bool {
               get {
                   return builderResult.hasLimits
               }
          }
          var limits:Com.Seagate.Kinetic.Proto.Command.GetLog.Limits! {
               get {
                   if limitsBuilder_ != nil {
                      builderResult.limits = limitsBuilder_.getMessage()
                   }
                   return builderResult.limits
               }
               set (value) {
                   builderResult.hasLimits = true
                   builderResult.limits = value
               }
          }
          private var limitsBuilder_:Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder! {
               didSet {
                  builderResult.hasLimits = true
               }
          }
          internal func getLimitsBuilder() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder {
            if limitsBuilder_ == nil {
               limitsBuilder_ = Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder()
               builderResult.limits = limitsBuilder_.getMessage()
               if limits != nil {
                  try! limitsBuilder_.mergeFrom(limits)
               }
            }
            return limitsBuilder_
          }
          func setLimits(value:Com.Seagate.Kinetic.Proto.Command.GetLog.Limits!) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Builder {
            self.limits = value
            return self
          }
          internal func mergeLimits(value:Com.Seagate.Kinetic.Proto.Command.GetLog.Limits) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Builder {
            if builderResult.hasLimits {
              builderResult.limits = try Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.builderWithPrototype(builderResult.limits).mergeFrom(value).buildPartial()
            } else {
              builderResult.limits = value
            }
            builderResult.hasLimits = true
            return self
          }
          internal func clearLimits() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Builder {
            limitsBuilder_ = nil
            builderResult.hasLimits = false
            builderResult.limits = nil
            return self
          }
          var hasDevice:Bool {
               get {
                   return builderResult.hasDevice
               }
          }
          var device:Com.Seagate.Kinetic.Proto.Command.GetLog.Device! {
               get {
                   if deviceBuilder_ != nil {
                      builderResult.device = deviceBuilder_.getMessage()
                   }
                   return builderResult.device
               }
               set (value) {
                   builderResult.hasDevice = true
                   builderResult.device = value
               }
          }
          private var deviceBuilder_:Com.Seagate.Kinetic.Proto.Command.GetLog.Device.Builder! {
               didSet {
                  builderResult.hasDevice = true
               }
          }
          internal func getDeviceBuilder() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Device.Builder {
            if deviceBuilder_ == nil {
               deviceBuilder_ = Com.Seagate.Kinetic.Proto.Command.GetLog.Device.Builder()
               builderResult.device = deviceBuilder_.getMessage()
               if device != nil {
                  try! deviceBuilder_.mergeFrom(device)
               }
            }
            return deviceBuilder_
          }
          func setDevice(value:Com.Seagate.Kinetic.Proto.Command.GetLog.Device!) -> Com.Seagate.Kinetic.Proto.Command.GetLog.Builder {
            self.device = value
            return self
          }
          internal func mergeDevice(value:Com.Seagate.Kinetic.Proto.Command.GetLog.Device) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Builder {
            if builderResult.hasDevice {
              builderResult.device = try Com.Seagate.Kinetic.Proto.Command.GetLog.Device.builderWithPrototype(builderResult.device).mergeFrom(value).buildPartial()
            } else {
              builderResult.device = value
            }
            builderResult.hasDevice = true
            return self
          }
          internal func clearDevice() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Builder {
            deviceBuilder_ = nil
            builderResult.hasDevice = false
            builderResult.device = nil
            return self
          }
          override internal var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          internal override func clear() -> Com.Seagate.Kinetic.Proto.Command.GetLog.Builder {
            builderResult = Com.Seagate.Kinetic.Proto.Command.GetLog()
            return self
          }
          internal override func clone() throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Builder {
            return try Com.Seagate.Kinetic.Proto.Command.GetLog.builderWithPrototype(builderResult)
          }
          internal override func build() throws -> Com.Seagate.Kinetic.Proto.Command.GetLog {
               try checkInitialized()
               return buildPartial()
          }
          internal func buildPartial() -> Com.Seagate.Kinetic.Proto.Command.GetLog {
            let returnMe:Com.Seagate.Kinetic.Proto.Command.GetLog = builderResult
            return returnMe
          }
          internal func mergeFrom(other:Com.Seagate.Kinetic.Proto.Command.GetLog) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Builder {
            if other == Com.Seagate.Kinetic.Proto.Command.GetLog() {
             return self
            }
            if !other.types.isEmpty {
               builderResult.types += other.types
            }
            if !other.utilizations.isEmpty  {
               builderResult.utilizations += other.utilizations
            }
            if !other.temperatures.isEmpty  {
               builderResult.temperatures += other.temperatures
            }
            if (other.hasCapacity) {
                try mergeCapacity(other.capacity)
            }
            if (other.hasConfiguration) {
                try mergeConfiguration(other.configuration)
            }
            if !other.statistics.isEmpty  {
               builderResult.statistics += other.statistics
            }
            if other.hasMessages {
                 messages = other.messages
            }
            if (other.hasLimits) {
                try mergeLimits(other.limits)
            }
            if (other.hasDevice) {
                try mergeDevice(other.device)
            }
            try mergeUnknownFields(other.unknownFields)
            return self
          }
          internal override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Builder {
               return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
          }
          internal override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.GetLog.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
            while (true) {
              let tag = try input.readTag()
              switch tag {
              case 0: 
                self.unknownFields = try unknownFieldsBuilder.build()
                return self

              case 8 :
                let valueInttypes = try input.readEnum()
                if let enumstypes = Command.GetLog.Types(rawValue:valueInttypes) {
                     builderResult.types += [enumstypes]
                } else {
                     try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueInttypes))
                }

              case 18 :
                let subBuilder = Com.Seagate.Kinetic.Proto.Command.GetLog.Utilization.Builder()
                try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
                utilizations += [subBuilder.buildPartial()]

              case 26 :
                let subBuilder = Com.Seagate.Kinetic.Proto.Command.GetLog.Temperature.Builder()
                try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
                temperatures += [subBuilder.buildPartial()]

              case 34 :
                let subBuilder:Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity.Builder = Com.Seagate.Kinetic.Proto.Command.GetLog.Capacity.Builder()
                if hasCapacity {
                  try subBuilder.mergeFrom(capacity)
                }
                try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
                capacity = subBuilder.buildPartial()

              case 42 :
                let subBuilder:Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder = Com.Seagate.Kinetic.Proto.Command.GetLog.Configuration.Builder()
                if hasConfiguration {
                  try subBuilder.mergeFrom(configuration)
                }
                try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
                configuration = subBuilder.buildPartial()

              case 50 :
                let subBuilder = Com.Seagate.Kinetic.Proto.Command.GetLog.Statistics.Builder()
                try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
                statistics += [subBuilder.buildPartial()]

              case 58 :
                messages = try input.readData()

              case 66 :
                let subBuilder:Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder = Com.Seagate.Kinetic.Proto.Command.GetLog.Limits.Builder()
                if hasLimits {
                  try subBuilder.mergeFrom(limits)
                }
                try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
                limits = subBuilder.buildPartial()

              case 74 :
                let subBuilder:Com.Seagate.Kinetic.Proto.Command.GetLog.Device.Builder = Com.Seagate.Kinetic.Proto.Command.GetLog.Device.Builder()
                if hasDevice {
                  try subBuilder.mergeFrom(device)
                }
                try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
                device = subBuilder.buildPartial()

              default:
                if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag))) {
                   unknownFields = try unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
        }

      }

    //Nested type declaration end



    //Nested type declaration start

      final internal class Security : GeneratedMessage, GeneratedMessageProtocol {


        //Nested type declaration start

          final internal class Acl : GeneratedMessage, GeneratedMessageProtocol {


            //Nested type declaration start

              final internal class Scope : GeneratedMessage, GeneratedMessageProtocol {
                private(set) var hasOffset:Bool = false
                private(set) var offset:Int64 = Int64(0)

                private(set) var hasValue:Bool = false
                private(set) var value:NSData = NSData()

                private var permissionMemoizedSerializedSize:Int32 = 0
                private(set) var permission:Array<Command.Security.Acl.Permission> = Array<Command.Security.Acl.Permission>()
                private(set) var hasTlsRequired:Bool = false
                private(set) var tlsRequired:Bool = false

                required internal init() {
                     super.init()
                }
                override internal func isInitialized() -> Bool {
                 return true
                }
                override internal func writeToCodedOutputStream(output:CodedOutputStream) throws {
                  if hasOffset {
                    try output.writeInt64(1, value:offset)
                  }
                  if hasValue {
                    try output.writeData(2, value:value)
                  }
                  for oneValueOfpermission in permission {
                      try output.writeEnum(3, value:oneValueOfpermission.rawValue)
                  }
                  if hasTlsRequired {
                    try output.writeBool(4, value:tlsRequired)
                  }
                  try unknownFields.writeToCodedOutputStream(output)
                }
                override internal func serializedSize() -> Int32 {
                  var serialize_size:Int32 = memoizedSerializedSize
                  if serialize_size != -1 {
                   return serialize_size
                  }

                  serialize_size = 0
                  if hasOffset {
                    serialize_size += offset.computeInt64Size(1)
                  }
                  if hasValue {
                    serialize_size += value.computeDataSize(2)
                  }
                  var dataSizepermission:Int32 = 0
                  for oneValueOfpermission in permission {
                      dataSizepermission += oneValueOfpermission.rawValue.computeEnumSizeNoTag()
                  }
                  serialize_size += dataSizepermission
                  serialize_size += (1 * Int32(permission.count))
                  if hasTlsRequired {
                    serialize_size += tlsRequired.computeBoolSize(4)
                  }
                  serialize_size += unknownFields.serializedSize()
                  memoizedSerializedSize = serialize_size
                  return serialize_size
                }
                internal class func parseFromData(data:NSData) throws -> Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope {
                  return try Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope.Builder().mergeFromData(data, extensionRegistry:Com.Seagate.Kinetic.Proto.KineticRoot.sharedInstance.extensionRegistry).build()
                }
                internal class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope {
                  return try Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
                }
                internal class func parseFromInputStream(input:NSInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope {
                  return try Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope.Builder().mergeFromInputStream(input).build()
                }
                internal class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope {
                  return try Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
                }
                internal class func parseFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope {
                  return try Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope.Builder().mergeFromCodedInputStream(input).build()
                }
                internal class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope {
                  return try Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
                }
                internal class func getBuilder() -> Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope.Builder {
                  return Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope.classBuilder() as! Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope.Builder
                }
                internal func getBuilder() -> Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope.Builder {
                  return classBuilder() as! Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope.Builder
                }
                internal override class func classBuilder() -> MessageBuilder {
                  return Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope.Builder()
                }
                internal override func classBuilder() -> MessageBuilder {
                  return Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope.Builder()
                }
                internal func toBuilder() throws -> Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope.Builder {
                  return try Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope.builderWithPrototype(self)
                }
                internal class func builderWithPrototype(prototype:Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope) throws -> Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope.Builder {
                  return try Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope.Builder().mergeFrom(prototype)
                }
                override internal func writeDescriptionTo(inout output:String, indent:String) throws {
                  if hasOffset {
                    output += "\(indent) offset: \(offset) \n"
                  }
                  if hasValue {
                    output += "\(indent) value: \(value) \n"
                  }
                  var permissionElementIndex:Int = 0
                  for oneValueOfpermission in permission {
                      output += "\(indent) permission[\(permissionElementIndex)]: \(oneValueOfpermission.rawValue)\n"
                      permissionElementIndex++
                  }
                  if hasTlsRequired {
                    output += "\(indent) tlsRequired: \(tlsRequired) \n"
                  }
                  unknownFields.writeDescriptionTo(&output, indent:indent)
                }
                override internal var hashValue:Int {
                    get {
                        var hashCode:Int = 7
                        if hasOffset {
                           hashCode = (hashCode &* 31) &+ offset.hashValue
                        }
                        if hasValue {
                           hashCode = (hashCode &* 31) &+ value.hashValue
                        }
                        for oneValueOfpermission in permission {
                            hashCode = (hashCode &* 31) &+ Int(oneValueOfpermission.rawValue)
                        }
                        if hasTlsRequired {
                           hashCode = (hashCode &* 31) &+ tlsRequired.hashValue
                        }
                        hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                        return hashCode
                    }
                }


                //Meta information declaration start

                override internal class func className() -> String {
                    return "Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope"
                }
                override internal func className() -> String {
                    return "Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope"
                }
                override internal func classMetaType() -> GeneratedMessage.Type {
                    return Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope.self
                }
                //Meta information declaration end

                final internal class Builder : GeneratedMessageBuilder {
                  private var builderResult:Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope = Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope()
                  internal func getMessage() -> Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope {
                      return builderResult
                  }

                  required override internal init () {
                     super.init()
                  }
                  var hasOffset:Bool {
                       get {
                            return builderResult.hasOffset
                       }
                  }
                  var offset:Int64 {
                       get {
                            return builderResult.offset
                       }
                       set (value) {
                           builderResult.hasOffset = true
                           builderResult.offset = value
                       }
                  }
                  func setOffset(value:Int64) -> Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope.Builder {
                    self.offset = value
                    return self
                  }
                  internal func clearOffset() -> Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope.Builder{
                       builderResult.hasOffset = false
                       builderResult.offset = Int64(0)
                       return self
                  }
                  var hasValue:Bool {
                       get {
                            return builderResult.hasValue
                       }
                  }
                  var value:NSData {
                       get {
                            return builderResult.value
                       }
                       set (value) {
                           builderResult.hasValue = true
                           builderResult.value = value
                       }
                  }
                  func setValue(value:NSData) -> Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope.Builder {
                    self.value = value
                    return self
                  }
                  internal func clearValue() -> Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope.Builder{
                       builderResult.hasValue = false
                       builderResult.value = NSData()
                       return self
                  }
                  var permission:Array<Command.Security.Acl.Permission> {
                      get {
                          return builderResult.permission
                      }
                      set (value) {
                          builderResult.permission = value
                      }
                  }
                  func setPermission(value:Array<Command.Security.Acl.Permission>) -> Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope.Builder {
                    self.permission = value
                    return self
                  }
                  internal func clearPermission() -> Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope.Builder {
                    builderResult.permission.removeAll(keepCapacity: false)
                    return self
                  }
                  var hasTlsRequired:Bool {
                       get {
                            return builderResult.hasTlsRequired
                       }
                  }
                  var tlsRequired:Bool {
                       get {
                            return builderResult.tlsRequired
                       }
                       set (value) {
                           builderResult.hasTlsRequired = true
                           builderResult.tlsRequired = value
                       }
                  }
                  func setTlsRequired(value:Bool) -> Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope.Builder {
                    self.tlsRequired = value
                    return self
                  }
                  internal func clearTlsRequired() -> Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope.Builder{
                       builderResult.hasTlsRequired = false
                       builderResult.tlsRequired = false
                       return self
                  }
                  override internal var internalGetResult:GeneratedMessage {
                       get {
                          return builderResult
                       }
                  }
                  internal override func clear() -> Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope.Builder {
                    builderResult = Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope()
                    return self
                  }
                  internal override func clone() throws -> Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope.Builder {
                    return try Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope.builderWithPrototype(builderResult)
                  }
                  internal override func build() throws -> Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope {
                       try checkInitialized()
                       return buildPartial()
                  }
                  internal func buildPartial() -> Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope {
                    let returnMe:Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope = builderResult
                    return returnMe
                  }
                  internal func mergeFrom(other:Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope) throws -> Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope.Builder {
                    if other == Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope() {
                     return self
                    }
                    if other.hasOffset {
                         offset = other.offset
                    }
                    if other.hasValue {
                         value = other.value
                    }
                    if !other.permission.isEmpty {
                       builderResult.permission += other.permission
                    }
                    if other.hasTlsRequired {
                         tlsRequired = other.tlsRequired
                    }
                    try mergeUnknownFields(other.unknownFields)
                    return self
                  }
                  internal override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope.Builder {
                       return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
                  }
                  internal override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
                    while (true) {
                      let tag = try input.readTag()
                      switch tag {
                      case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                      case 8 :
                        offset = try input.readInt64()

                      case 18 :
                        value = try input.readData()

                      case 24 :
                        let valueIntpermission = try input.readEnum()
                        if let enumspermission = Command.Security.Acl.Permission(rawValue:valueIntpermission) {
                             builderResult.permission += [enumspermission]
                        } else {
                             try unknownFieldsBuilder.mergeVarintField(3, value:Int64(valueIntpermission))
                        }

                      case 32 :
                        tlsRequired = try input.readBool()

                      default:
                        if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag))) {
                           unknownFields = try unknownFieldsBuilder.build()
                           return self
                        }
                      }
                    }
                  }
                }

              }

            //Nested type declaration end



              //Enum type declaration start 

              internal enum Hmacalgorithm:Int32 {
                case InvalidHmacAlgorithm = -1
                case HmacSha1 = 1

              }

              //Enum type declaration end 



              //Enum type declaration start 

              internal enum Permission:Int32 {
                case InvalidPermission = -1
                case Read = 0
                case Write = 1
                case Delete = 2
                case Range = 3
                case Setup = 4
                case P2Pop = 5
                case Getlog = 7
                case Security = 8

              }

              //Enum type declaration end 

            private(set) var hasIdentity:Bool = false
            private(set) var identity:Int64 = Int64(0)

            private(set) var hasKey:Bool = false
            private(set) var key:NSData = NSData()

            private(set) var hmacAlgorithm:Command.Security.Acl.Hmacalgorithm = Command.Security.Acl.Hmacalgorithm.InvalidHmacAlgorithm
            private(set) var hasHmacAlgorithm:Bool = false
            private(set) var scope:Array<Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope>  = Array<Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope>()
            private(set) var maxPriority:Command.Priority = Command.Priority.Normal
            private(set) var hasMaxPriority:Bool = false
            required internal init() {
                 super.init()
            }
            override internal func isInitialized() -> Bool {
             return true
            }
            override internal func writeToCodedOutputStream(output:CodedOutputStream) throws {
              if hasIdentity {
                try output.writeInt64(1, value:identity)
              }
              if hasKey {
                try output.writeData(2, value:key)
              }
              if hasHmacAlgorithm {
                try output.writeEnum(3, value:hmacAlgorithm.rawValue)
              }
              for oneElementscope in scope {
                  try output.writeMessage(4, value:oneElementscope)
              }
              if hasMaxPriority {
                try output.writeEnum(5, value:maxPriority.rawValue)
              }
              try unknownFields.writeToCodedOutputStream(output)
            }
            override internal func serializedSize() -> Int32 {
              var serialize_size:Int32 = memoizedSerializedSize
              if serialize_size != -1 {
               return serialize_size
              }

              serialize_size = 0
              if hasIdentity {
                serialize_size += identity.computeInt64Size(1)
              }
              if hasKey {
                serialize_size += key.computeDataSize(2)
              }
              if (hasHmacAlgorithm) {
                serialize_size += hmacAlgorithm.rawValue.computeEnumSize(3)
              }
              for oneElementscope in scope {
                  serialize_size += oneElementscope.computeMessageSize(4)
              }
              if (hasMaxPriority) {
                serialize_size += maxPriority.rawValue.computeEnumSize(5)
              }
              serialize_size += unknownFields.serializedSize()
              memoizedSerializedSize = serialize_size
              return serialize_size
            }
            internal class func parseFromData(data:NSData) throws -> Com.Seagate.Kinetic.Proto.Command.Security.Acl {
              return try Com.Seagate.Kinetic.Proto.Command.Security.Acl.Builder().mergeFromData(data, extensionRegistry:Com.Seagate.Kinetic.Proto.KineticRoot.sharedInstance.extensionRegistry).build()
            }
            internal class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.Security.Acl {
              return try Com.Seagate.Kinetic.Proto.Command.Security.Acl.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
            }
            internal class func parseFromInputStream(input:NSInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.Security.Acl {
              return try Com.Seagate.Kinetic.Proto.Command.Security.Acl.Builder().mergeFromInputStream(input).build()
            }
            internal class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.Security.Acl {
              return try Com.Seagate.Kinetic.Proto.Command.Security.Acl.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
            }
            internal class func parseFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.Security.Acl {
              return try Com.Seagate.Kinetic.Proto.Command.Security.Acl.Builder().mergeFromCodedInputStream(input).build()
            }
            internal class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.Security.Acl {
              return try Com.Seagate.Kinetic.Proto.Command.Security.Acl.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
            }
            internal class func getBuilder() -> Com.Seagate.Kinetic.Proto.Command.Security.Acl.Builder {
              return Com.Seagate.Kinetic.Proto.Command.Security.Acl.classBuilder() as! Com.Seagate.Kinetic.Proto.Command.Security.Acl.Builder
            }
            internal func getBuilder() -> Com.Seagate.Kinetic.Proto.Command.Security.Acl.Builder {
              return classBuilder() as! Com.Seagate.Kinetic.Proto.Command.Security.Acl.Builder
            }
            internal override class func classBuilder() -> MessageBuilder {
              return Com.Seagate.Kinetic.Proto.Command.Security.Acl.Builder()
            }
            internal override func classBuilder() -> MessageBuilder {
              return Com.Seagate.Kinetic.Proto.Command.Security.Acl.Builder()
            }
            internal func toBuilder() throws -> Com.Seagate.Kinetic.Proto.Command.Security.Acl.Builder {
              return try Com.Seagate.Kinetic.Proto.Command.Security.Acl.builderWithPrototype(self)
            }
            internal class func builderWithPrototype(prototype:Com.Seagate.Kinetic.Proto.Command.Security.Acl) throws -> Com.Seagate.Kinetic.Proto.Command.Security.Acl.Builder {
              return try Com.Seagate.Kinetic.Proto.Command.Security.Acl.Builder().mergeFrom(prototype)
            }
            override internal func writeDescriptionTo(inout output:String, indent:String) throws {
              if hasIdentity {
                output += "\(indent) identity: \(identity) \n"
              }
              if hasKey {
                output += "\(indent) key: \(key) \n"
              }
              if (hasHmacAlgorithm) {
                output += "\(indent) hmacAlgorithm: \(hmacAlgorithm.rawValue)\n"
              }
              var scopeElementIndex:Int = 0
              for oneElementscope in scope {
                  output += "\(indent) scope[\(scopeElementIndex)] {\n"
                  try oneElementscope.writeDescriptionTo(&output, indent:"\(indent)  ")
                  output += "\(indent)}\n"
                  scopeElementIndex++
              }
              if (hasMaxPriority) {
                output += "\(indent) maxPriority: \(maxPriority.rawValue)\n"
              }
              unknownFields.writeDescriptionTo(&output, indent:indent)
            }
            override internal var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasIdentity {
                       hashCode = (hashCode &* 31) &+ identity.hashValue
                    }
                    if hasKey {
                       hashCode = (hashCode &* 31) &+ key.hashValue
                    }
                    if hasHmacAlgorithm {
                       hashCode = (hashCode &* 31) &+ Int(hmacAlgorithm.rawValue)
                    }
                    for oneElementscope in scope {
                        hashCode = (hashCode &* 31) &+ oneElementscope.hashValue
                    }
                    if hasMaxPriority {
                       hashCode = (hashCode &* 31) &+ Int(maxPriority.rawValue)
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override internal class func className() -> String {
                return "Com.Seagate.Kinetic.Proto.Command.Security.Acl"
            }
            override internal func className() -> String {
                return "Com.Seagate.Kinetic.Proto.Command.Security.Acl"
            }
            override internal func classMetaType() -> GeneratedMessage.Type {
                return Com.Seagate.Kinetic.Proto.Command.Security.Acl.self
            }
            //Meta information declaration end

            final internal class Builder : GeneratedMessageBuilder {
              private var builderResult:Com.Seagate.Kinetic.Proto.Command.Security.Acl = Com.Seagate.Kinetic.Proto.Command.Security.Acl()
              internal func getMessage() -> Com.Seagate.Kinetic.Proto.Command.Security.Acl {
                  return builderResult
              }

              required override internal init () {
                 super.init()
              }
              var hasIdentity:Bool {
                   get {
                        return builderResult.hasIdentity
                   }
              }
              var identity:Int64 {
                   get {
                        return builderResult.identity
                   }
                   set (value) {
                       builderResult.hasIdentity = true
                       builderResult.identity = value
                   }
              }
              func setIdentity(value:Int64) -> Com.Seagate.Kinetic.Proto.Command.Security.Acl.Builder {
                self.identity = value
                return self
              }
              internal func clearIdentity() -> Com.Seagate.Kinetic.Proto.Command.Security.Acl.Builder{
                   builderResult.hasIdentity = false
                   builderResult.identity = Int64(0)
                   return self
              }
              var hasKey:Bool {
                   get {
                        return builderResult.hasKey
                   }
              }
              var key:NSData {
                   get {
                        return builderResult.key
                   }
                   set (value) {
                       builderResult.hasKey = true
                       builderResult.key = value
                   }
              }
              func setKey(value:NSData) -> Com.Seagate.Kinetic.Proto.Command.Security.Acl.Builder {
                self.key = value
                return self
              }
              internal func clearKey() -> Com.Seagate.Kinetic.Proto.Command.Security.Acl.Builder{
                   builderResult.hasKey = false
                   builderResult.key = NSData()
                   return self
              }
                var hasHmacAlgorithm:Bool{
                    get {
                        return builderResult.hasHmacAlgorithm
                    }
                }
                var hmacAlgorithm:Command.Security.Acl.Hmacalgorithm {
                    get {
                        return builderResult.hmacAlgorithm
                    }
                    set (value) {
                        builderResult.hasHmacAlgorithm = true
                        builderResult.hmacAlgorithm = value
                    }
                }
                internal func setHmacAlgorithm(value:Command.Security.Acl.Hmacalgorithm) -> Com.Seagate.Kinetic.Proto.Command.Security.Acl.Builder {
                  self.hmacAlgorithm = value
                  return self
                }
                internal func clearHmacAlgorithm() -> Com.Seagate.Kinetic.Proto.Command.Security.Acl.Builder {
                   builderResult.hasHmacAlgorithm = false
                   builderResult.hmacAlgorithm = .InvalidHmacAlgorithm
                   return self
                }
              var scope:Array<Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope> {
                   get {
                       return builderResult.scope
                   }
                   set (value) {
                       builderResult.scope = value
                   }
              }
              func setScope(value:Array<Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope>) -> Com.Seagate.Kinetic.Proto.Command.Security.Acl.Builder {
                self.scope = value
                return self
              }
              internal func clearScope() -> Com.Seagate.Kinetic.Proto.Command.Security.Acl.Builder {
                builderResult.scope.removeAll(keepCapacity: false)
                return self
              }
                var hasMaxPriority:Bool{
                    get {
                        return builderResult.hasMaxPriority
                    }
                }
                var maxPriority:Command.Priority {
                    get {
                        return builderResult.maxPriority
                    }
                    set (value) {
                        builderResult.hasMaxPriority = true
                        builderResult.maxPriority = value
                    }
                }
                internal func setMaxPriority(value:Command.Priority) -> Com.Seagate.Kinetic.Proto.Command.Security.Acl.Builder {
                  self.maxPriority = value
                  return self
                }
                internal func clearMaxPriority() -> Com.Seagate.Kinetic.Proto.Command.Security.Acl.Builder {
                   builderResult.hasMaxPriority = false
                   builderResult.maxPriority = .Normal
                   return self
                }
              override internal var internalGetResult:GeneratedMessage {
                   get {
                      return builderResult
                   }
              }
              internal override func clear() -> Com.Seagate.Kinetic.Proto.Command.Security.Acl.Builder {
                builderResult = Com.Seagate.Kinetic.Proto.Command.Security.Acl()
                return self
              }
              internal override func clone() throws -> Com.Seagate.Kinetic.Proto.Command.Security.Acl.Builder {
                return try Com.Seagate.Kinetic.Proto.Command.Security.Acl.builderWithPrototype(builderResult)
              }
              internal override func build() throws -> Com.Seagate.Kinetic.Proto.Command.Security.Acl {
                   try checkInitialized()
                   return buildPartial()
              }
              internal func buildPartial() -> Com.Seagate.Kinetic.Proto.Command.Security.Acl {
                let returnMe:Com.Seagate.Kinetic.Proto.Command.Security.Acl = builderResult
                return returnMe
              }
              internal func mergeFrom(other:Com.Seagate.Kinetic.Proto.Command.Security.Acl) throws -> Com.Seagate.Kinetic.Proto.Command.Security.Acl.Builder {
                if other == Com.Seagate.Kinetic.Proto.Command.Security.Acl() {
                 return self
                }
                if other.hasIdentity {
                     identity = other.identity
                }
                if other.hasKey {
                     key = other.key
                }
                if other.hasHmacAlgorithm {
                     hmacAlgorithm = other.hmacAlgorithm
                }
                if !other.scope.isEmpty  {
                   builderResult.scope += other.scope
                }
                if other.hasMaxPriority {
                     maxPriority = other.maxPriority
                }
                try mergeUnknownFields(other.unknownFields)
                return self
              }
              internal override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.Security.Acl.Builder {
                   return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
              }
              internal override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.Security.Acl.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
                while (true) {
                  let tag = try input.readTag()
                  switch tag {
                  case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                  case 8 :
                    identity = try input.readInt64()

                  case 18 :
                    key = try input.readData()

                  case 24 :
                    let valueInthmacAlgorithm = try input.readEnum()
                    if let enumshmacAlgorithm = Command.Security.Acl.Hmacalgorithm(rawValue:valueInthmacAlgorithm){
                         hmacAlgorithm = enumshmacAlgorithm
                    } else {
                         try unknownFieldsBuilder.mergeVarintField(3, value:Int64(valueInthmacAlgorithm))
                    }

                  case 34 :
                    let subBuilder = Com.Seagate.Kinetic.Proto.Command.Security.Acl.Scope.Builder()
                    try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
                    scope += [subBuilder.buildPartial()]

                  case 40 :
                    let valueIntmaxPriority = try input.readEnum()
                    if let enumsmaxPriority = Command.Priority(rawValue:valueIntmaxPriority){
                         maxPriority = enumsmaxPriority
                    } else {
                         try unknownFieldsBuilder.mergeVarintField(5, value:Int64(valueIntmaxPriority))
                    }

                  default:
                    if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag))) {
                       unknownFields = try unknownFieldsBuilder.build()
                       return self
                    }
                  }
                }
              }
            }

          }

        //Nested type declaration end

        private(set) var acl:Array<Com.Seagate.Kinetic.Proto.Command.Security.Acl>  = Array<Com.Seagate.Kinetic.Proto.Command.Security.Acl>()
        private(set) var hasOldLockPin:Bool = false
        private(set) var oldLockPin:NSData = NSData()

        private(set) var hasNewLockPin:Bool = false
        private(set) var newLockPin:NSData = NSData()

        private(set) var hasOldErasePin:Bool = false
        private(set) var oldErasePin:NSData = NSData()

        private(set) var hasNewErasePin:Bool = false
        private(set) var newErasePin:NSData = NSData()

        required internal init() {
             super.init()
        }
        override internal func isInitialized() -> Bool {
         return true
        }
        override internal func writeToCodedOutputStream(output:CodedOutputStream) throws {
          for oneElementacl in acl {
              try output.writeMessage(2, value:oneElementacl)
          }
          if hasOldLockPin {
            try output.writeData(3, value:oldLockPin)
          }
          if hasNewLockPin {
            try output.writeData(4, value:newLockPin)
          }
          if hasOldErasePin {
            try output.writeData(5, value:oldErasePin)
          }
          if hasNewErasePin {
            try output.writeData(6, value:newErasePin)
          }
          try unknownFields.writeToCodedOutputStream(output)
        }
        override internal func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          for oneElementacl in acl {
              serialize_size += oneElementacl.computeMessageSize(2)
          }
          if hasOldLockPin {
            serialize_size += oldLockPin.computeDataSize(3)
          }
          if hasNewLockPin {
            serialize_size += newLockPin.computeDataSize(4)
          }
          if hasOldErasePin {
            serialize_size += oldErasePin.computeDataSize(5)
          }
          if hasNewErasePin {
            serialize_size += newErasePin.computeDataSize(6)
          }
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        internal class func parseFromData(data:NSData) throws -> Com.Seagate.Kinetic.Proto.Command.Security {
          return try Com.Seagate.Kinetic.Proto.Command.Security.Builder().mergeFromData(data, extensionRegistry:Com.Seagate.Kinetic.Proto.KineticRoot.sharedInstance.extensionRegistry).build()
        }
        internal class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.Security {
          return try Com.Seagate.Kinetic.Proto.Command.Security.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
        }
        internal class func parseFromInputStream(input:NSInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.Security {
          return try Com.Seagate.Kinetic.Proto.Command.Security.Builder().mergeFromInputStream(input).build()
        }
        internal class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.Security {
          return try Com.Seagate.Kinetic.Proto.Command.Security.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        internal class func parseFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.Security {
          return try Com.Seagate.Kinetic.Proto.Command.Security.Builder().mergeFromCodedInputStream(input).build()
        }
        internal class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.Security {
          return try Com.Seagate.Kinetic.Proto.Command.Security.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        internal class func getBuilder() -> Com.Seagate.Kinetic.Proto.Command.Security.Builder {
          return Com.Seagate.Kinetic.Proto.Command.Security.classBuilder() as! Com.Seagate.Kinetic.Proto.Command.Security.Builder
        }
        internal func getBuilder() -> Com.Seagate.Kinetic.Proto.Command.Security.Builder {
          return classBuilder() as! Com.Seagate.Kinetic.Proto.Command.Security.Builder
        }
        internal override class func classBuilder() -> MessageBuilder {
          return Com.Seagate.Kinetic.Proto.Command.Security.Builder()
        }
        internal override func classBuilder() -> MessageBuilder {
          return Com.Seagate.Kinetic.Proto.Command.Security.Builder()
        }
        internal func toBuilder() throws -> Com.Seagate.Kinetic.Proto.Command.Security.Builder {
          return try Com.Seagate.Kinetic.Proto.Command.Security.builderWithPrototype(self)
        }
        internal class func builderWithPrototype(prototype:Com.Seagate.Kinetic.Proto.Command.Security) throws -> Com.Seagate.Kinetic.Proto.Command.Security.Builder {
          return try Com.Seagate.Kinetic.Proto.Command.Security.Builder().mergeFrom(prototype)
        }
        override internal func writeDescriptionTo(inout output:String, indent:String) throws {
          var aclElementIndex:Int = 0
          for oneElementacl in acl {
              output += "\(indent) acl[\(aclElementIndex)] {\n"
              try oneElementacl.writeDescriptionTo(&output, indent:"\(indent)  ")
              output += "\(indent)}\n"
              aclElementIndex++
          }
          if hasOldLockPin {
            output += "\(indent) oldLockPin: \(oldLockPin) \n"
          }
          if hasNewLockPin {
            output += "\(indent) newLockPin: \(newLockPin) \n"
          }
          if hasOldErasePin {
            output += "\(indent) oldErasePin: \(oldErasePin) \n"
          }
          if hasNewErasePin {
            output += "\(indent) newErasePin: \(newErasePin) \n"
          }
          unknownFields.writeDescriptionTo(&output, indent:indent)
        }
        override internal var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementacl in acl {
                    hashCode = (hashCode &* 31) &+ oneElementacl.hashValue
                }
                if hasOldLockPin {
                   hashCode = (hashCode &* 31) &+ oldLockPin.hashValue
                }
                if hasNewLockPin {
                   hashCode = (hashCode &* 31) &+ newLockPin.hashValue
                }
                if hasOldErasePin {
                   hashCode = (hashCode &* 31) &+ oldErasePin.hashValue
                }
                if hasNewErasePin {
                   hashCode = (hashCode &* 31) &+ newErasePin.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override internal class func className() -> String {
            return "Com.Seagate.Kinetic.Proto.Command.Security"
        }
        override internal func className() -> String {
            return "Com.Seagate.Kinetic.Proto.Command.Security"
        }
        override internal func classMetaType() -> GeneratedMessage.Type {
            return Com.Seagate.Kinetic.Proto.Command.Security.self
        }
        //Meta information declaration end

        final internal class Builder : GeneratedMessageBuilder {
          private var builderResult:Com.Seagate.Kinetic.Proto.Command.Security = Com.Seagate.Kinetic.Proto.Command.Security()
          internal func getMessage() -> Com.Seagate.Kinetic.Proto.Command.Security {
              return builderResult
          }

          required override internal init () {
             super.init()
          }
          var acl:Array<Com.Seagate.Kinetic.Proto.Command.Security.Acl> {
               get {
                   return builderResult.acl
               }
               set (value) {
                   builderResult.acl = value
               }
          }
          func setAcl(value:Array<Com.Seagate.Kinetic.Proto.Command.Security.Acl>) -> Com.Seagate.Kinetic.Proto.Command.Security.Builder {
            self.acl = value
            return self
          }
          internal func clearAcl() -> Com.Seagate.Kinetic.Proto.Command.Security.Builder {
            builderResult.acl.removeAll(keepCapacity: false)
            return self
          }
          var hasOldLockPin:Bool {
               get {
                    return builderResult.hasOldLockPin
               }
          }
          var oldLockPin:NSData {
               get {
                    return builderResult.oldLockPin
               }
               set (value) {
                   builderResult.hasOldLockPin = true
                   builderResult.oldLockPin = value
               }
          }
          func setOldLockPin(value:NSData) -> Com.Seagate.Kinetic.Proto.Command.Security.Builder {
            self.oldLockPin = value
            return self
          }
          internal func clearOldLockPin() -> Com.Seagate.Kinetic.Proto.Command.Security.Builder{
               builderResult.hasOldLockPin = false
               builderResult.oldLockPin = NSData()
               return self
          }
          var hasNewLockPin:Bool {
               get {
                    return builderResult.hasNewLockPin
               }
          }
          var newLockPin:NSData {
               get {
                    return builderResult.newLockPin
               }
               set (value) {
                   builderResult.hasNewLockPin = true
                   builderResult.newLockPin = value
               }
          }
          func setNewLockPin(value:NSData) -> Com.Seagate.Kinetic.Proto.Command.Security.Builder {
            self.newLockPin = value
            return self
          }
          internal func clearNewLockPin() -> Com.Seagate.Kinetic.Proto.Command.Security.Builder{
               builderResult.hasNewLockPin = false
               builderResult.newLockPin = NSData()
               return self
          }
          var hasOldErasePin:Bool {
               get {
                    return builderResult.hasOldErasePin
               }
          }
          var oldErasePin:NSData {
               get {
                    return builderResult.oldErasePin
               }
               set (value) {
                   builderResult.hasOldErasePin = true
                   builderResult.oldErasePin = value
               }
          }
          func setOldErasePin(value:NSData) -> Com.Seagate.Kinetic.Proto.Command.Security.Builder {
            self.oldErasePin = value
            return self
          }
          internal func clearOldErasePin() -> Com.Seagate.Kinetic.Proto.Command.Security.Builder{
               builderResult.hasOldErasePin = false
               builderResult.oldErasePin = NSData()
               return self
          }
          var hasNewErasePin:Bool {
               get {
                    return builderResult.hasNewErasePin
               }
          }
          var newErasePin:NSData {
               get {
                    return builderResult.newErasePin
               }
               set (value) {
                   builderResult.hasNewErasePin = true
                   builderResult.newErasePin = value
               }
          }
          func setNewErasePin(value:NSData) -> Com.Seagate.Kinetic.Proto.Command.Security.Builder {
            self.newErasePin = value
            return self
          }
          internal func clearNewErasePin() -> Com.Seagate.Kinetic.Proto.Command.Security.Builder{
               builderResult.hasNewErasePin = false
               builderResult.newErasePin = NSData()
               return self
          }
          override internal var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          internal override func clear() -> Com.Seagate.Kinetic.Proto.Command.Security.Builder {
            builderResult = Com.Seagate.Kinetic.Proto.Command.Security()
            return self
          }
          internal override func clone() throws -> Com.Seagate.Kinetic.Proto.Command.Security.Builder {
            return try Com.Seagate.Kinetic.Proto.Command.Security.builderWithPrototype(builderResult)
          }
          internal override func build() throws -> Com.Seagate.Kinetic.Proto.Command.Security {
               try checkInitialized()
               return buildPartial()
          }
          internal func buildPartial() -> Com.Seagate.Kinetic.Proto.Command.Security {
            let returnMe:Com.Seagate.Kinetic.Proto.Command.Security = builderResult
            return returnMe
          }
          internal func mergeFrom(other:Com.Seagate.Kinetic.Proto.Command.Security) throws -> Com.Seagate.Kinetic.Proto.Command.Security.Builder {
            if other == Com.Seagate.Kinetic.Proto.Command.Security() {
             return self
            }
            if !other.acl.isEmpty  {
               builderResult.acl += other.acl
            }
            if other.hasOldLockPin {
                 oldLockPin = other.oldLockPin
            }
            if other.hasNewLockPin {
                 newLockPin = other.newLockPin
            }
            if other.hasOldErasePin {
                 oldErasePin = other.oldErasePin
            }
            if other.hasNewErasePin {
                 newErasePin = other.newErasePin
            }
            try mergeUnknownFields(other.unknownFields)
            return self
          }
          internal override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.Security.Builder {
               return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
          }
          internal override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.Security.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
            while (true) {
              let tag = try input.readTag()
              switch tag {
              case 0: 
                self.unknownFields = try unknownFieldsBuilder.build()
                return self

              case 18 :
                let subBuilder = Com.Seagate.Kinetic.Proto.Command.Security.Acl.Builder()
                try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
                acl += [subBuilder.buildPartial()]

              case 26 :
                oldLockPin = try input.readData()

              case 34 :
                newLockPin = try input.readData()

              case 42 :
                oldErasePin = try input.readData()

              case 50 :
                newErasePin = try input.readData()

              default:
                if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag))) {
                   unknownFields = try unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
        }

      }

    //Nested type declaration end



    //Nested type declaration start

      final internal class PinOperation : GeneratedMessage, GeneratedMessageProtocol {


          //Enum type declaration start 

          internal enum PinOpType:Int32 {
            case InvalidPinop = -1
            case UnlockPinop = 1
            case LockPinop = 2
            case ErasePinop = 3
            case SecureErasePinop = 4

          }

          //Enum type declaration end 

        private(set) var pinOpType:Command.PinOperation.PinOpType = Command.PinOperation.PinOpType.InvalidPinop
        private(set) var hasPinOpType:Bool = false
        required internal init() {
             super.init()
        }
        override internal func isInitialized() -> Bool {
         return true
        }
        override internal func writeToCodedOutputStream(output:CodedOutputStream) throws {
          if hasPinOpType {
            try output.writeEnum(1, value:pinOpType.rawValue)
          }
          try unknownFields.writeToCodedOutputStream(output)
        }
        override internal func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          if (hasPinOpType) {
            serialize_size += pinOpType.rawValue.computeEnumSize(1)
          }
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        internal class func parseFromData(data:NSData) throws -> Com.Seagate.Kinetic.Proto.Command.PinOperation {
          return try Com.Seagate.Kinetic.Proto.Command.PinOperation.Builder().mergeFromData(data, extensionRegistry:Com.Seagate.Kinetic.Proto.KineticRoot.sharedInstance.extensionRegistry).build()
        }
        internal class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.PinOperation {
          return try Com.Seagate.Kinetic.Proto.Command.PinOperation.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
        }
        internal class func parseFromInputStream(input:NSInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.PinOperation {
          return try Com.Seagate.Kinetic.Proto.Command.PinOperation.Builder().mergeFromInputStream(input).build()
        }
        internal class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.PinOperation {
          return try Com.Seagate.Kinetic.Proto.Command.PinOperation.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        internal class func parseFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.PinOperation {
          return try Com.Seagate.Kinetic.Proto.Command.PinOperation.Builder().mergeFromCodedInputStream(input).build()
        }
        internal class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.PinOperation {
          return try Com.Seagate.Kinetic.Proto.Command.PinOperation.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        internal class func getBuilder() -> Com.Seagate.Kinetic.Proto.Command.PinOperation.Builder {
          return Com.Seagate.Kinetic.Proto.Command.PinOperation.classBuilder() as! Com.Seagate.Kinetic.Proto.Command.PinOperation.Builder
        }
        internal func getBuilder() -> Com.Seagate.Kinetic.Proto.Command.PinOperation.Builder {
          return classBuilder() as! Com.Seagate.Kinetic.Proto.Command.PinOperation.Builder
        }
        internal override class func classBuilder() -> MessageBuilder {
          return Com.Seagate.Kinetic.Proto.Command.PinOperation.Builder()
        }
        internal override func classBuilder() -> MessageBuilder {
          return Com.Seagate.Kinetic.Proto.Command.PinOperation.Builder()
        }
        internal func toBuilder() throws -> Com.Seagate.Kinetic.Proto.Command.PinOperation.Builder {
          return try Com.Seagate.Kinetic.Proto.Command.PinOperation.builderWithPrototype(self)
        }
        internal class func builderWithPrototype(prototype:Com.Seagate.Kinetic.Proto.Command.PinOperation) throws -> Com.Seagate.Kinetic.Proto.Command.PinOperation.Builder {
          return try Com.Seagate.Kinetic.Proto.Command.PinOperation.Builder().mergeFrom(prototype)
        }
        override internal func writeDescriptionTo(inout output:String, indent:String) throws {
          if (hasPinOpType) {
            output += "\(indent) pinOpType: \(pinOpType.rawValue)\n"
          }
          unknownFields.writeDescriptionTo(&output, indent:indent)
        }
        override internal var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasPinOpType {
                   hashCode = (hashCode &* 31) &+ Int(pinOpType.rawValue)
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override internal class func className() -> String {
            return "Com.Seagate.Kinetic.Proto.Command.PinOperation"
        }
        override internal func className() -> String {
            return "Com.Seagate.Kinetic.Proto.Command.PinOperation"
        }
        override internal func classMetaType() -> GeneratedMessage.Type {
            return Com.Seagate.Kinetic.Proto.Command.PinOperation.self
        }
        //Meta information declaration end

        final internal class Builder : GeneratedMessageBuilder {
          private var builderResult:Com.Seagate.Kinetic.Proto.Command.PinOperation = Com.Seagate.Kinetic.Proto.Command.PinOperation()
          internal func getMessage() -> Com.Seagate.Kinetic.Proto.Command.PinOperation {
              return builderResult
          }

          required override internal init () {
             super.init()
          }
            var hasPinOpType:Bool{
                get {
                    return builderResult.hasPinOpType
                }
            }
            var pinOpType:Command.PinOperation.PinOpType {
                get {
                    return builderResult.pinOpType
                }
                set (value) {
                    builderResult.hasPinOpType = true
                    builderResult.pinOpType = value
                }
            }
            internal func setPinOpType(value:Command.PinOperation.PinOpType) -> Com.Seagate.Kinetic.Proto.Command.PinOperation.Builder {
              self.pinOpType = value
              return self
            }
            internal func clearPinOpType() -> Com.Seagate.Kinetic.Proto.Command.PinOperation.Builder {
               builderResult.hasPinOpType = false
               builderResult.pinOpType = .InvalidPinop
               return self
            }
          override internal var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          internal override func clear() -> Com.Seagate.Kinetic.Proto.Command.PinOperation.Builder {
            builderResult = Com.Seagate.Kinetic.Proto.Command.PinOperation()
            return self
          }
          internal override func clone() throws -> Com.Seagate.Kinetic.Proto.Command.PinOperation.Builder {
            return try Com.Seagate.Kinetic.Proto.Command.PinOperation.builderWithPrototype(builderResult)
          }
          internal override func build() throws -> Com.Seagate.Kinetic.Proto.Command.PinOperation {
               try checkInitialized()
               return buildPartial()
          }
          internal func buildPartial() -> Com.Seagate.Kinetic.Proto.Command.PinOperation {
            let returnMe:Com.Seagate.Kinetic.Proto.Command.PinOperation = builderResult
            return returnMe
          }
          internal func mergeFrom(other:Com.Seagate.Kinetic.Proto.Command.PinOperation) throws -> Com.Seagate.Kinetic.Proto.Command.PinOperation.Builder {
            if other == Com.Seagate.Kinetic.Proto.Command.PinOperation() {
             return self
            }
            if other.hasPinOpType {
                 pinOpType = other.pinOpType
            }
            try mergeUnknownFields(other.unknownFields)
            return self
          }
          internal override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.PinOperation.Builder {
               return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
          }
          internal override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.PinOperation.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
            while (true) {
              let tag = try input.readTag()
              switch tag {
              case 0: 
                self.unknownFields = try unknownFieldsBuilder.build()
                return self

              case 8 :
                let valueIntpinOpType = try input.readEnum()
                if let enumspinOpType = Command.PinOperation.PinOpType(rawValue:valueIntpinOpType){
                     pinOpType = enumspinOpType
                } else {
                     try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntpinOpType))
                }

              default:
                if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag))) {
                   unknownFields = try unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
        }

      }

    //Nested type declaration end



      //Enum type declaration start 

      internal enum Synchronization:Int32 {
        case InvalidSynchronization = -1
        case Writethrough = 1
        case Writeback = 2
        case Flush = 3

      }

      //Enum type declaration end 



      //Enum type declaration start 

      internal enum Priority:Int32 {
        case Normal = 5
        case Lowest = 1
        case Lower = 3
        case Higher = 7
        case Highest = 9

      }

      //Enum type declaration end 



      //Enum type declaration start 

      internal enum Algorithm:Int32 {
        case InvalidAlgorithm = -1
        case Sha1 = 1
        case Sha2 = 2
        case Sha3 = 3
        case Crc32 = 4
        case Crc64 = 5

      }

      //Enum type declaration end 



      //Enum type declaration start 

      internal enum MessageType:Int32 {
        case InvalidMessageType = -1
        case Get = 2
        case GetResponse = 1
        case Put = 4
        case PutResponse = 3
        case Delete = 6
        case DeleteResponse = 5
        case Getnext = 8
        case GetnextResponse = 7
        case Getprevious = 10
        case GetpreviousResponse = 9
        case Getkeyrange = 12
        case GetkeyrangeResponse = 11
        case Getversion = 16
        case GetversionResponse = 15
        case Setup = 22
        case SetupResponse = 21
        case Getlog = 24
        case GetlogResponse = 23
        case Security = 26
        case SecurityResponse = 25
        case Peer2Peerpush = 28
        case Peer2PeerpushResponse = 27
        case Noop = 30
        case NoopResponse = 29
        case Flushalldata = 32
        case FlushalldataResponse = 31
        case Pinop = 36
        case PinopResponse = 35
        case Mediascan = 38
        case MediascanResponse = 37
        case Mediaoptimize = 40
        case MediaoptimizeResponse = 39
        case StartBatch = 42
        case StartBatchResponse = 41
        case EndBatch = 44
        case EndBatchResponse = 43
        case AbortBatch = 46
        case AbortBatchResponse = 45

      }

      //Enum type declaration end 

    private(set) var hasHeader:Bool = false
    private(set) var header:Com.Seagate.Kinetic.Proto.Command.Header!
    private(set) var hasBody:Bool = false
    private(set) var body:Com.Seagate.Kinetic.Proto.Command.Body!
    private(set) var hasStatus:Bool = false
    private(set) var status:Com.Seagate.Kinetic.Proto.Command.Status!
    required internal init() {
         super.init()
    }
    override internal func isInitialized() -> Bool {
     return true
    }
    override internal func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasHeader {
        try output.writeMessage(1, value:header)
      }
      if hasBody {
        try output.writeMessage(2, value:body)
      }
      if hasStatus {
        try output.writeMessage(3, value:status)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override internal func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasHeader {
          if let varSizeheader = header?.computeMessageSize(1) {
              serialize_size += varSizeheader
          }
      }
      if hasBody {
          if let varSizebody = body?.computeMessageSize(2) {
              serialize_size += varSizebody
          }
      }
      if hasStatus {
          if let varSizestatus = status?.computeMessageSize(3) {
              serialize_size += varSizestatus
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    internal class func parseFromData(data:NSData) throws -> Com.Seagate.Kinetic.Proto.Command {
      return try Com.Seagate.Kinetic.Proto.Command.Builder().mergeFromData(data, extensionRegistry:Com.Seagate.Kinetic.Proto.KineticRoot.sharedInstance.extensionRegistry).build()
    }
    internal class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command {
      return try Com.Seagate.Kinetic.Proto.Command.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    internal class func parseFromInputStream(input:NSInputStream) throws -> Com.Seagate.Kinetic.Proto.Command {
      return try Com.Seagate.Kinetic.Proto.Command.Builder().mergeFromInputStream(input).build()
    }
    internal class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command {
      return try Com.Seagate.Kinetic.Proto.Command.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    internal class func parseFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Command {
      return try Com.Seagate.Kinetic.Proto.Command.Builder().mergeFromCodedInputStream(input).build()
    }
    internal class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command {
      return try Com.Seagate.Kinetic.Proto.Command.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    internal class func getBuilder() -> Com.Seagate.Kinetic.Proto.Command.Builder {
      return Com.Seagate.Kinetic.Proto.Command.classBuilder() as! Com.Seagate.Kinetic.Proto.Command.Builder
    }
    internal func getBuilder() -> Com.Seagate.Kinetic.Proto.Command.Builder {
      return classBuilder() as! Com.Seagate.Kinetic.Proto.Command.Builder
    }
    internal override class func classBuilder() -> MessageBuilder {
      return Com.Seagate.Kinetic.Proto.Command.Builder()
    }
    internal override func classBuilder() -> MessageBuilder {
      return Com.Seagate.Kinetic.Proto.Command.Builder()
    }
    internal func toBuilder() throws -> Com.Seagate.Kinetic.Proto.Command.Builder {
      return try Com.Seagate.Kinetic.Proto.Command.builderWithPrototype(self)
    }
    internal class func builderWithPrototype(prototype:Com.Seagate.Kinetic.Proto.Command) throws -> Com.Seagate.Kinetic.Proto.Command.Builder {
      return try Com.Seagate.Kinetic.Proto.Command.Builder().mergeFrom(prototype)
    }
    override internal func writeDescriptionTo(inout output:String, indent:String) throws {
      if hasHeader {
        output += "\(indent) header {\n"
        try header?.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent) }\n"
      }
      if hasBody {
        output += "\(indent) body {\n"
        try body?.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent) }\n"
      }
      if hasStatus {
        output += "\(indent) status {\n"
        try status?.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent) }\n"
      }
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override internal var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasHeader {
                if let hashValueheader = header?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueheader
                }
            }
            if hasBody {
                if let hashValuebody = body?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuebody
                }
            }
            if hasStatus {
                if let hashValuestatus = status?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuestatus
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override internal class func className() -> String {
        return "Com.Seagate.Kinetic.Proto.Command"
    }
    override internal func className() -> String {
        return "Com.Seagate.Kinetic.Proto.Command"
    }
    override internal func classMetaType() -> GeneratedMessage.Type {
        return Com.Seagate.Kinetic.Proto.Command.self
    }
    //Meta information declaration end

    final internal class Builder : GeneratedMessageBuilder {
      private var builderResult:Com.Seagate.Kinetic.Proto.Command = Com.Seagate.Kinetic.Proto.Command()
      internal func getMessage() -> Com.Seagate.Kinetic.Proto.Command {
          return builderResult
      }

      required override internal init () {
         super.init()
      }
      var hasHeader:Bool {
           get {
               return builderResult.hasHeader
           }
      }
      var header:Com.Seagate.Kinetic.Proto.Command.Header! {
           get {
               if headerBuilder_ != nil {
                  builderResult.header = headerBuilder_.getMessage()
               }
               return builderResult.header
           }
           set (value) {
               builderResult.hasHeader = true
               builderResult.header = value
           }
      }
      private var headerBuilder_:Com.Seagate.Kinetic.Proto.Command.Header.Builder! {
           didSet {
              builderResult.hasHeader = true
           }
      }
      internal func getHeaderBuilder() -> Com.Seagate.Kinetic.Proto.Command.Header.Builder {
        if headerBuilder_ == nil {
           headerBuilder_ = Com.Seagate.Kinetic.Proto.Command.Header.Builder()
           builderResult.header = headerBuilder_.getMessage()
           if header != nil {
              try! headerBuilder_.mergeFrom(header)
           }
        }
        return headerBuilder_
      }
      func setHeader(value:Com.Seagate.Kinetic.Proto.Command.Header!) -> Com.Seagate.Kinetic.Proto.Command.Builder {
        self.header = value
        return self
      }
      internal func mergeHeader(value:Com.Seagate.Kinetic.Proto.Command.Header) throws -> Com.Seagate.Kinetic.Proto.Command.Builder {
        if builderResult.hasHeader {
          builderResult.header = try Com.Seagate.Kinetic.Proto.Command.Header.builderWithPrototype(builderResult.header).mergeFrom(value).buildPartial()
        } else {
          builderResult.header = value
        }
        builderResult.hasHeader = true
        return self
      }
      internal func clearHeader() -> Com.Seagate.Kinetic.Proto.Command.Builder {
        headerBuilder_ = nil
        builderResult.hasHeader = false
        builderResult.header = nil
        return self
      }
      var hasBody:Bool {
           get {
               return builderResult.hasBody
           }
      }
      var body:Com.Seagate.Kinetic.Proto.Command.Body! {
           get {
               if bodyBuilder_ != nil {
                  builderResult.body = bodyBuilder_.getMessage()
               }
               return builderResult.body
           }
           set (value) {
               builderResult.hasBody = true
               builderResult.body = value
           }
      }
      private var bodyBuilder_:Com.Seagate.Kinetic.Proto.Command.Body.Builder! {
           didSet {
              builderResult.hasBody = true
           }
      }
      internal func getBodyBuilder() -> Com.Seagate.Kinetic.Proto.Command.Body.Builder {
        if bodyBuilder_ == nil {
           bodyBuilder_ = Com.Seagate.Kinetic.Proto.Command.Body.Builder()
           builderResult.body = bodyBuilder_.getMessage()
           if body != nil {
              try! bodyBuilder_.mergeFrom(body)
           }
        }
        return bodyBuilder_
      }
      func setBody(value:Com.Seagate.Kinetic.Proto.Command.Body!) -> Com.Seagate.Kinetic.Proto.Command.Builder {
        self.body = value
        return self
      }
      internal func mergeBody(value:Com.Seagate.Kinetic.Proto.Command.Body) throws -> Com.Seagate.Kinetic.Proto.Command.Builder {
        if builderResult.hasBody {
          builderResult.body = try Com.Seagate.Kinetic.Proto.Command.Body.builderWithPrototype(builderResult.body).mergeFrom(value).buildPartial()
        } else {
          builderResult.body = value
        }
        builderResult.hasBody = true
        return self
      }
      internal func clearBody() -> Com.Seagate.Kinetic.Proto.Command.Builder {
        bodyBuilder_ = nil
        builderResult.hasBody = false
        builderResult.body = nil
        return self
      }
      var hasStatus:Bool {
           get {
               return builderResult.hasStatus
           }
      }
      var status:Com.Seagate.Kinetic.Proto.Command.Status! {
           get {
               if statusBuilder_ != nil {
                  builderResult.status = statusBuilder_.getMessage()
               }
               return builderResult.status
           }
           set (value) {
               builderResult.hasStatus = true
               builderResult.status = value
           }
      }
      private var statusBuilder_:Com.Seagate.Kinetic.Proto.Command.Status.Builder! {
           didSet {
              builderResult.hasStatus = true
           }
      }
      internal func getStatusBuilder() -> Com.Seagate.Kinetic.Proto.Command.Status.Builder {
        if statusBuilder_ == nil {
           statusBuilder_ = Com.Seagate.Kinetic.Proto.Command.Status.Builder()
           builderResult.status = statusBuilder_.getMessage()
           if status != nil {
              try! statusBuilder_.mergeFrom(status)
           }
        }
        return statusBuilder_
      }
      func setStatus(value:Com.Seagate.Kinetic.Proto.Command.Status!) -> Com.Seagate.Kinetic.Proto.Command.Builder {
        self.status = value
        return self
      }
      internal func mergeStatus(value:Com.Seagate.Kinetic.Proto.Command.Status) throws -> Com.Seagate.Kinetic.Proto.Command.Builder {
        if builderResult.hasStatus {
          builderResult.status = try Com.Seagate.Kinetic.Proto.Command.Status.builderWithPrototype(builderResult.status).mergeFrom(value).buildPartial()
        } else {
          builderResult.status = value
        }
        builderResult.hasStatus = true
        return self
      }
      internal func clearStatus() -> Com.Seagate.Kinetic.Proto.Command.Builder {
        statusBuilder_ = nil
        builderResult.hasStatus = false
        builderResult.status = nil
        return self
      }
      override internal var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      internal override func clear() -> Com.Seagate.Kinetic.Proto.Command.Builder {
        builderResult = Com.Seagate.Kinetic.Proto.Command()
        return self
      }
      internal override func clone() throws -> Com.Seagate.Kinetic.Proto.Command.Builder {
        return try Com.Seagate.Kinetic.Proto.Command.builderWithPrototype(builderResult)
      }
      internal override func build() throws -> Com.Seagate.Kinetic.Proto.Command {
           try checkInitialized()
           return buildPartial()
      }
      internal func buildPartial() -> Com.Seagate.Kinetic.Proto.Command {
        let returnMe:Com.Seagate.Kinetic.Proto.Command = builderResult
        return returnMe
      }
      internal func mergeFrom(other:Com.Seagate.Kinetic.Proto.Command) throws -> Com.Seagate.Kinetic.Proto.Command.Builder {
        if other == Com.Seagate.Kinetic.Proto.Command() {
         return self
        }
        if (other.hasHeader) {
            try mergeHeader(other.header)
        }
        if (other.hasBody) {
            try mergeBody(other.body)
        }
        if (other.hasStatus) {
            try mergeStatus(other.status)
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      internal override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Com.Seagate.Kinetic.Proto.Command.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      internal override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Com.Seagate.Kinetic.Proto.Command.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let tag = try input.readTag()
          switch tag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10 :
            let subBuilder:Com.Seagate.Kinetic.Proto.Command.Header.Builder = Com.Seagate.Kinetic.Proto.Command.Header.Builder()
            if hasHeader {
              try subBuilder.mergeFrom(header)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            header = subBuilder.buildPartial()

          case 18 :
            let subBuilder:Com.Seagate.Kinetic.Proto.Command.Body.Builder = Com.Seagate.Kinetic.Proto.Command.Body.Builder()
            if hasBody {
              try subBuilder.mergeFrom(body)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            body = subBuilder.buildPartial()

          case 26 :
            let subBuilder:Com.Seagate.Kinetic.Proto.Command.Status.Builder = Com.Seagate.Kinetic.Proto.Command.Status.Builder()
            if hasStatus {
              try subBuilder.mergeFrom(status)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            status = subBuilder.buildPartial()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }

  }

}

// @@protoc_insertion_point(global_scope)
